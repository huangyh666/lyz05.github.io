<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ubuntu18.04与Win10双系统]]></title>
    <url>%2F2018%2F11%2F25%2FUbuntu18-04%E4%B8%8EWin10%E5%8F%8C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[搭建Ubuntu 18.04与Win10双系统运行环境目标主机：XPS 13 9360目标引导模式：UEFI 安装系统大致步骤 下载ubuntu 18.04.1 LTS镜像Ubuntu官方下载页面 准备4G以上空间U盘，并使用Rufus烧录Rufus官方下载页面 Rufus烧录使用默认配置，先选择U盘，选择好镜像，按要求先使用推荐的烧录方式。 重启电脑，狂按F12进入一次启动页面，选择U盘启动。 先try ubuntu，试试当前版本的Ubuntu与机子的硬件兼容性如何，如果有不兼容的建议换Ubuntu版本，不然找驱动可能要你命。 Install Ubuntu，一路正常安装，进入分区页面时，根据需要分区。至少需要两个区/与swap。启动引导安装位置有两种选择，一种是选择整个硬盘，会覆盖Windows Boot Mannager。另一种是选择分区/boot，装好Ubuntu后重启进入windows使用EasyBCD添加Ubuntu开机引导。 一切顺利的话，重启进入Ubuntu系统。能见到熟悉的Gnome界面 安装Ubuntu下软件我选择的是最小安装，所以不带播放器，office等插件。 Ubuntu安装软件的方式Ubuntu/Debian系都是用deb后缀的安装包，可以直接从软件的官网上下载，deb后缀的包。需要注意的是分清系统是32位还是64位，i386代表32位,amd64代表64位。Linux发行版中的软件绝大部分都有64位版。如果我记得没错的话，不打开选项64位系统无法安装32位。apt-get apt 这两个命令基本一致可以用于更新/搜索/安装/卸载Debian系的软件，并能自动解决依赖问题，是安装的首选方式。对于软件来源可以直接修改Sources.list或添加ppa。Ubuntu14.04和16.04官方默认更新源sources.list和第三方源推荐（干货！）dpkg -i 安装本地的deb包，命令无法直接解决依赖问题，需要再次使用sudo apt install -f解决软件的依赖问题。snap install snap工具安装法pip3 pip python相关的软件安装命令 优化工具Gnome Tweak Tool 参考链接 播放器SMplayer网易云音乐 输入法搜狗输入法 浏览器Google-chrome-stableflash 办公软件wps office字体问题解决方法 编程工具&amp;文本编辑器gitg++vimfpcnotepadqq 视频处理ffmpegx264Aegisub Wine-deepin2018年wine QQ最完美解决方案（多Linux发行版通过测试并稳定运行）TIM微信 下载工具uGet 截图工具Shutter 建议在设置-键盘中设置快捷键命令：shutter -s 博客工具hexo 翻墙工具shadowsocksRlantern 相关软件的配置gedit 首选项，插件看需求notepadqq 配色 编译命令gnome-tweak-tool 根据需求设置]]></content>
      <categories>
        <category>互联网</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电影《你好，之华》]]></title>
    <url>%2F2018%2F11%2F14%2F%E7%94%B5%E5%BD%B1%E3%80%8A%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B9%8B%E5%8D%8E%E3%80%8B%2F</url>
    <content type="text"><![CDATA[契机闲着无聊，想看电影，去“美团”搜索电影票，就看到《你好，之华》这部电影。之前稍有听说过，是因为子枫参演拿了个台湾金马奖的最佳女配。但是，这个电影名字一看就特别的文艺，加之子枫并不是主角，所以没有如我的法眼。但是看看同时段的其他电影，《名侦探柯南：零的执行人》，嗯！昨天就已经看过盗版了，而且这是情怀电影，还不值得我掏钱买电影票。《毒液:致命守护者》，对不起，对漫威题材电影不感兴趣。 没办法，是同档期对手太菜。 最终决定看《你好，之华》有一下几个原因。一是支持一波子枫，早在《李雷和韩梅梅》就想支持一波，幸亏没买那是的票，剧情坑的一批！二是毕竟是金马奖提名影片，加之子枫的最佳女配，说明至少电影还是受电影界的认可的。三是日本导演加女主周迅，日本导演当然也算加分项，因为我也算看过不少日本电影，周迅演技也是得到认可的，我记得曾经看子枫综艺中听说过这个人。 影院看了排期，适合我的最佳排期是15：50，时间稍微紧张一点。主要是还有该死的思政讲座要去听，而且网络签到到最后一刻才签到成功！看一看距离2.8公里，骑行15分钟。实际用时10分钟。这时有单车的重要性就体现出来的。影院环境比我想象中的好，而且价格也便宜。虽然感觉影院里面的屏幕素质一般，有些烧屏，而且好像是投影的硬伤，一到暗环境下就啥都看不见。 剧情一开始就是袁之南去世，骨灰被袁之南的女儿袁睦睦留下，放在家中。袁睦睦收到一封袁之南的初中聚会。于是乎袁之南的妹妹之华代替姐姐参加初中同学聚会。因为之华是学生会主席。在聚会中，之华被其他同学推上舞台发言，因自己不擅长在台上发言，没说几句话就下台了，也因为害怕被人认出就灰溜溜的提前离开了。聚会上的尹川注意到了之华。尽管，他一眼看出了这不是之南而是之华，但并没有拆穿她。发现之华离开后一直追至公交车站。之华以家里离的远为借口，想要提前离开。而尹川却希望能够跟之南（之华）找个地方聊聊，两人最后留下了联系方式。之华回到家中，之华丈夫周文涛惊讶于之华回来的这么早，随后，之华在洗手间卸妆的过程中，被周文涛意外发现之华手机上尹川发来的信息“其实我一直都喜欢你”。随后，周文涛拿起手机质问之华，之华向其解释这是在之南的同学会上加的同学，但是周文涛并不相信，把手机摔了，还用花洒淋手机，最后，手机坏了。之华也干脆不用手机，写了封信向尹川诉说发生的事情。向其抱怨丈夫有意为难她，不仅把婆婆安排回来住，还带了朋友家的两条大狗回来代养。给尹川写信的时候并没有留地址，因为不希望尹川回信。而尹川最终写信到了之南的老家，被睦睦碰巧收到了，睦睦对尹川也是有一定的了解，所以，假装之南给尹川回信。而此刻之华也在婆婆的老师家中，借用老师家的地址给尹川写回信。 镜头回到少年时期，尹川一家搬到之南所在的县城，跟之南在同一所高中。尹川称自己来自北京，爱好足球和写作。而他关注到了之南，就喜欢上了她。恰巧的是尹川的妹妹跟之南的妹妹即之华是同学，她们在玩乐的过程中，遇到了尹川。尹川从之华的口中了解到她是之南的妹妹，就开始从之华的口中获取之南的信息。就在交谈之中之华喜欢上了尹川，愿意帮助尹川传递情书。但每次收到情书后，之华都并没有真正的给到之南。之华不仅给尹川看了很多张姐姐的相片，还在一次偶遇中，让其看到她真正的脸。（平时，因为流感而一直带着口罩）最后，尹川发现了之华并没有将情书转给之南，之南不知说些什么好，只好一个劲的道歉。称自己一定会将这些信转交给之南。之华也履行了他的诺言，将信全部转交给了之南。但她依旧喜欢尹川而不想放弃，在某一天，亲自到尹川家中找他，写了一封信，问“我们能做朋友吗？”遭到尹川的拒绝。尹川在学校被之南拦下，之南希望他能帮她改写毕业发言演讲稿，尹川很谦虚的说自己并不擅长写作，并问了之南为什么选择他来修改演讲稿，之南说她看过了尹川给他写的信，觉得很不错，认为尹川以后能够成为作家。 镜头转回成年后，尹川找到之华写信的地址，登门拜访。之华恰巧也在，之华随便找了个口红化了妆，就把尹川请了进来，说明自已不是有意隐瞒他，代替姐姐之南写信给她，并让其知道姐姐是自杀而死，有可能是得了抑郁症。而之南的丈夫张超是个极其不负责的人，有一次家暴快把之南打死，自己却什么事都没发生的跑了。尹川也找到了张超的居住地，进一步了解了一下张超是什么人。随后，尹川又回到了初中，拍摄了些照片，正好遇到了睦睦和飒然两人在遛狗，尹川一眼就认出她们两个是之南和之华的女儿，因为长得太像了。~那都是一个人演的~，睦睦也认出了尹川，遂邀请尹川到外婆家中做，也就是之南的老家。尹川见到了之南的骨灰，烧了香，泪如雨下。渐渐平复心情后，偶然瞥见书架上的《之南》一书。心中的心结也解开了，他写的《之南》之南真的看过了，睦睦也看过这本书，所以收到信时他就想到了这封信是这本书的作者寄的。 尹川在准备回上海时，最后见了一次之华，将他在初中校园拍的一些照片给了之华看，也将他遇到睦睦和飒然的事告诉了之华。影片结尾以睦睦和她的弟弟打开之南的遗书结束。遗书的内容，与《之南》书的结尾，毕业典礼演讲稿的内容一样。 影后感先从整个影片的结构上说，结构上还是很不错的，固定的长镜头很多，符合多数日影的情况。而且本土化做的超乎想象的好。少年之华之南的装扮，场景，都特别的复古。没有一丝的日本情景在里面，给人一种故事真的发生在中国的感觉。但故事的内核，又具有编剧表达情愫的唯美感。本土化无疑是成功的。虽然在影片中我也一直在吐槽写信这种通讯方式的传统，以及寄信过程中的问题。让我联想到寄信的过程就是UDP，寄出去就没有后文了，无法知晓是否传达成功。而寄信的过程如同http，非加密的容易发生中间人攻击，所以只有写信这种方式才能让故事变的有趣。如同豆瓣简介一样，这是一个含蓄的故事，讲的是错过的故事！不需要直白的表达，就能将人与人的之间的情愫表达出来。]]></content>
      <categories>
        <category>个人</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离散数学主析取范式及主合取范式]]></title>
    <url>%2F2018%2F10%2F27%2F%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B8%BB%E6%9E%90%E5%8F%96%E8%8C%83%E5%BC%8F%E5%8F%8A%E4%B8%BB%E5%90%88%E5%8F%96%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[转载文章]]></content>
      <categories>
        <category>互联网</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>link</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人数字信息存储与分布]]></title>
    <url>%2F2018%2F09%2F30%2F%E4%B8%AA%E4%BA%BA%E6%95%B0%E5%AD%97%E4%BF%A1%E6%81%AF%E5%AD%98%E5%82%A8%E4%B8%8E%E5%88%86%E5%B8%83%2F</url>
    <content type="text"><![CDATA[序标题可能有点奇怪，但我实在找不到好的标题了。主要列举目前我的各种数字信息存储地，以及为何这样存储。本想统一各大平台的信息存储，但最后发现很难做到。因为各大平台的独立性较强，以及整理需要很长时间，也不划算。随着国内版权保护越来越严，国内互联网产品有着各种不稳定因素 (已经被网盘坑的不再信任了) ，因此买了个移动硬盘来备份我的数据。 本地存储移动硬盘空间够大，方便拔插，将网盘中的东西备份，顺便存储一些大的图片视频，以及各种影视剧。 家中台式同样也是空间够大，存储一些只存在于移动硬盘而不再云存储上的数据。 网络云存储小米云主要存储手机上拍摄的照片，视频，录音。通讯录等手机相关信息 (一入miui深似海) 坚果云目前在用的同步盘，同步一些小而常用的文件，例如：编写的程序代码，相关文档。 Google photos备份父母以及相机上的照片视频 GitHub&amp;Coding两个基于git的代码云存储平台。一个国内，一个国外。一个有免费私密项目，一个有大容量项目存储。优劣互补… 七牛云(废弃)博客的图床，视频床。对冷门资源的国内加速。对网络速度要求高的数据存储。因为种种原因，七牛云现在需要提供备案的域名才能申请七牛云的正式域名，临时域名只有30天的时间。所以将博客图床转移，直接存在博客上。 网络收藏豆瓣用于标记电影，电视剧，图书，唱片等相关的状态，以及评分，评论等内容。 酷狗自建的各种歌单，收藏的单曲 网易云音乐收藏专辑及他人建立的歌单 微信&amp;QQ各种公众号，朋友圈的文章，及部分聊天记录 知乎收藏的知乎答案 bilibili收藏的B站相关视频 YouTube关注的各种YouTube频道，及收藏的YouTube视频 酷市场收藏的安卓应用列表 在线社交QQ，微信，贴吧，Facebook，微博，Instagram，telegram]]></content>
      <categories>
        <category>互联网</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[荣誉学院申请表三问]]></title>
    <url>%2F2018%2F09%2F27%2F%E8%8D%A3%E8%AA%89%E5%AD%A6%E9%99%A2%E7%94%B3%E8%AF%B7%E8%A1%A8%E4%B8%89%E9%97%AE%2F</url>
    <content type="text"><![CDATA[您认为的自主学习 您的人生方向 您对荣誉学院理念的理解。 我认为自主学习是作为现代人都应具备的品质。而自主学习与传统的学习不同，他需要你对自己有清晰的认知并有足够的自律性，明确自己需要学习些什么，然后通过各种可行的手段（如阅读，搜索，询问，探讨等方式）自行安排计划学习。从实践的角度出发，我认为我是具备一定的自主学习能力。高中时期，我参加过信息学竞赛，因为每个人的进度不同，所以我们的教练会给我们提供各种资源，引导我们自主学习。而我主要通过与同年级的同学讨论，自己上网查找（博文，维基百科）资料来解决我所遇到的问题。至于人生方向，就目前而言，一方面是继续学习基础知识，大学阶段是最后能有大片时间静下学习的时期，争取考研。另一方面是充实自己的大学校园生活，为融入社会做准备。至于长远的方向，我觉得应当做好自己，适应社会，并为人类社会尽自己微薄之力。荣誉学院能提供一个更广阔的国际化的平台，让我们有机会接触到中国以外的教育，与各国学生一道交流学习。除此之外，荣誉学院对学生的自主学习，自主探讨研究能力有着很高的要求。能够锻炼自身能力，开阔自己的视野，增长自己的见识。]]></content>
      <categories>
        <category>个人</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[china daily摘录]]></title>
    <url>%2F2018%2F09%2F20%2Fchina%20daily%E6%91%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[FIRSTTitles：Dorms’ face recognition gets thumbs-up for convenienceWords word translate word translate face-recognition 人脸识别 assuring 保证 swiping 刷(磁卡) freshman （大学）一年级新生 director 主任 mugshot （俚）脸面照片 checkup 检验 compile 编译，编写 authorities 当局，官方 adopt 采用 canteens 小饭馆 promoting 促进 keep track 注意动向 attendance 出勤 thumbs-up 竖起大拇指 management 管理部门 efficiency 效率 via 通过 luggage 行李 parcels 包裹 Sentence The system, officially put into operation on Sept 1, enables students to enter or exit their dormitories via facial scanning at the entrance, instead of swiping their electronic student ID. Ge Ruxiong, director of the Hangzhou Normal University Information Center, said the university had input all students’ mugshot photos and information into the face-recognition system before the new semester began. “In this way, when they arrive, they were immediately recognized by the checkup systems at the dormitory,” he said. Sun Kejia, a student, said the face-recognition system is very convenient. there is no need to be worried in case we lose or forget to carry our electronic student ID cards。 Summary人脸识别技术运用于大学宿舍和学生考勤，提高了通行效率，方便了学生日常生活。face recognition technology is applied to college dormitories and students attendance, which improve efficiency and convenient student daily life. SECONDTitle: Shine on, harvest moonWords word translate word translate Shine on, harvest moon 满月照人间 reunion 团聚 Intrinsically 内在的 resembles 类似 Academy 学院 customarily 通常 Flaky 薄片状的 pastry 糕点 Dense 密集的 consumption 消费 Repast 饭菜 historical 历史的 Transcends 超越 derived from 来源于 Preserved 保存 worship 崇拜 Incense 焚香 candlesticks 烛台 Altar 祭坛 tackle 着手处理 Sentence In Chinese belief, the roundness of the full moon, seen on the Mid-Autumn Day, means “togetherness. There are various mooncakes on the market, some are for home consumption, while others are expensively packaged to be given as gifts. The point of doing so is to show love and respect to relatives and friends. Chen Yannan, a native of Quanzhou in Southeast China’s Fujian province, who now works for a Beijing-based media firm, says she had to give up going home due to the long distance. Nowadays, more people in the cities tend to celebrate the festival with friends, dining out or taking short trips together. Summary主要介绍中秋节的历史渊源和传统，以及现代人庆祝中秋节的各种方式。This article mainly introduces the history and tradition of the Mid Autumn Festival, and the ways in which modern people celebrate the Mid Autumn Festival.]]></content>
      <categories>
        <category>个人</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>收集</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SAMSUNG Galaxy SⅡ玩机系列]]></title>
    <url>%2F2018%2F09%2F20%2FSAMSUNG%20Galaxy%20S%E2%85%A1%E7%8E%A9%E6%9C%BA%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[前言一次偶然的机会，翻出来了这部古董机。仔细研究了一下，发现这部当年的旗舰机并没有先前想的那样不堪。遂将我研究后的经验写下。 手机来源作为家里第一部智能机，印象深刻。奠定了我对安卓机整体的初步认知。在此之前，我曾用过一段时间的HTC Desire S。感觉还不错，玩跑跑卡丁车，植物大战僵尸，水果忍者等早期游戏，体验都很棒。而且那部机刷了MIUI4，用起来相当的顺手。算是我最早接触的安卓机。也是因此，我产生了对MIUI的信仰。言归正传，让我们来一起看看这部当年的三星机皇。出厂版本是Android 2.3。但实际到手时应该已经是Android 4.0.3。(我记得我没有升级过系统),操作系统是TouchWiz，期间有过软件更新的提醒。但当时的我不知道是干啥子的，就没去更新系统。在当年那就是屏幕大，性能强。厚度薄。买的时候应该是13年，用了1年左右，因为发热严重，续航尿崩，就提前结束了它的使用。后来，我妈换新机，这部手机就归我了。但我也受不了这部机子的高热，时刻感觉会爆炸。(如同Note7一般)随后买了红米1S，弃用之。直到今年(2017)，因为种种原因，不得不再次启用它做备用机。但如今的我，已经有相当好的使用(调教)经验。只要不是硬件硬伤，有相应的第三方软件支持，我就能带这部机重回流畅省电。 原因分析为什么会如此的高耗电，续航崩？首先很容易猜测到是CPU的问题。所以，我打开了CPU-Z，能很明显的看到两个cpu的频率居高不下。这不可能啊，我啥软件都没开啊！打开后台应用进程，好像也没什么问题，最后想到开发者模式似乎可以看各个应用的占用率。于是乎打开开发者模式中的显示CPU使用情况，就很容易发现360安全卫士一直占据第一的位置。当时，我从未想过360会这么耗CPU。 干掉360刚开始的时候，想到可以直接在360中退出，但依旧会有进程残留在后台。最后直接在系统设置应用中将360后台服务结束了。可能是我关了360自动启动的服务，重启后360就再也没有唤醒过了。当然，你可能会问，为什么不直接卸载掉360呢？因为当年智障的我，开启了防卸载功能。360注册了设备管理器，然后我又忘记了解除防卸载的密码。我印象中记得这个功能对系统重置也是很有效的，总之挺强大的。最后只有双清的办法，且慢，我还有很多应用没有备份完。主要还是因为我担心双清会把我内部存储的数据销毁，事实上，就算是双清也会引起问题。(后面会提到) 尝试刷机刷机首要条件，是要有刷机包。突然发现i9100至今还有第三方官方维护系统更新。wow！不愧是三星旗舰机。因为一直找不到三星官方固件下载站点，所以在网上胡乱找了一些刷机包。但还好，这些刷机包都挺小的，300M左右，比起主流机型动辄1G+好太多。因为是这部机初次刷机，所以应当循序渐进慢慢来，先刷官方包升级到最新版，在以安卓版本为顺序刷第三方包来玩。 基于官方4.1.2官方Touchwiz只维护到4.1.2，这是一个十分尴尬的版本号。目前大部分软件最新版最低支持Android KitKat 4.4。更有少部分冷门软件或国外软件要求Android lollipop 5.0。所以，要有较好的软件体验，需要想办法升级安卓版本。但为了防止机子变砖，不敢过早的刷非官方版本的ROM包。 刷机遇阻想要卡刷，首先要有好用的卡刷工具即RECOVERY，第三方rec我首先想到twrp，去官网查询，发现有相应的版本支持。但是只提供了img镜像，可以使用更低版本的twrp刷入，或者线刷，但是我没有电脑，不能线刷。我在网上也找不到低版本的twrp卡刷包。所以只好用官方rec进行刷机了。除了这个基于官方的修改包，我还下载了MIUI包和cm11等其他包，防止某个包因刷机失败而进不了系统。开始卡刷，双清之后重新开机，发现主屏幕一直崩溃，我当时想有可能是我卸载了一些系统软件导致系统的不稳定，又或者是360的锅。总之，如果没有可用的包刷入系统，这部手机就真成砖了。重新回到rec，一个个刷机包试，试到最后一个MIUI包的时候终于成功刷入了。其他的包都因为没有官方签名，而过不了验证。既然如此那就先体验一下MIUI吧！MIUI体验请看下一章。MIUI用了一段时间就又开始做死，想用回官方包。这时我重启发现官方rec替换成CWM了。而CWM是不会进行签名验证，所以成功上了官改的车。 使用体验最新的官改包没有三星自家以及Google自家的云服务，只有最基础的系统软件。大概一页纸的自带app，用Kingroot搞定内置推广，发现好多了。续航不差，流畅度也不差，很稳定。还有一些偏原生的好用的功能。没有之前的WiFi开关bug。我认为可以长久的使用。如果安卓版本再高一点我可能就会长期使用这个ROM了，奈何版本太低，很多软件用不了。所以踏上了Android4.4追寻之路 MIUI V5MIUI官网对这部机型有两位开发者提供的ROM包，均已停更。版本死在MIUI V5。但两个底层安卓版本不同，一个是4.4，一个是4.1.2。 Android 4.4版本MIUI意外的通过官方rec刷入的MIUI。当时只下了这一版本。因为它是最新的。 使用体验卡的不能自理，系统流畅性还行，但是动画时间长。旧版MIUI基本都是靠动画时间来给人一种流畅的感觉。同样也会有大面积的发热现象。 CM11经过我的多方寻找，找到了鼎鼎大名的CM刷机包，这款刷机包，用了之后顿时舒服多了。我的Android版本终于上了4.4，不会遇到连知乎都装不了的问题了。 使用体验如同前面所说，飞一般的流畅，而且还能开启ART模式。但是，随便使用现在最新款的应用，都容易造成CPU高频，继而带来高发热和耗电。因此，只要注意使用旧版的软件，就好了。 总结这次重新研究这部手机，使我对三星有了大的改观。真实的感受到了三星强大的硬件实力。也感受到国产流氓软件对三星的毒害。事实证明不是三星硬件实力不行，而是国产软件太流氓。如果三星的价格能再亲民一点，界面能在好看易用，我可能就会选择三星了！]]></content>
      <categories>
        <category>个人</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017高考试题分析]]></title>
    <url>%2F2017%2F07%2F02%2F2017%E9%AB%98%E8%80%83%E8%AF%95%E9%A2%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[语文论述类文本阅读失误分析缺少对文章应有的标记，时间分配不足，要在文章中找到相应的句子验证选项的正确性。 文学类文本阅读失误分析对文章主旨理解有误，造成大面积的失分。文章主旨：帮助别人，也是帮助自己简答题答题的分析角度不够多小说是为了塑造人物形象，而文章塑造出不畏艰险，认真负责，热心救人的科研工作者的形象。 文言文阅读失误分析断句需要对这段话有全面的了解，了解文意。翻译题需要熟练掌握重要实词的意思。 古代诗词阅读失误分析对诗词的理解不足，答题的层次不够深。 默写失误分析诗词的背诵记忆较薄弱，考试时脑子容易一片空白，要加强背诵及关键字的记忆。 成语题失误分析成语的意思，褒贬意用法，相近成语的区分，了解不足。 语言表达得体题失误分析要了解常用的口语用词，谦辞敬辞，在什么样的语言环境下要用到什么词。 句子填空题失误分析最后一句分析的还不是很到位。根据上下文语意的分析，填空句子与上下文的连贯性，以及上下文中的提示来填空，句子的唯一性一般能确定下来。 理科数学选择题(3)复数有关知识的考察做法需要熟练掌握复数的形式 $ z = a + bi (a,b \in R)$找出题设的反例，或者根据复数的通用形式进行运算，判断命题是否成立。 失误分析做题时思考反例的时间太长，没有合理的用到复数的基本形式进行运算，再进行命题的判断，过于依赖寻找反例 (7)三视图失误分析三视图所对应的立体图形的作图，花费了较长时间。对基本的三视图所对应的立体图形不熟悉。 (9)三角函数做法三角函数间的相互转化的规则记忆例如：左加右减，横坐标伸长$n$倍，$\omega = \frac{1}{n}$ 失误分析对三角函数变化的方法记忆模糊，花了一定的时间验证自己的记忆，以及验证答案的正确性。 (10)圆锥曲线做法在抛物线中，焦点弦的长度等于两交点到准线的距离和。联立直线与抛物线方程组求解，得到相应的表达式使用基本不等式$ a + b &gt;= 2\sqrt{ab}$求得最小值 失误分析考场中没有想到将焦点弦进行转换，觉得列方程组求解的过程过于复杂。继而，随便举例算的答案。 (11)对数||指数的运算比较做法分别将$x,y,z$通过中间量表示出来，用除法比较两个式子的大小，用换底公式约分。 失误分析考场中完全没有头绪，带数字进去比较，花费时间过长。 (12)数列的分组及数列的累加通项的计算做法先将数列进行分组，在对前$k$组进行求和,对最后一组单独拿出来独立计算。熟练使用 $T_{N} = 1 + 2 + 4 + 2^{N-1} = \frac{1 - 2 * 2^{N-1}}{1 - 2} = 2^{N} - 1$ 失误分析考场时想到使用二进制的表示求和找规律，但是实在是没发现什么规律，暴力算过于复杂。没有想到可以将整个数列分组，在用求和公式求和计算。 填空题(16)几何平面图形的立体化&amp;&amp;导数求最值做法观察图形得知，外围的三个三角形是等腰全等三角形。可以设边长为x求得三棱锥体积的表达式。对表达式求到后，得最大值 失误分析考场中没有算得三棱锥的表达式，将平面图形立体化。 简答题(17)(2)三角函数求周长做法根据(1)凑出$cos(B+C)$解得角度A，由面积解得bc，用余弦定理得到$ b^2 + c^2 $,继而求出面积。 失误分析没有想到可以用（1）所得结论来解体。盲目的使用正弦余弦定理。 (19)(2)概率统计失误分析当时看到就懵了，完全不知道要答什么，也没有耐心看后面的内容。 (20)(2)圆锥曲线题&amp;&amp;(21)(2)函数求导题失误分析这部分内容较难，做题时时间不够。圆锥曲线题花些时间还是可以做出来的。函数求导题涉及到对a的分类讨论，情况比较多，最后一种情况难，平时也很少练。 (22)(2)坐标系与参数方程失误分析对于这题而言，考场中使用的方法复杂，使用直线与椭圆相切的做法求直线到椭圆的最大值，相当耗时，尽管最后做了出来。 英语阅读B失误分析 25.无中生有，误以为小猫头鹰受伤而文中并没有明确表示猫头鹰受伤，作者只是赶过去看情况。 阅读C失误分析 28.原文句子意思理解不透，单词记忆不熟，类似于：awareness，significance，potential。造成选择错误。 阅读D失误分析 32.选项单词意思理解有误。delicate——熟练的，portable——轻便的。文中说蒸馏装置的便携性强，可以折叠后纳入小包，并系在腰间。 33.接水器是整个蒸馏装置，而不是单个杯子，杯子虽能接水，但光杯子一个不能起到蒸馏作用。 34.看文章时没有注意到真正的最后一步是在塑料膜中央放置些石子将塑料膜压下去。 7选5失误分析填空处句子的上下文关联性，了解的不够细致。 完形填空失误分析 46.故事发生在上大学的第一周，引出后文学习手语的经历。而不是有会议。 48.不用语言交流，只用手部动作的想法（idea）吸引了我。不是交流的多少（amount） 52.不是想得到更多的手语练习，而是想要探索更多关于手语的东西。 57.prohibit——禁止，词语意思理解不到位 58.转折关系，instead——相反 59.句子理解，cause——造成 理综(132=46+32+54)单选题(生物) 2.考试前看过台盼蓝用于检测细胞膜的完整性，选了A。双缩脲试剂实际上是与蛋白质中的肽键反应，氨基酸不含肽键，所以不能进行染色。 4.因为第二次作用时才有症状发生，第一次没有发生，所以是过敏反应，而不是呼吸抑制剂，抑制呼吸系统。考试时，没有想清为什么第一次作用是症状没有发生，而第二次发生了，错选D。 单选题(化学) 7.合成纤维是人工合成的，与天然不同。宣纸，羊绒衫，棉衬衣都是天然材料，只有尼龙绳是合成的。考试时，不了解各个用品的材质。 8.蒸馏需要加热液体混合物，生砒是固体，文中是固-气-固的过程，升华符合要求。考试时，没注意蒸馏需要液体混合物。 9.(d)的二氯代物有6种，(d)中左右两边不在一个平面上。考试时认为(d)在同一平面上，二氯代物有6种。 11.C高硅铸铁是惰性辅助材料，不被损耗，D溶液环境不同需要根据腐蚀趋势，调整电流。A腐蚀电流就是钢管柱与海水之间的腐蚀作用，因为有外电路存在，所以腐蚀电流接近于0。考试时，不理解腐蚀电流的意思。 单选题(物理) 14.没有区分好动量与冲量的不同，冲量是动量的变化量。因为动量守恒，火箭的动量大小等同于燃料的动量，方向相反。 16.每个微粒都受到三个力的作用，重力竖直向下，电场力竖直向上，a磁场力指向圆心，b磁场力竖直向上，c磁场力竖直向下。考试时，没有准确的分析出粒子的受力情况。$\therefore M_{b} &gt; M_{a} &gt; M_{c}$ 18.题目的意思是让我们找出一种方案，使得紫铜薄板向左，向右，向上，向下，都可以产生磁通量的变化。只有A符合，考试时没有理解清题意。 19.同向电流相吸，异向电流相斥，根据这条原理作图，计算。关键在于对上述原理的理解与记忆。 20.结合$E = \frac{kQ}{r^{2}}$与$W = Uq$两个公式，计算。观察图像及图例，明白图像的意思。 简答题（物理） 23.(1)电压从0开始采用分压法,$ R_{x}^{2} = R_{A}*R_{v} $, 故采用外接法，电压表量程不够，串联R0分压。考试时，时间不足。(3)最小功率时，滑动变阻器阻值最大，$4=U+10I$；最大功率时，滑动变阻器阻值最小,$4=U+I$,画出这两个函数的对应图像，找交点，得到对应的U与I。再根据$W = I^{2}*R$计算小灯泡的功率。时间不足，没有细想。 24.(2)$mgh_{2}-W_{f} = \frac{1}{2}mv_{1}^{2}-\frac{1}{2}mv_{2}^{2}$，时间不足及信心不足，认真列式计算即可。 25.(1)由动量定理得：$E_{2}qt_{1}-E_{2}qt_{1}-2mgt_{1} = mv_{b}-mv_{0}$(2)$H_{0} = \frac{v_{0}^{2}}{2g}$根据A，B点的相对位置进行讨论。$H = \frac{H_{0}}{2} = H_{1}+H_{2}$ ， $H_1 = v_0t_1+\frac{1}{2}a_1t_1^2$;$H_2 = v_Bt_1+\frac{1}{2}a_2t_1^2$ ;$ma_1 = E_2q - mg ; ma_2 = -E_2q-mg;E_1q = mg$,$\because E_2&gt;E_1$ 得到对应的关系式。关键在于作图，电场强度与时间的图像，分析每个阶段粒子所属的状态：速度，受力情况等。(1)问相对简单，(2)问较难，需要分类讨论，字母运算，解不等式，并求出范围。计算复杂度高。 简答题（化学） 26.(1)a是玻璃导管，用于平衡气压。考试时，辨认不当，认为a是温度计。(2)f是直型冷凝管。考试时，没有想起冷凝管具体的类型，只填了“冷凝管”。(3)水蒸气充满管路，停止加热后，水蒸气冷凝成水，管路内压强减小，蒸馏水到吸入装置C。考试时，认为蒸馏水倒流进装置C，比较难，中间还有装置e。(4)铵盐与氢氧化钠反应，氨气逸出。防止氨气逸出，造成环境污染。双层玻璃瓶起隔热保温作用。(5)根据元素守恒，$NH_3*H_3BO_4 + HCl = NH_4Cl + H_3BO_3$得知HCl与$NH_3*H_3BO_4$为$1:1$反应。$\therefore n(N) = n(C_2H_3NO_2) = n(HCl) = cv*10^{-3} mol$,$m(N) = 14cv*10^{-3}$，考试时，因题目涉及计算相关，比较复杂，就很快跳过了。 27.(2)盐酸与钛铁矿反应生成$TiOCl_{4}^{2-}$和水。知晓反应物和生成物，配平就很简单了。考试时，没有搞清楚反应物是什么。(3)从两方面考虑低于40℃，反应随温度升高而增大，高于40℃双氧水分解，氨水分解，反应物减少，印象反应进行。考试时，没有想明白高于40℃，反应为什么减缓。(5)了解$K_{sp}$公式的计算方法，算得$1.0*10{-24}&gt;1.69*10^{-40}$,此时，无沉淀生成。考试时，时间不够。(6)从图中获知反应物为$FePO_4和Li_2CO_3$，推得生成物有二氧化碳，水和$LiFePO_4$，关键在于反应物和生成物是什么。化学方程式考察中。反应物及生成物推断能力弱。 28.(1)D.物质的还原性大小与微粒中元素的化合价及微粒结构有关，与其电离产生氢离子的浓度大小无关。B.同是二元弱酸，溶液中离子浓度越大，溶液的导电性就越强。考试时，对酸性强弱比较的方法理解不清。(2)加快运算速度。考试时，花费了太多时间在运算中。(3)三段式计算，设反应xmol物质，解得x=0.01mol，$\therefore \alpha_1 = \frac{0.01}{0.40}*100\% = 2.5\%$；直接计算反应平衡常数K；$620K&gt;610K$温度升高，水的物质的量增大，平衡右移，反应吸热。$\alpha_2 &gt; \alpha_1$。 简答题（生物） 29.(1)将若干宿主细胞均分为甲、乙两组，分别用放射性同位素标记甲组培养基中的（T）与乙组培养基中的（U），用新型病毒分别侵染两组宿主细胞，于适宜环境中培养一段时间，检测甲乙两组中，新生病毒的放射性;(2)若甲组检测到放射性，乙组未检测到放射性，则为DNA病毒；若甲组为检测到放射性，乙组检测到放射性，，则为RNA病毒。考试时，没见过这种生物简答题，考得不好。 30.表述不够清晰，二氧化碳、氧气的变化情况，进而影响光合作用，有氧呼吸。 31.(3)内环境的作用主要为，①细胞生存的直接环境②细胞与外界环境进行物质交换的媒介。考试时，内环境的作用记忆不牢。 32.(2)因为黑毛：白猫=3:1，$\therefore$黑毛是显性，白毛是隐性。假设是否位于性染色体上。推测结果。(3)用心数即可，你要漏掉一些特殊情况。 选做题（物理） 33.(2)熟练运用$PV=nRT$这个公式，抓住不变量，温度或体积不变。 选做题（化学） 36.熟练掌握官能团的变化，各个有机物的名称。 选做题（生物） 38.(3)大肠杆菌作为受体细胞的优点有：易培养，繁殖快，单细胞，遗传物质简单。(5)艾弗里等人的肺炎双球菌转化实验证明DNA是遗传物质，并证明将一种生物的DNA导入并整合到另一种生物的DNA上，并能稳定的遗传和表达，作为基因工程得以实现的理论基础。]]></content>
      <categories>
        <category>个人</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红米3S玩机系列]]></title>
    <url>%2F2016%2F10%2F24%2F%E7%BA%A2%E7%B1%B33S%E7%8E%A9%E6%9C%BA%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[前言红米1S提前退休，对于我这种喜旧厌新的人来说，多少还是有点感情的。(毕竟是第一部智能机)对于选手机这件事，品牌只能是小米(一入MIUI深似海，谁叫我已经入坑了呢)。因为至今，我也没有找到更好的系统来替代MIUI。为了及时获得MIUI的系统更新，我只能选择小米手机啦。因此，重要的事情说三遍 我是去买系统的 我是去买系统的 我是去买系统的 再加上小米手机价格屠夫的称号，那是相当的划算。(除耳机外，我所用过的小米系列产品品控都不错。) 9月16日拿到的新机，整体感觉还不错。 这部机子虽然性能不算强，(比前代红米3略差)但是主打续航。4100mah的电池容量，相比之前我的手机红米1S来说电池容量翻了倍。在屏幕尺寸有所提升的情况下，耗电速度与红米1S相当。GPU相比红米3有所提升，但对于我这种不玩游戏的人来说，并无卵用。CPU也从联发科的换成了高通。配备有指纹解锁功能。为了紧扣题目，下面就是有关红米3S的玩机教程啦。 手机信息手机刚拿到手，预装的就是当时最新MIUI7.5稳定版，安卓版本6.0。由于第一次用这种不可拆卸型的手机，刚开始装卡时遇到了些麻烦。原来是要用撞针用力捅进去，卡槽才会弹出来。(毕竟是乡下人)卡槽类型为双卡+单卡与micro sd卡。 BL锁要想顺畅的玩机，最先做的就是解BL锁，现在市面上大部分的安卓机型都加上了BL锁。这个可以上小米官网申请解锁。打开申请解锁的网址，申请时要求填写申请理由，随便写写凑够字数就行了(据说审核是机审)。官网说将在10个工作日处理。然而实际上3天就受理成功了。下载解锁工具后，解锁工具将会联网验证手机上对应的小米账号是否解锁。解锁工具使用一次就失效了。至于如何上锁，我就不清楚了。BL锁是为了防止手机被第三方软件执行刷机，root等操作。保证系统不被其他非官方ROM破坏。(比如之前的360雷电OS系统系列)这样做后包括电脑端与手机端在内的各种各样的刷机软件与ROOT都将失效。也无法使用与刷入Recovery。好处就是能够保障手机不被其他流氓软件侵扰。MIUI在抗流氓软件上还是非常有效的。 卡刷TWRP(Recovery)TWRP(Teamwork Recovery Project)一款相当强大的Android Recovery软件。可视化触屏操作，多语言支持，多插件支持。简直就是一款强大的Windows PE。完成BL解锁后，接着应当刷入第三方的Recovery，本身自带的Recovery因为没有界面而无法使用。自带的Recovery往往只能刷入官方包，而不能刷入修改定制后的包，所以换Recovery就显得至关重要了。刷入TWRP方法还是相当的简单。首先保证电脑与手机的正常连接，手机进入fastboot模式，电脑中与手机相关的驱动运行正常。具备这些前提条件后，执行一下相应的批处理命令即可。这里有批处理命令相关代码:&lt;!- 批处理命令相关代码，以及相关命令解释&gt;一般只需要1-2s就可刷入Recovery。对于小米官方ROM，需要在高级菜单下，执行删除DM效验，否则将无法通过手机启动到TWRP。这样就造成每次刷完官方包后都需要执行一次以上的操作。TWRP除了具备普通Recovery中基本的擦除数据，以及刷入zip包。还具有MTP功能，将文件(刷机包)从电脑传入到手机中，虽然对外部sd卡中文支持不佳。这个MTP好像有容量判断上的问题，要确保拷入的文件大小不超过本身设备的可用容量。对于一般拷ROM包还是没问题的。拥有小型的文件管理，可以通过刷入插件变得更强。对于条件允许的机型可以刷双系统(然而，我在网上并没有找到红米3S的解决方案)。刷入aroma插件后，可以刷入具有可视化界面的刷机包。(功能强大到令人发指)可以说只要TWRP还在，就不怕救转不成功。 线刷一般情况下都不需要执行这种刷机方式。当然也有特例。比如说Recovery挂了(我还没试过)，Recovery功能不齐全(MI recovery 2.0.1)，Recovery无法执行刷机操作(某次卸载系统更新)。一般都是很作死的情况下，才需要此般折腾。首先当然是下载先刷工具啦，网上有很多相关教程。但我还是更相信并依赖于小米官方。从小米官网上下载刷机工具以及对应机型的线刷包，后缀一般都是tar.gz(Linux压缩包格式)。解压压缩包，手机进入fastboot界面，刷机工具选择解压后的目录。因为小米没有提供不清空\sdcard目录的线刷脚本，所以要勾选清楚内部存储器的选择框。执行三清后刷机。我在线刷时，刷机工具并没有显示完成的对话框，不用担心，只要没有报错，耐心等待就行，直到手机自动重启即可。(大概需要500s)线刷是相当全面的刷机，包括Recovery也会被替换。如果想要一个干净的官方系统可以试试。 ROOT折腾了这么多，最终就是为了ROOT而做准备。之前红米1S，我一直都是用的都是KingRoot。然而，这次KingRoot并不支持红米3S。也用过类似奇兔刷机等其他ROOT工具，都无效。之前听说过有一个很强的ROOT授权管理工具(SuperSU)。之前在龙哥的平板上见过，因为界面比较丑陋，然后懒得折腾就没用。对于MIUI系统来说，其实不用那么麻烦刷第三方ROOT。默认都可以通过刷开发版来获取ROOT。但是，红米3S开发版的ROOT有被阉割，就算是给钛备份授权了ROOT，依旧无法恢复数据。而且官方ROOT有25s授权验证。并且每次OTA升级或者重刷系统会掉ROOT，每次又要重新下载ROOT包并授权。还是相当的繁琐的。因为SuperSU的zip包是全机型通用的，直接上网下刷机包刷入就好了(无需双清)为了确保能够成功刷入，最好使用第三方的Recovery。刷完之后默认就会使用SuperSU进行授权管理，新版的SuperSU已经不在丑陋了，并且非常的干净，无广告。 Xposed框架Xposed框架通过修改一些基础的系统软件，达到其他基于Xposed框架的模组能够更容易的对系统进行定制或修改。在Android5.0以前版本的系统可以直接安装Xposed Installer获取ROOT权限后替换系统文件即可安装成功。Android5.0以上的只能通过刷Xposed包完成安装，在官网上提供机型的Android版本与处理器平台后，找到对应版本下载。因为MIUI的特殊性直接刷入官网的Xposed并没有用，需要安装某个大神定制的Xposed by MIUI才行。安装这个框架后就可以使用各种强悍的功能了。 ROM包好不容易换手机了，为何不使用一些非MIUI的包呢？之前用过刷机精灵提供的ROM包，但里面太多内置推广了，还不如官方包。所以，最好去环境相对好的论坛，比如说MIUI论坛。在里面我已经看到了大神制作的AOSP,CM，RR等ROM。试用了一下CM，感觉还不错。系统贴近原生，干净，没有乱七八糟的软件，省流量，系统后台基本无流量消耗。缺点也很明显，开源嘛，所以没有云服务咯。但是，我还是习惯了使用小米全家桶。而CM作为一个开源社区，来源软件，本身并不提供云服务，而我还是过于依赖小米的云服务。所以，没用几天就用回去了。另外CM还是比较耗电的。加了绿色守护之后，明显好了超多。AOSP没用过，不置评。最后，为了长期使用，还是得用回MIUI，在MIUI论坛上，我看到了一些人，对MIUI进行定制修改，其中我看中了两个人的ROM。一个是基于稳定版的极光ROM，一个是基于开发版的bbk520ROM。但我还是更喜欢后者。以至于到写这篇博文为止，还在使用这个ROM包。极光提供的包，功能不太多，因为设置界面太丑了，所以没用。bbk520提供的包(去除推广后)功能很多，自带了ROOT,Xposed,音效软件。还提供了多种基于Xposed的模组。 去除系统更新不得不提，一直以来我都解决不了该死的系统更新问题。两次线刷都是系统更新的锅。第一次在用红米1S使用KingRoot中的卸载系统应用功能，卸载之后重启手机，就卡白米了，虽然MI-recovery还是可以用，但是这是一个阉割功能的Recovery，因为必须将ROM包拷贝到内部存储根目录下，并改名为update.zip，但我现在压根传不了文件进去。第二次在用红米3S，因为冻结了系统更新，卡白米。在启动的时候疯狂的优化应用程序，最后强制重启进去TWRP，但是TWRP写不了\system。所以…除此之外，还有更改版本号，关闭通知等各种作死行为。]]></content>
      <categories>
        <category>互联网</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDOI2016旅游记]]></title>
    <url>%2F2016%2F05%2F12%2FGDOI2016%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概述第二年亦是最后一年GDOI。那当然就是去旅游的啦！像我这种连NOIP一等奖都拿不到的蒟蒻……今年GDOI在四会中学进行哦！$成绩 = 50+90+0$ DAY0本想着今年四会会比去年粤北地区韶关好一点的。结果……在车上，我和龙哥还预测着我们会住哪个宾馆。结果，让我们感受一下距离。遥想去年此刻，我们还能步行回宾馆。然而这里的宾馆真的什么都没有，也多亏我们选了一个很好的5楼房间。这里的电梯只能到4楼，并且每一个楼梯间都能通到不同的5楼。幸亏凭借我们高超的智商，很快就找到了我们的房间。但对于住8楼的同学，我就是在无能为力了，真搞不懂为什么对面的1楼是8楼。其实，最好的房间应该是8楼，有液晶电视哦！！我们那边还是显像管电视，龙哥带了各种转接线，然而并无卵用。让我们感受一下神奇的5楼楼梯间。尤其吐槽的是4号车，新车甲醛味道可真重啊！学校感觉还不错，饭菜也比去年正常多了。听说，有机会试机，然而，我连机房在哪都不知道。 DAY1早早的起来了!!我们不慌不忙的来到了宾馆1楼的食堂。WTF！！！（此处允许我盗图，来源：dwj）于是，我们做出了在学校买好早餐，明天吃的决定。到了考场，8:00左右，推迟了15分钟开考吧！反正在此之前，我是真心什么都没准备的！ T1:中学生数学题自从今年GDKOI开始各种各样的学生就来了，就差幼儿园了…这不就是二次函数求最大值吗？？难道不能直接算，算算发现不对，有向下取整操作！但本人坚信此题可以O(1)出解，鸟都不鸟下面的数据范围。化简成二次函数之后，可以直接求出最大的利润P，然后反推回去$n=\lfloor n0-kp \rfloor$得到n,然后尝试将P在增大,但不会超过所计算出的n。可能这种方法是错的…对于第二问，推了一下子，好像还要分类讨论，看起来很复杂的样子，那就算了…. T2:最长公共子串感觉上是dp题嘛，像我这种暴力选手。当然要用暴力的方法。通过第二个样例可以发现，区间可以合并，我们并不需要求最少的替换次数，所以可以不用管。这样我们可以把所有能合并的区间合并，得到一个大集合，由若干个小集合所组成。这样我们可以枚举两个区间，对于左右两个最边边的区间，里面的元素可以不用取光，中间集合中的元素必须全部取光。用这种方法去做搜索匹配就好了!时间复杂度就是能匹配成功的所有序列长度的和。然而这样做虽然在随机数据状态下表现良好，但如果有些用心良苦的数据，GG！ T3:有趣的一关期望弃疗！亏我刚学过数学期望，还要列什么分布列，然而并无卵用，连样例都不知道是怎么出来的还做什么做！！ T4:疯狂动物城这次旅游的一项任务就是看疯狂动物城，然而考试的时候并没有看。这是剧透啊！！！不能忍啊！！！而且还把如此呆萌的Flash改的如此邪恶！！！(⊙﹏⊙)b据说WWT大神被delta异或给坑了，然而我已经不记得我怎么打得了，好像这题有20分。提炼题目就是，两个点之间的距离乘上一个累加值的和。因为有累加值，所以倍增无能啊！那我就一个个跳咯！考验一下调试代码的能力，虽说有20%的特殊数据，但也想不到怎么做… DAY1就大致这样了，评奖的时候顺便刷一波日剧……据说是为了提升我省队选手的数学水平，所以有了这份试题！！ 《我的乖乖女》你看不到我！！ DAY2早餐队伍奇迹般消失了，终于吸取教训了…… T1:SigemaGOspfa直接上，但是有个问题，如果我对所有的$(u,v’)(v’,v)$中的$(u,v)$都连一条边,那会超时的,而且spfa也忘了有个神奇的队列优化。然而最后有2个崩溃，6个WA，表示不知为何WA… T2:森林之家这个游戏挺有趣的嘛，回去下了一下来玩，然而国产某mi手机没有GOOGLE应用框架啊！穷人玩不起啊！像我这种傻逼，肯定直接搜索啊！我什么剪枝好像都没加，就有了50。(⊙﹏⊙)b！ T3:机密网络只需要解决第1问，那就随便枚举跑图咯 T4:飞机看题目弃疗，什么小岛啊，边长啊，联通块啊！都是浮云… DAY3早早就知道没戏了…做好去旅游的准备，然而其实就是步行瞎走，然后当地气温倍儿高。所以，干脆折返看剧算了！！送上一副图。 DAY4坐车到闭幕式现场就已经迟到了，这次会议比去年快多了呀！当听到郭老师说这次15人终于不是这两个学校垄断时，居然莫名喜感。其实还是垄断了呀！但是石门的消失我还是很惊讶的！带来的精神食粮也差不多用完了，辛亏有充足的准备，才能在这种不能用的wifi状态下挺过去。 《我的乖乖女》萌萌果的声音真是太软了，接受无能啊！《相棒》还是觉得s10e10好！当然也有几级脑洞挺大的！相比脑残《柯南》算是非常好的了。]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网盘的那些事]]></title>
    <url>%2F2016%2F05%2F11%2F%E7%BD%91%E7%9B%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[契机因为受到了一万点来自快盘的伤害，所以我决定要写篇博文记录，并回忆这些年来与各种各样的网盘发生形形色色的事。 早期早在小学时期，我就曾经用过最早期的163网易邮箱网盘。当时的口号还挺厉害的：2GB的存储空间，抛弃U盘。 在当时其实挺不现实的，家里还用着512k的网速，但相较于U盘有着无可比拟的优势。不需要带着U盘到处跑，也不用担心U盘中的病毒，只要在任何能够联网的电脑都可以拿到文件。 于是我在小学时期就通过网易的邮箱网盘收集了许多资料，这些资料也跟着我不断的换网盘，而不断的转移。 在这段时间，我好像见过中国电信的同步盘，但并没有用过。 快盘 契机遇到金山快盘源于黑基网的一篇文章。最初只有免费的5G容量，但可以不断的使用增加容量。最开始只有同步盘的客户端，是为了配合WPS的使用。金山做软件我还是很放心的，没有怎么令我失望过。(话说，我也是大概在这个时候认识的雷军和傅盛)金山的软件界面美观，运行速度也快。所以，至今我仍在用很多他们出品的软件，尽管现在已经落寞了。(也是因此让我对小米的软件miui放心) 使用体验体验是相当不错的，并且金山也挺重视。论坛上讨论的人也很多。对于很多需要用U盘传输文件的商业人士，帮助确实很大。 诸如各式各样的图标状态显示，历史记录查询，同步目录选择，极速秒传… 但是便捷式网盘就做得非常差了，有时对一些大型的文件夹重命名都不可以。 波折当快盘刚起步时，国内的网盘商还是相当少的。本来可以好好的继续改进产品，增加用户粘性的。却没有抓住这个机会。被后来居上的百度云，360，微盘所超过。 后面也是觉得快盘开始力不从心，加之存储式的网盘做得不好，通过多层比较最后确定了使用百度云。 关停2015年4.28号宣布停止个人存储业务。6,30开始删数据。对于这条消息，完全在我的意料之内，但是，没想到这一天来的实在是太快了。让我没有一个充足的准备。 更无语的是，除了官网上的那个小小的公告，竟然在其他地方没有任何关停的消息。客户端好歹也可以弹个窗啊！搞得很没事人一样，要不是我突然在知乎上看到其他网盘关停的消息，我还不一定会去官网。后来证实给我的邮箱发了封邮件。 金山T盘 在我用快盘不到1年的时间，金山(珠海)又做出了一个T盘，功能跟快盘一模一样，就是空间加到了1T。就连应用都是一模一样的，就改了个名字。 刚开始使用时还需要强邀请码，第一次体会到邀请码是多么的难强。凭着我家的弱网速，花费了3分钟才抢到了一个。6分钟就抢光了！ 所以我就着手快盘到T盘的迁移工作。事实是，不过1年，金山就宣布停止服务了，提供工具给我们将数据转向快盘。说好的1T就这样的没了。因为在T盘使用容量没超过20G，所以就以最低20G打发了我到快盘。 当时就感觉我被骗了，说好的永久免费的1TB呢… 115网盘 115网盘也算是一个极为早期的网盘，现在(2016)也还在，但随着分享功能的失效，使用的人数越来越少。 我最初用的时候,好像并没有同步盘的功能,软件页面像是一个下载器。空间上也没有什么竞争力。偶尔传些数据也就没多大用处了。 Dbank华为网盘 这是我使用的第一个华为的软件服务。很早以前，就用过华为做得modern,虽然坏过很多次，但好歹也是全球500强公司，公司页面也够简洁，低调。虽说华为做得UI，确实叫人着。 因为华为网盘的网页端对同步盘与非同步盘有明显的分割，并且能够很方便的转移。其他功能又和快盘差不多。为了能够达成文件的统一，我又一次的将文件从快盘搬了过去。 最后，也逃不过我的放弃。然而放弃的原因我已经忘记了 360云盘 听说360要出云盘了，而且还是36T哦！听到这，我就没敢用，因为我坚信360这样做吃枣药丸。然而我好像打脸了，因为到2016它还是正常运营的，反而快盘挂了。360还是有其他优势的，他的网盘支持离线下载，分享的外链也很简洁。速度也很快。当时就当作为我的cc软件集发布工具用了。 百度云百度三大良心产品之一啊！！第一就要颁给百度云啦！搜索和贴吧只能排到后面。改签了以前我眼中的网盘的样子。百度云初期那是相当的业界良心啊！！也正式因此使他后来居上，成为网盘界的佼佼者。每个账号都可以获得2T的空间，他的同步功能虽然不如Dropbox，但在其他方面还是很有优势的。不用担心被墙的问题。离线下载支持很多协议，如果先前有人离线过了，就可以直接存在网盘里，初期的分享是不限速的。虽然客户端做的比较差，卡的不行！网页端做的还是相当可以，无论是建立，删除，移动，重命名速度都很快！还有得益于百度的强大搜索功能。当然这些只是网盘的基础服务，只是百度云将这些服务做得更好罢了。百度云的强大在于它将数据用活了起来。压缩包可以直接在云端解压查看，office系列文件，可以直接在网页上浏览。视频也可以直接观看，选择不同的画质。在国内，也只有百度云将网盘做成这样的方便。虽然，国外也有很多类似的网盘，但都逃不过速度慢，被墙，空间小这些缺陷。 GitHub良心网站啊，空间无上限，还不怕被墙。(虽然随时有要墙掉的风险)然而他并不是真正的网盘！！！但用他来存一些开放的小文件还是可行的！而且有直链哦！加上IDM多线程加速，速度不是问题！总之现在是被我用来存放信息学程序，翻墙工具及博客网站数据的地方。 七牛云存储空间只有1个G，用来存网站的静态数据绰绰有余了，速度很快，毕竟国内CDN加速。还支持其他的文件处理服务。 其他我也记不得还用过哪些网盘啦！总之，上面的都是那些我用了有一段时间，让我还有记忆的网盘。国外的网盘还真的没用过，但因为我不能时刻保证都可以越过GFW。所以，就算是体验再好，关键时刻用不了也是很影响体验的！ 总结因为现在已经有很多家网盘商，放弃了个人网盘，这种拖后腿不赚钱的业务。而我的网盘数据又众多，我又不想存在本地磁盘上占用空间。又不想突然间挂了，还要搬来搬去。还好，现在在学校，网速够快，要不然100G的文件要我搬多久啊！！这次，众多网盘关闭，让我不再敢相信国内的网盘服务了！万一哪天数据说没就没了呢！承担不起啊！！但是国外的网盘又不能保证时时刻刻都能用，所以经过我的深思熟虑的得到了一下对策！ 对策同步盘：坚果云，小米云备份盘：百度云，移动硬盘程序： Github，Coding图片与视频：Google Photos 手机上的数据就交给小米云了。~(&gt;_&lt;)~呜呜，谁叫我上了miui这条贼船呢！当然小米云还是很贴心的，各种数据都能备份。妈妈再也不用担心我刷机后丢数据啦！网速好的状态下，半个小时新手机就能变成旧手机。坚果云，还没怎么用，除了界面丑了点，限制上传下载数据量坑了点，其他还好！知乎众多用户的推荐，你值得拥有！据说是国内学Dropbox学的最像的。剩下的那种又大又笨拙，还不经常用的数据只好放在百度云了，毕竟有百度靠着。比什么360靠谱多了！因为Csdn Code能够免费创建私密仓库，所以我才用。要不然才不会用这么脑残的东西。还因为我有个CSDN博客在这上面。因为本人是拍照狂魔，然后通过大数据研究发现，本人大部分数据还是照片视频。之前听说Yahoo Flickr可以存照片，有1TB的存储空间，又听说2015 Google I/O大会上发布了一个新产品Google photos。无限存储照片视频，而且还有autotag功能。可能以后还会更强大！毕竟，今年(2016)AlphaGo可是赢了人类啊！所以最终我选择了Google。这样我的照片终于有了一个归宿了。 现在我会尽量在本地也留一份文件！不再那么相信网盘了！文件又不是他们的，他们才没心思管你呢！！]]></content>
      <categories>
        <category>互联网</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大橋のぞみ Oohashi Nozomi]]></title>
    <url>%2F2016%2F05%2F11%2F%E5%A4%A7%E6%A9%8B%E3%81%AE%E3%81%9E%E3%81%BF%2F</url>
    <content type="text"><![CDATA[一个唱《崖上的波妞》从头唱到尾的有精神的女孩子。 序言这是我所写的第三个人物，亦是第二个童星。好吧(∩_∩)！我承认其实我是loli控！ 关于她从07-12年活跃在日本童星一线。12年4月后暂时隐退。(在很多人眼中，可能觉得这是个遗憾！但我并不这么认为，她的隐退对她来说其实是个最好的选择。)因演唱 《崖上的波妞》同名主题曲而红遍了日本。曾经打破红白歌会上年纪最小上台表演者。（其后，纪录被芦田爱莱超越，并一直保持至今（2016年））详细信息请右转维基百科 声优名侦探柯南剧场版《天空的遇难船》简介大桥望美在里面是声的出演。川口聪 役。 小结曾经的我可是柯南粉啊！（因为自从看了《相棒》之后，就对柯南的各种假，感到无望）然而现在已经不是了，只不过要是出最新的剧场版，还是会追的。剧场版一年一更。当时我还在刷柯南剧场版时还并不知道 演员久石譲 in 武道館 ~宮崎アニメと共に歩んだ25年間~早在我关注宫崎骏动画的时候，无意间在bilibili中发现了这场演奏会的视频。也就是那时候从弹幕中知道的大桥望美。这是一场十分不错的演唱会，强烈建议看一下!! 简介这可是25年以来从风之谷到悬崖上的金鱼姬，久石让为宫崎骏配音中的大部分配乐的演奏，其中一些配乐还加上了歌词，请来了原唱。（自然，大桥望美肯定少不了了）如果，你曾经看过宫崎骏有关的动漫，会产生很强的画面感！当然，没看过也没关系。毕竟，我在最开始的时候也没有看过多少。即使没看过，你也可以从久石让的音乐中听出各种各样的感情。 演出悬崖上的金鱼姬 47:00出场 这可是她的主打歌啊！！一直唱到隐退…最初时，我就想，这娃有多厉害啊，尽然能够在武道馆，这么大的牌场下表演，一定很有名气。但我看完表演，却也不觉得怎么样，十分的普通，就像是那种在道路上随便找的人来唱的。没什么镜头感，没什么气场。跟Crystal比起来简直弱爆啊！所以，我一直觉得很奇怪，这不符合常理啊。当然第一次时只是稍微看了一下，并没有太在意她。前面说了那么多不足，在来说一下优点吧。其实，她在武道馆的演出比红白上好太多了！没有红白上那么紧张，表现非常的自然，就要这种效果。而且也没有出现唱歌跑调这种情况。（波妞这首歌似乎是唯一一个不会唱跑调的歌了。）只不过经常忘词，这倒是真事！还试过藤冈藤卷跟着一起忘词的情况。 散步 01:32:00出场 镜头不多，也就是打打酱油。在她以个人名义发布的第一张专辑《ノンちゃん云に乗る 》中也有收录这首歌曲《散步》。这次的表演唱的比专辑中的要好！视频地址 钢之女简介大桥望美在这部剧中饰演中野爱梨，私生女小孩，就像知乎上某人所说： 日剧里面，有这么个规则，凡是小孩子有戏份，基本都是家庭有问题成长多坎坷什么的。 然而，她在这部剧中表现并不出色！尽管，名字被特意拿到最前面，相对于其他子役而言。简直弱爆啊!!!其他子役个个都在刷存在感,演技爆表啊！！尤其是那个叫吉田里琴的，女王风范啊！！你就在那呆萌呆萌的……（醉） 第一季可以说编剧还是给了充足的戏份的，在没主要出场的几集中，都能时常看到她的露脸。（这段时间也是她最辉煌的时候啦！在芦田爱莱还没崛起之前）主要出场在第6集哦！其实整一集也真的没什么好说的，就是呆萌嘛！当然与柠檬酱的对手戏还是不错的，将来可以做一个不错的姐姐！（竟然你那么想做幼儿园老师） 第二季也就第一集出场的时间比较多，依旧是原先第一季的设定，就是一个暖妹子嘛！在第8集时，有个地方还是挺令我吃惊的。28：30，有一种young神的感觉啊！整个人的气质都出来了啊！ 白色之春简介歌手崖の上のポニョ 以大橋のぞみと藤冈藤巻的名义，发行的第一张专辑。相比中国新声代的国内小朋友，已经相当的幸福了。能够发行含自己名字的专辑。《崖の上のポニョ》这首歌完成的相当棒！全程音非常的准，没有跑调！这也是她唯一一首值得骄傲的歌了。整个演艺生涯也就是将这首歌从小唱到大。《フジモトのテーマ》这首歌大橋のぞみ没有参与，完全是藤冈藤巻两个大叔唱的，还是比较耐听的。我好像在弹幕中看到有人说这其中有个人像白岩松。《崖の上のポニョ(のぞみちゃんデモ)》这是demo试唱版，大橋のぞみ的小奶音相当的重啊！！萌cry了！！因为这是最初的曲子版本，后面的成品对曲子有所修改，所以并不是她唱跑调的啦。 ノンちゃん云に乗る 视频【pv】悬崖上的金鱼姬 【making】悬崖上的金鱼姬 function changeFrameHeight(ID){ var ifm= document.getElementById(ID); var bHeight = document.documentElement.clientHeight-150; var dHeight = document.documentElement.clientWidth-150; var height = Math.min(bHeight, dHeight); ifm.height = height; //ifm.height=ifm.width; //ifm.width=50 } window.onresize=function(){ changeFrameHeight("video1"); changeFrameHeight("video2"); } window.onload=function (){ changeFrameHeight("video1"); changeFrameHeight("video2"); }]]></content>
      <categories>
        <category>人物</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>未完成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[走进吉卜力的奇幻世界]]></title>
    <url>%2F2016%2F04%2F01%2F%E8%B5%B0%E8%BF%9B%E5%90%89%E5%8D%9C%E5%8A%9B%E7%9A%84%E5%A5%87%E5%B9%BB%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[序标题的命名在此之前，我想了很久在这篇博文的命名上。首先我是想在命名中包含宫崎骏的名字。但总觉的这样不太好，原因如下: 我所喜欢的已经从宫崎骏的作品中，渐渐延伸开来，到了整个吉卜力的作品 一部好的作品不仅仅只是一个人的功劳。(尽管宫崎骏是一个控制狂，但是没有像铃木敏夫这样的协调，推动，支持者，也就不会有现在的宫崎骏) 宫崎骏的名字貌似已经被用烂了(很多人不分黑白的，把吉卜力的作品往宫崎骏头上套) 基于这些原因，我打消了使用宫崎骏名字的念头。因为出于对吉卜力和宫崎骏作品风格的喜爱，我觉得有必要加入吉卜力的名字。(尽管这个名字是宫崎骏胡乱从一架飞机名字中取来的)。这个标题也是在一个纪录片的名字中看到的，觉得还不错，就暂且取来用了。 写作内容在这里，我会详细描述，这一个月以来，接触宫崎骏动画，到喜欢并沉迷于他的动画的过程中的所思所想。以及爱屋及乌的喜欢他这个人的具体评价。当然，这其中我是有参考许多其他人对他的作品或他本人的评价。这篇博文也主要偏向于宫崎骏的作品。 温馨提示这篇博文会比较冗长!!这篇博文包含剧透!! 作品排行(以下纯属个人观点) 宫崎骏 风之谷 天空之城 千与千寻 魔女宅急便 龙猫 幽灵公主 崖上的波妞 红猪 哈尔的移动城堡 起风了 其他 萤火虫之墓 借东西的小人阿莉埃蒂 红花坂上的海 侧耳倾听 回忆中的玛妮 百变狸猫 地海战记 猫的报恩 配乐排行宫崎骏 天空之城 风之谷 龙猫 哈尔的移动城堡 千与千寻 魔女宅急便 幽灵公主 崖上的波妞 红猪 起风了 其他 未看过 岁月的童话 我的领居山田君 辉夜姬物语 因为高畑勋特殊的水彩画风，我比较难以接受，所以只看了两部他导演的作品。(原谅我的双重标准……) 风之谷前言作为宫崎骏第一部成名之作。(亦是第二部担任动画电影导演的作品)，在这之前他就已经参与过许多的动画电影的制作。已经有了丰富的经验。经过他千辛万苦的努力所争取到的动画电影制作机会。这部宫老的作品是我眼中最好的最大气的一部。在这部电影和漫画中，倾泻了很多宫崎骏对人与自然的思考。风之谷和天空之城一样，与之前宫崎骏的TV版动画《未来少年柯南》存在很大的相似性。 都有一个拥有与大自然交流能力的女主 都有一个拥有着至上权利的女性角色，而且都改邪归正了！ 据说，庵野秀明将制作「风之谷」第2部，我认为这部作品出续集，我还是可以接受的。毕竟动画版的内容实在是太短，跟原版漫画思想上差了好几个台阶。风之谷漫画版连载至1994年，而动画版1984年就已经完成并上映了。正因如此，才有更大的发挥空间去完成续集。 作品主题动画版动画版在情节上是漫画版的精简，主要人物出场了1/3。尽管如此，宫崎骏通过自己的改编，以人与环境的关系问题为主题，以娜乌西卡善良且拥有着与虫类及其他动物沟通能力的人物形象为特征，呼吁我们去尊重、保护自然。人与自然，人与人应当和谐相处。腐海产生的原因，正是为了要进化这个被人类污染了的世界。人类对大自然的污染越大，腐海的面积也会越大。而愚蠢的人类却对自然地态度却还停留在“七日之火”那场战役中，想通过巨神兵等具有强大杀伤力的武器征服自然。 漫画版同动画版一样,娜乌西卡发现了腐海的秘密,是为了净化这个被人类污染的世界。而她的设定正好是救世主的存在。他拥有着与自然和人类沟通的能力。最后，她用自己的真诚，和坚定的反对战争。让几乎所有不同国家、不同种族、不同信仰的人相信了她，正因为她的存在，人类才得以和平相处一段时间。将所有的憎恶暂时的抛弃掉。修瓦之墓才是这个世界的真正控制者。他们是“火之七日”中，最后的科学家，看到这个世界已经无法在短时间内恢复其自然的状态。而想到将一切推导重来，为此而设计了一个长达千年的净化程序。腐海，王虫都是被人类基因改造过的生物。恶魔出现的原因正是因为这个陵墓，为了自身利益，不顾当今世界的其他生物，为了能够得到一个干净的世界，通过设定好的程序，而重新复活原人类。最后被向往生命自由的娜乌西卡用巨神兵给销毁了。最后留给我们这样一个问题：在所有科技都已丢失，“心”的力量能否帮助人类渡过厄运？（漫画版很好的打了环保主义的脸，最终人类就应当是一个被灭亡的族群。） 漫画版剧情梗概漫画版剧情梗概 观后感第一次看这部作品,是在机房里…第一部让我看到落泪的电影。尤其是那段回忆，娜乌西卡小时候为了保护一个弱小的王虫。但是大人们不管王虫是否做过什么坏事，固执的认为人与昆虫是不能生存在同一个世界中的。故事设定的背景是在工业文明消失于7日之火之后的第1000年。在这样的背景下，人类苟延残喘的活着。在这1000年中，虽说战争不像”七日之火”那样剧烈，但人与人依旧战争不断。不仅如此，世界的很多地方和国家都被腐海这一人类几乎无法生存的生态系统所控制。（未完待续） 收集 一次又一次被他的作品惊到。我不停的想象，那个总是爱用女孩做主角的男人在生活里是一个什么样的人，到底是什么赋予了他那么惊奇的想象力，如洪水般波涛汹涌，如雨露般永不枯竭。是什么让他的心中充满了童爱，让他的眼睛紧紧的盯着这个世界仅剩的纯净，以及用不同的方式来表达对这个世界的思索与关爱┅(能看宫崎俊的动画就是幸福)[https://movie.douban.com/review/1479935/]((蓝光风云)《风之谷》日A蓝光碟截图点评)[http://movie.mtime.com/10606/reviews/5775122.html] 我希望再活30年。我想看到东京被大海淹没，NTV(日本电视公司)的电视塔成为孤岛。我想看到曼哈顿成为水下之城……我对这一切感到兴奋。(因为)金钱和欲望，所有这一切会走向崩溃，绿色的杂草将接管(世界)。—宫崎骏 经典台词 人类，就是一直在重复过去的道路。每个人都认为自己是对的，然后就由罪恶衍生出更多的罪恶，悲哀衍生出更多的悲哀，永远找不到出路。 火在一天之内把森林烧成灰烬，水和风却需要一百年以上的时间来造林。 在我心中，也存在黑暗，如果这是我内在的森林，那这沙漠也是我内在的东西……若真是如此的话，他也便是我的一部分。 如果只是把世界分为清净和污浊两者，是不是就反而看不到真相了呢？ 你们也喝井里的水吧?你们知道是谁在替你们净化那些水源?湖泊与河流中的水，都被人类污染了，是腐海中的树木，一直在净化被污染的水!绝不能烧掉腐海的森林，一切都错在你们发现了巨神兵! 憎恨蒙蔽了我的双眼，让我失去了理智。 天空之城 龙猫 魔女宅急便 红猪 幽灵公主 千与千寻 哈尔的移动城堡 崖上的波妞 起风了 红花坂上的海一句话总结:精美的画面，积极活泼的海，沉重却不失浪漫的剧情，打动着我的心。 观影前看到是宫崎吾郎的作品。因为先前看到过他导演的地海战记，被世人吐槽许多。而且这是他第二部担任导演的剧场版电影。所以对这部片子颇有些担心。 观影中开头就是一片自然环境的渲染，很不错！画面刻画的很细腻，在配上简单乐器弹奏的音乐，给人一种轻松、愉悦之感。很快就见到本片的女主角了松崎海。Tags核阴影]]></content>
      <categories>
        <category>互联网</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>未完成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[趣写算法系列之--匈牙利算法]]></title>
    <url>%2F2016%2F03%2F19%2F%E8%B6%A3%E5%86%99%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E4%B9%8B-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[转载文章]]></content>
      <categories>
        <category>信息学</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>link</tag>
        <tag>二分图</tag>
        <tag>匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDKOI总结]]></title>
    <url>%2F2016%2F02%2F23%2FGDKOI%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概述第二年亦是最后一年GDKOI，然而还是一样的弱。D1：30+0+20+30=80D2:20+50+0+30=100抱着拿部分分的心态参与考试…. Day1T1：cardcaptor位运算，线段树 刚开始时还理解错题意,因为着急的看下文,忽略了给出的例子.幸亏后面回头又看了一次题,才发现原先把问题想复杂了。此题差一步就想到正解了。看到区间询问和单点修改，很自然的想到了线段树。线段树的关键在两个区间的合并，然而在考场中并没有想到，怎么O(1)的快速合并。实际上合并依旧是个暴力。结果在对拍的过程中才发现GG，效率跟暴力差不多……题目中涉及到xor操作，因该将它拆解成每一位做，通过乘法原理，优化加法的计算。 下次遇到此类题，首先，应当有一双慧眼，相信自己的方法，大胆猜想。 T2：portal概率！！我好像就没一次做对过此类题型…我到最后连样例是如何计算出来的都不知道. T3：treasurehunt有依赖关系的图，（最大权闭合子图+网络流），还真不知道…那就看着拿暴力分吧。 T4：map随便瞎搞个暴力 Day2T1：coloring博弈题!!同概率!!所以打了一个错误的搜索,只能保证先手最优化,后手最差化.结果都能骗到20… 一定要好好恶补有关博弈和概率的问题…不然样例都不知道怎么来的… T2：qt这题没想到是数位DP,觉得要用高精度做,有点恶心,先拿了50分再说!! T3：necklace2看到题目直接回想起上次GDKOI,第一次知道了传说中M打头的算法O(N)出解.然而,我已经忘光了,只能打O(N^2)的暴力,我的内心是崩溃的!!就算知道怎么打,也还是比较难. 只可惜不知评测时,为何我的程序文件操作挂了.可能是Pascal的文件读入我没测试吧!! T4：math刚开始看到这道题,还很高兴!!不就是循环一遍求一下乘法逆元…结果做到后面发现有一些数是没有逆元的，直接GG。本以为连30%都拿不到的，出了考场听其他人说有个限制n&lt;p,就不会存在没有逆元的情况.感谢出题人啊!!!求逆元也没白打,恰好在这之前做了两道有关扩展GCD的问题. 小结 考试策略基本正确,细心细致注意取mod数. 不管题目有多难,只要能看懂题目,能算出样例,就一定能打出暴力. 正解一般都与暴力的实现有关,注意数据范围和题目的类型,就能大致确定算法类型. 不管怎样对拍,小数据,大数据都不必可少,保证程序稳定,不挂. 理解清题目最重要,发现自己想不下去的时候.重看一遍题目,往往会有新的发现. 现有的问题及解决方案题目理解是前提，样例提示都要看。遇到难题不要慌，冷静分析是关键。（编不下去了…）多想1分钟，胜过多打10分钟的程序。只要是自己熟悉的算法，打起来就没有什么难的。现在缺的不是程序实现、调试。而是对题目的思考和优化。]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【GDKOI】总结 2.16-2.18]]></title>
    <url>%2F2016%2F02%2F19%2F%E3%80%90GDKOI%E3%80%91%E6%80%BB%E7%BB%93-2-16-2-18%2F</url>
    <content type="text"><![CDATA[2.16概述先看数据范围，根据数据范围推得算法的时间复杂度。能打的暴力，在时间允许的情况下就打，不要怕复杂。有时一个方法想不通，可以换几种方法，不要陷入一种方法中。将题意转换化简一下，往往就能得出正解。 T1:【GDOI2003】购物因为没有环，转化成树后，经典的树形dp。枚举结点选或不选，得到该节点的子树的答案最大值。 T2:删边刚开始看到这道题，没有什么特别好的方法。暴力水的70分。这题和T4的思想类似，可以通过递归求解直径，通过转根，使得另一边的直径可以直接算出来。只不过要分多种情况，还是挺复杂的。要尽量保存更多的信息，而不需要重新计算，通过原先的答案推出新的答案。降低时间复杂度。 T3:blockenemy这题可贪心，并查集加边维护。正解是dp。dp要分多种情况讨论。考试时没有想到特别好的方法，暴力太复杂，所以没打。 T4:treecut很简单的转根，也是我最拿手的题型。 2.17概述这套题是我感觉最好的一套题，很多题之前都做过相类似的。 T1:广告印刷做过很多次这种类型的题，单调队列判断最远能扩展到的地方。 T2:锻炼身体【推荐】瑰丽华尔兹，dp加单调队列优化。 T3:求和欧拉函数有一个公式，但考试时并不知道，可以通过容斥原理筛选并得出答案。 T4:无题noname扩展GCD解整数解，第一次较彻底的明白扩展GCD的功能及其原理。要有较好的数学功底转化并化简题目。 2.18概述发挥不大好，T1,T2离正解好差一点。 T1:得分看起来像01背包，然而打完之后发现并不是，因为这道题有后效性。除非能够确定一个特定的顺序，确保无后效性，再dp就没问题了。考试时，因为这一问题卡壳了，然后朝其他方向想，想了一个错误的单调队列。顺序其实很好确定，讨论一下两个不同的作业谁更优即可。 T2:荒岛野人因为不太会化简恒等取mod式，所以直接暴力枚举。首先要理解好题意，写出一个恒等式，化简。上扩展GCD直接求得相遇所需的最小年限。优化掉一重循环。 T3:体育场可以建关系树，发现树可以用并查集的路径压缩，来压缩路径，通过一个数组d，判断是否矛盾。 T4:机器人M号题目竟然有800+字…从前面一堆废话中，提取信息：老师：是x的因子，独立数：该点的欧拉函数。通过递推式求得答案。]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无题noname]]></title>
    <url>%2F2016%2F02%2F18%2F%E6%97%A0%E9%A2%98noname%2F</url>
    <content type="text"><![CDATA[Description给定一个N，求出所有1到N之间的x，使得x^2=1(mod N)。 Input一行一个正整数，没有多余字符，表示N。 Output从小到大输出所有的x，一行一个。 Sample Input17 Sample Output1216 Data Constraint【数据范围】 30%的数据N&lt;=20000； 100%的数据N&lt;=2000000000。 Analysis这道题有两种解题方法 第一种方法(扩展GCD)$x^2\equiv1 (mod N)\longleftrightarrow x^2-1=N*T\longleftrightarrow (x+1)(x-1) = a*b*x0*(-y0)$将N分解为ab，$T\in N$ 将T分解为x0(-y0),这样可以得到两个等式。$$ \left\{\begin{aligned}x+1 = a*x0 \quad①\\x-1 = b*(-y0) \quad②\\\end{aligned}\right.$$$a*x0+b*y0=2 \qquad ③=①-②$ 下面是扩展GCD的一些知识③可以用扩展GCD解得一组特解x0,y0，然后能通过特解的出一般解。一般解为$$ \left\{\begin{aligned}x0 + \frac {b}{p}*k \quad①\\y0 - \frac {a}{p}*k \quad②\\\end{aligned}\right.$$ 扩展GCD$a*x+b*y=d$解得一组整数解x,y的充分必要条件是gcd（a,b）| d。所以我们可以通过解出x，y，从而计算x的值$2*x = a*x0-b*y0\qquad ④=①+②$$x = \frac {a*x0-b*y0}{2}$将$x$化为一般解，即：$x = \frac {a*(x0 + \frac {b}{p}*k)-b*(y0- \frac {a}{p}*k)}{2}$因为 $1\leq x\leq N$所以可以得到k的取值范围最后所求的x可化为：$x = \frac {a*x0-b*y0}{2}+\frac {a*b*k}{p}$详情代码1 第二种方法(中国剩余定理)详情请参见References列表中的链接详情代码2 Code代码1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;typedef long long LL;LL n,k,tmp,x3,y3,a,b,p;int ans[1000];LL gcd(LL a,LL b)&#123; if (!b) &#123; x3 = 2/a; y3 = 0; return a; &#125; LL ret = gcd(b,a%b),t = x3; x3 = y3; y3 = t-a/b*y3; return ret;&#125;void work(LL a,LL b)&#123; p = gcd(a,b); if (2%p!=0) return; LL x = a*x3-b*y3; if (x%2==1) return; LL t = 2*a*b/p; double kmin = 1.0*(2-a*x3+b*y3)/t, kmax = 1.0*(2*n-a*x3+b*y3)/t; for (int k=ceil(kmin);k&lt;=floor(kmax);k ++) &#123; ans[++ ans[0]] = x/2+a*b*k/p; &#125;&#125;int main()&#123; //freopen("1460.in","r",stdin); //freopen("1460.out","w",stdout); scanf("%lld",&amp;n); if (n==1) return 0; for (int i=1;i&lt;=sqrt(n);i ++) &#123; if (n%i==0) &#123; a = i;b = n/i; work(a,b);work(b,a); &#125; &#125; sort(ans+1,ans+1+ans[0]); printf("%d\n",ans[1]); for (int i=2;i&lt;=ans[0];i ++) if (ans[i]!=ans[i-1]) printf("%d\n",ans[i]); return 0;&#125; 代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109var n,m,t,t1,t2,tt,tt2,i,j:longint; mo:int64; b,d,g,mm:array[0..10001] of int64; c:array[0..10001,0..4] of int64; p:array[0..100001] of boolean;function exgcd(x,y:longint;var tx,ty:longint):longint;var t1:int64;begin if y=0 then begin tx:=1;ty:=0; exit(x); end; exgcd:=exgcd(y,x mod y,tx,ty); t1:=tx;tx:=ty;ty:=t1-(x div y)*tyend;procedure qsort(x,y:longint);var i,j,k:longint;begin i:=x;j:=y; k:=g[(i+j) div 2]; while i&lt;=j do begin while g[i]&lt;k do inc(i); while g[j]&gt;k do dec(j); if i&lt;=j then begin g[0]:=g[i];g[i]:=g[j];g[j]:=g[0]; inc(i);dec(j); end; end; if i&lt;y then qsort(i,y); if x&lt;j then qsort(x,j);end;procedure sy;var i:longint; ans:int64;begin ans:=0; for i:=1 to tt do begin exgcd(mm[i],b[i],t1,t2); ans:=(ans+((d[i]*t1) mod mo*mm[i]) mod mo+mo*10) mod mo; end; inc(tt2); g[tt2]:=ans;end;procedure dfs(x:longint);var i:longint;begin if x=tt+1 then begin sy; exit; end; for i:=1 to c[x,0] do begin d[x]:=c[x,i]; dfs(x+1); end;end;begin readln(n); mo:=n; t:=trunc(sqrt(n)); tt:=0; m:=n; for i:=2 to t do if not p[i] then begin if m mod i=0 then begin inc(tt); t2:=i; b[tt]:=1; while m mod i=0 do begin m:=m div i; b[tt]:=b[tt]*t2; end; end; j:=i; while j&lt;=t do begin p[j]:=true; j:=j+i; end; end; if m&lt;&gt;1 then begin inc(tt); b[tt]:=m; end; for i:=1 to tt do begin if b[i] mod 2=0 then begin if b[i]=2 then begin c[i,0]:=1; c[i,1]:=1; end else if b[i]=4 then begin c[i,0]:=2; c[i,1]:=1; c[i,2]:=3; end else begin c[i,0]:=4; c[i,1]:=1; c[i,2]:=b[i] div 2-1; c[i,3]:=b[i] div 2+1; c[i,4]:=b[i]-1; end; end else begin c[i,0]:=2; c[i,1]:=1; c[i,2]:=b[i]-1; end; end; for i:=1 to tt do mm[i]:=n div b[i]; dfs(1); qsort(1,tt2); for i:=1 to tt2 do writeln(g[i]);end. References代码2来源lzy算法导论—–数论—–计算x^2=1(mod n) 在区间[1,n-1]的解中国剩余定理扩展GCD]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高考古诗文背诵64篇]]></title>
    <url>%2F2016%2F02%2F18%2F%E9%AB%98%E8%80%83%E5%8F%A4%E8%AF%97%E6%96%87%E8%83%8C%E8%AF%B564%E7%AF%87%2F</url>
    <content type="text"><![CDATA[高考古诗文背诵篇目(64篇) 《孔子语录》①子曰：“学而时习之，不亦说乎？有朋自远方来，不亦乐乎？人不知而不愠，不亦君子乎？” ②曾子曰：“吾日三省吾身：为人谋而不忠乎？与朋友交而不信乎？传不习乎？”②子曰：“温故而知新，可以为师矣。”③子曰：“学而不思则罔，思而不学则殆。”④子曰：“由，诲女知之乎！知之为知之，不知为不知，是知也。”⑤子贡问曰：“孔文子何以为‘文’也?”子曰:“敏而好学,不耻下问,是以谓之‘文’也”⑥子曰：“默而识之,学而不厌,诲人不倦,何有于我哉!”⑦子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。”⑧子曰：“知之者不如好之者,好之者不如乐之者。”⑨子在川上，曰：“逝者如斯夫,不舍昼夜。”⑩子曰：“吾尝终日不食，终夜不寝，以思，无益，不如学也。” 《鱼我所欲也》 鱼，我所欲也，熊掌，亦我所欲也，二者不可得兼，舍鱼而取熊掌者也。生，亦我所欲也，义，亦我所欲也，二者不可得兼，舍生而取义者也。生亦我所欲，所欲有甚于生者，故不为苟得也。死亦我所恶，所恶有甚于死者，故患有所不避也。如使人之所欲莫甚于生，则凡可以得生者何不用也。使人之所恶莫甚于死者，则凡可以避患者何不为也！由是则生而有不用也；由是则可以避患而有不为也。是故所欲有甚于生者，所恶有甚于死者。非独贤者有是心也，人皆有之，贤者能勿丧耳。 一箪食，一豆羹，得之则生，弗得则死。呼尔而与之，行道之人弗受；蹴尔而与之，乞人不屑也。万钟则不辨礼义而受之，万钟于我何加焉！为宫室之美，妻妾之奉，所识穷乏者得我欤？乡为身死而不受，今为宫室之美为之；乡为身死而不受，今为妻妾之奉为之；乡为身死而不受，今为所识穷乏者得我而为之：是亦不可以已乎？此之谓失其本心。 《生于忧患死于安乐》 孟子 舜发于畎亩之中，傅说举于版筑之中，胶鬲举于鱼盐之中，管夷吾举于士，孙叔敖举于海，百里奚举于市。 故天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。 人恒过，然后能改；困于心，衡于虑，而后作；征于色，发于声，而后喻。入则无法家拂士，出则无敌国外患者，国恒亡。 然后知生于忧患，而死于安乐也。 《曹刿论战》 左传 十年春，齐师伐我。公将战。曹刿请见。其乡人曰：“肉食者谋之，又何间焉？”刿曰：“肉食者鄙，未能远谋。”乃入见。问：“何以战？”公曰：“衣食所安，弗敢专也，必以分人。”对曰：“小惠未徧，民弗从也。”公曰：“牺牲玉帛，弗敢加也，必以信。”对曰：“小信未孚，神弗福也。”公曰：“小大之狱，虽不能察，必以情。”对曰：“忠之属也。可以一战。战则请从。” 公与之乘。战于长勺。公将鼓之。刿曰：“未可。”齐人三鼓。刿曰：“可矣。”齐师败绩。公将驰之。刿曰：“未可。”下视其辙，登轼而望之，曰：“可矣。”遂逐齐师。 既克，公问其故。对曰：“夫战，勇气也。一鼓作气，再而衰，三而竭。彼竭我盈，故克之，夫大国，难测也，惧有伏焉。吾视其辙乱，望其旗靡，故逐之。” 《邹忌讽齐王纳谏》 战国策 邹忌修八尺有余，形貌昳丽。朝服衣冠，窥镜，谓其妻曰：“我孰与城北徐公美？”其妻曰：“君美甚，徐公何能及公也！”城北徐公，齐国之美丽者也。忌不自信，而复问其妾曰：“吾孰与徐公美？”妾曰：“徐公何能及君也！”旦日，客从外来，与坐谈，问之客曰：“吾与徐公孰美？”客曰：“徐公不若君之美也！”明日，徐公来。孰视之，自以为不如；窥镜而自视，又弗如远甚。暮寝而思之曰：“吾妻之美我者，私我也；妾之美我者，畏我也；客之美我者，欲有求于我也。” 于是入朝见威王曰：“臣诚知不如徐公美，臣之妻私臣，臣之妾畏臣，臣之客欲有求于臣，皆以美于徐公。今齐地方千里，百二十城，宫妇左右，莫不私王；朝廷之臣，莫不畏王；四境之内，莫不有求于王。由此观之，王之蔽甚矣！” 王曰：“善。”乃下令：“群臣吏民，能面刺寡人之过者，受上赏；上书谏寡人者，受中赏；能谤议于市朝，闻寡人之耳者，受下赏。” 令初下，群臣进谏，门庭若市。数月之后，时时而间进。期年之后，虽欲言，无可进者。燕、赵、韩、魏闻之，皆朝于齐。此所谓战胜于朝廷 《出师表》 诸葛亮 臣亮言：先帝创业未半，而中道崩殂；今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣，不懈于内；忠志之士，忘身于外者：盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气；不宜妄自菲薄，引喻失义，以塞忠谏之路也。 宫中府中，俱为一体；陟罚臧否，不宜异同：若有作奸犯科，及为忠善者，宜付有司，论其刑赏，以昭陛下平明之理；不宜偏私，使内外异法也。 侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下：愚以为宫中之事，事无大小，悉以咨之，然后施行，必能裨补阙漏，有所广益。 将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰“能”，是以众议举宠为督：愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所也。 亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也！侍中、尚书、长史、参军，此悉贞亮死节之臣也，愿陛下亲之、信之，则汉室之隆，可计日而待也。 臣本布衣，躬耕南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间,尔来二十有一年矣。 先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明；故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都：此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允等之任也。 愿陛下托臣以讨贼兴复之效，不效则治臣之罪，以告先帝之灵；若无兴德之言，则责攸之、祎、允等之慢，以彰其咎。陛下亦宜自谋，以谘诹善道，察纳雅言，深追先帝遗诏。臣不胜受恩感激！ 今当远离，临表涕零，不知所言。 《桃花源记》 陶渊明 晋太元中，武陵人捕鱼为业，缘溪行，忘路之远近。忽逢桃花林，夹岸数百步，中无杂树，芳草鲜美，落英缤纷，渔人甚异之。 复前行，欲穷其林。 林尽水源，便得一山，山有小口，仿佛若有光，便舍船从口入。 初极狭，才通人，复行数十步，豁然开朗。土地平旷，屋舍俨然，有良田美池桑竹之属。 阡陌交通，鸡犬相闻。其中往来种作，男女衣著，悉如外人。黄发垂髫，并怡然自乐。 见渔人，乃大惊，问所从来。具答之。便要还家，设酒杀鸡作食。村中闻有此人，咸 来问讯。自云先世避秦时乱，率妻子邑人来此绝境，不复出焉，遂与外人间隔。问今是何 世，乃不知有汉，无论魏晋。此人一一为具言所闻，皆叹惋。 余人各复延至其家，皆出酒食。停数日，辞去。此中人语云，不足为外人道也。 既出，得其船，便扶向路，处处志之。及郡下，诣太守说如此。太守即遣人随其往，寻向所志， 遂迷不复得路。 南阳刘子骥，高尚士也，闻之，欣然规往，未果。寻病终。后遂无问津者。 《三峡》 郦道元 自三峡七百里中，两岸连山，略无阙处；重岩叠嶂，隐天蔽日，自非亭午夜不见曦月。 至于夏水襄陵，沿溯阻绝。或王命急宣，有时朝发白帝，暮到江陵，其间千二百里，虽乘奔御风不以疾也。 春冬之时，则素湍绿潭，回清倒影。绝巘多生怪柏，悬泉瀑布，飞漱其间。清荣峻茂，良多趣味。 每至晴初霜旦，林寒涧肃，常有高猿长啸，属引凄异，空谷传响，哀转久绝。故渔者歌曰：“巴东三峡巫峡长，猿鸣三声泪沾裳！” 《马说》 韩愈 世有伯乐，然后有千里马。千里马常有，而伯乐不常有。故虽有名马，祗辱于奴隶人之手，骈死于槽枥之间，不以千里称也。 马之千里者，一食或尽粟一石。食马者，不知其能千里而食也。是马也，虽有千里之能，食不饱，力不足，才美不外见，且欲与常马等不可得，安求其能千里也。 策之不以其道，食之不能尽其材，鸣之而不能通其意，执策而临之，曰：“天下无马。”呜呼！其真无马邪？其真不知马也！ 《陋室铭》 刘禹锡 山不在高，有仙则名。水不在深，有龙则灵。斯是陋室，惟吾德馨。苔痕上阶绿，草色入帘青。谈笑有鸿儒，往来无白丁。可以调素琴，阅金经。无丝竹之乱耳，无案牍之劳形。南阳诸葛庐，西蜀子云亭。孔子云：“何陋之有？” 《小石潭记》 柳宗元 从小丘西行百二十步，隔篁竹，闻水声，如鸣佩环，心乐之。伐竹取道，下见小潭，水尤清冽。全石以为底，近岸，卷石底以出，为坻，为屿，为嵁，为岩。青树翠蔓，蒙络摇缀，参差披拂。 潭中鱼可百许头，皆若空游无所依。日光下澈，影布石上，佁然不动;俶尔远逝，往来翕忽，似与游者相乐。 潭西南而望，斗折蛇行，明灭可见。其岸势犬牙差互，不可知其源。 坐潭上，四面竹树环合，寂寥无人，凄神寒骨，悄怆幽邃。以其境过清，不可久居，乃记之而去。 同游者：吴武陵，龚古，余弟宗玄。隶而从者，崔氏二小生：曰恕己，曰奉壹。 《岳阳楼记》 范仲淹 庆历四年春，滕子京谪守巴陵郡。越明年，政通人和，百废具兴。乃重修岳阳楼，增其旧制，刻唐贤今人诗赋于其上。属予作文以记之。 予观夫巴陵胜状，在洞庭一湖。衔远山，吞长江，浩浩汤汤，横无际涯；朝晖夕阴，气象万千。此则岳阳楼之大观也。前人之述备矣。然则北通巫峡，南极潇湘，迁客骚人，多会于此，览物之情，得无异乎？ 若夫霪雨霏霏，连月不开，阴风怒号，浊浪排空；日星隐耀，山岳潜形；商旅不行，樯倾楫摧；薄暮冥冥，虎啸猿啼。登斯楼也，则有去国怀乡，忧谗畏讥，满目萧然，感极而悲者矣。 至若春和景明，波澜不惊，上下天光，一碧万顷；沙鸥翔集，锦鳞游泳；岸芷汀兰，郁郁青青。而或长烟一空，皓月千里，浮光跃金，静影沉璧，渔歌互答，此乐何极！登斯楼也，则有心旷神怡，宠辱偕忘，把酒临风，其喜洋洋者矣。 嗟夫！予尝求古仁人之心，或异二者之为，何哉？不以物喜，不以己悲；居庙堂之高则忧其民；处江湖之远则忧其君。是进亦忧，退亦忧。然则何时而乐耶？其必曰“先天下之忧而忧，后天下之乐而乐”乎。噫！微斯人，吾谁与归？ 时六年九月十五日。 《醉翁亭记》 欧阳修 环滁皆山也。其西南诸峰，林壑尤美。望之蔚然而深秀者，琅琊也。山行六七里，渐闻水声潺潺，而泄出于两峰之间者，酿泉也。峰回路转，有亭翼然临于泉上者，醉翁亭也。作亭者谁？山之僧智仙也。名之者谁？太守自谓也。太守与客来饮于此，饮少辄醉，而年又最高，故自号曰“醉翁”也。醉翁之意不在酒，在乎山水之间也。山水之乐，得之心而寓之酒也。 若夫日出而林霏开，云归而岩穴暝，晦明变化者，山间之朝暮也。野芳发而幽香，佳木秀而繁阴，风霜高洁，水落而石出者，山间之四时也。朝而往，暮而归，四时之景不同，而乐亦无穷也。 至于负者歌于途，行者休于树，前者呼，后者应，伛偻提携，往来而不绝者，滁人游也。临溪而渔，溪深而鱼肥；酿泉为酒，泉香而酒冽；山肴野蔌，杂然而前陈者，太守宴也。宴酣之乐，非丝非竹，射者中，弈者胜，觥筹交错，起坐而喧哗者，众宾欢也。苍颜白发，颓然乎其间者，太守醉也。 已而夕阳在山，人影散乱，太守归而宾客从也。树林阴翳，鸣声上下，游人去而禽鸟乐 也。然而禽鸟知山林之乐，而不知人之乐；人知从太守游而乐，而不知太守之乐其乐也。醉能同其乐，醒能述其文者，太守也。太守谓谁？庐陵欧阳修也。 《爱莲说》 周敦颐 水陆草木之花，可爱者甚蕃。晋陶渊明独爱菊；自李唐来，世人盛爱牡丹；予独爱莲之出淤泥而不染，濯清涟而不妖，中通外直，不蔓不枝，香远益清，亭亭净植，可远观而不可亵玩焉。 予谓菊，花之隐逸者也；牡丹，花之富贵者也；莲，花之君子者也。噫！菊之爱，陶后鲜有闻；莲之爱，同予者何人；牡丹之爱，宜乎众矣。 《记承天寺夜游》 苏轼 元丰六年十月十二日夜，解衣欲睡，月色入户，欣然起行。 念无与为乐者，遂至承天寺，寻张怀民，怀民未寝，相与步于中庭。 庭下如积水空明，水中藻荇交横，盖竹柏影也。何夜无月，何处无松柏，但少闲人如吾两人者耳。 《送东阳马生序》宋濂 余幼时即嗜学。家贫，无从致书以观，每假借于藏书之家，手自笔录，计日以还。天大寒，砚冰坚，手指不可屈伸，弗之怠。录毕，走送之，不敢稍逾约。以是人多以书假余，余因得遍观群书。既加冠，益慕圣贤之道。又患无硕师名人与游，尝趋百里外从乡之先达执经叩问。先达德隆望尊，门人弟子填其室，未尝稍降辞色。余立侍左右，援疑质理，俯身倾耳以请；或遇其叱咄，色愈恭，礼愈至，不敢出一言以复；俟其欣悦，则又请焉。故余虽愚，卒获有所闻。当余之从师也，负箧曳屣，行深山巨谷中，穷冬烈风，大雪深数尺，足肤皲裂而不知。至舍，四支僵劲不能动，媵人持汤沃灌，以衾拥覆，久而乃和。寓逆旅主人，日再食，无鲜肥滋味之享。同舍生皆被绮绣，戴朱缨宝饰之帽，腰白玉之环，左佩刀，右备容臭，烨然若神人；余则緼袍敝衣处其间，略无慕艳意，以中有足乐者，不知口体之奉不若人也。盖余之勤且艰苦此。 今诸生学于太学，县官日有禀销之供，父母岁有裘葛之遗，无冻馁之患矣；坐大厦之下而诵《诗》《书》，无奔走之劳矣；有司业、博士为之师，未有问而不告，求而不得者也；凡所宜有之书皆集于此，不必若余之手录，假诸人而后见也。其业有不精，德有不成者，非天质之卑，则心不若余之专耳，岂他人之过哉？ 东阳马生君则在太学已二年，流辈甚称其贤。余朝京师，生以乡人子谒余。撰长书以为贽，辞甚畅达。与之论辨，言和而色夷。自谓少时用心于学甚劳。是可谓善学者矣。其将归见其亲也，余故道为学之难以告之。 《关睢》 诗经关关雎鸠，在河之洲。窈窕淑女，君子好逑。参差荇菜，左右流之。窈窕淑女，寤寐求之。求之不得，寤寐思服。悠哉悠哉。辗转反侧。参差荇菜，左右采之。窈窕淑女，琴瑟友之。参差荇菜，左右毛之。窈窕淑女。钟鼓乐之。 《蒹葭》 诗经蒹葭苍苍，白露为霜。所谓伊人，在水一方。溯洄从之，道阻且长；溯游从之，宛在水中央蒹葭凄凄，白露未晞。所谓伊人，在水之湄。溯洄从之，道阻且跻；溯游从之，宛在水中坻蒹葭采采，白露未已，所谓伊人，在水之涘。溯洄从之，道阻且右；溯游从之，宛在水中沚 《山坡羊(潼关怀古)》 张养浩峰峦如聚，波涛如怒，山河表里潼关路。望西都。意踌躇，伤心秦汉经行处。宫阙万间都做了土。兴，百姓苦。亡，百姓苦。 《相间欢》 李虞无言独上西楼，月如钩，寂寞梧桐、深院锁清秋。剪不断， 理还乱，是离愁。别是一番、滋味在心头。 《江城子》 乙卯正月二十夜记梦 苏轼老夫聊发少年狂，左牵黄，右擎苍。锦帽貂裘，千骑卷平冈。欲报倾城随太守，亲射虎，看孙郎。 酒酣胸胆尚开张，鬓微霜，又何妨！持节云中，何日遣冯唐？会挽雕弓如满月，西北望，射天狼。 《水调歌头》 苏轼明月几时有，把酒问青天。不知天上宫阙，今夕是何年。我欲乘风归去, 又恐琼楼玉宇，高处不胜寒，起舞弄清影，何似在人间。转朱阁，低绮户，照无眠。不应有恨，何事长向别时圆。人有悲欢离合，月有阴晴圆缺，此事古难全。但愿人长久，千里共婵娟。 《观刈麦》 白居易田家少闲月，五月人倍忙。夜来南风起，小麦覆陇黄。妇姑荷箪食，童稚携壶浆。相随饷田去，丁壮在南冈。足蒸暑土气，背灼炎天光。力尽不知热，但惜夏日长。复有贫妇人，抱子在其旁。右手秉遗穗，左臂悬敝筐。听其相顾言，闻者为悲伤。家田输税尽，拾此充饥肠。今我何功德，曾不事农桑。吏禄三百石，岁晏有馀粮。念此私自愧，尽日不能忘。 《观沧海》 曹操东临碣石，以观沧海。水何澹澹，山岛竦峙。树木丛生，百草丰茂。秋风萧瑟，洪波涌起。日月之行，若出其中；星汉灿烂，若出其里。幸甚至哉！歌以咏志。 《饮酒》 陶渊明结庐在人境，而无车马喧。问君何能尔，心远地自偏。采菊东篱下，悠然见南山。山气日夕佳，飞鸟相与还。此中有真意，欲辨已忘言。 《送杜少府之任蜀州》 王勃城阙辅三秦，风烟望五津。与君离别意，同是宦游人。海内存知己，天涯若比邻。无为在歧路，儿女共沾巾。 《次北固山下》王湾客路青山外， 行舟绿水前。潮平两岸阔， 风正一帆悬。海日生残夜， 江春入旧年。乡书何处达， 归雁洛阳边。 《使至塞上》 王维单车欲问边，属国过居延。征蓬出汉塞，归雁入胡天。大漠孤烟直，长河落日圆。萧关逢候骑，都护在燕然。 《闻王昌龄左迁龙标遥有此寄》 李白杨花落尽子规啼，闻到龙标过五溪。我寄愁心与明月，随君直到夜郎西。 《行路难》 李白金樽清酒斗十千，玉盘珍馐值万钱。停杯投箸不能食，拔剑四顾心茫然。欲渡黄河冰塞川，将登太行雪满山。闲来垂钓碧溪上，忽复乘舟梦日边。行路难，行路难！多歧路，今安在？长风破浪会有时，直挂云帆济沧海。 《望岳》 杜甫岱宗夫如何，齐鲁青未了。造化钟神秀，阴阳割昏晓。荡胸生层云，决眦入归鸟。会当凌绝顶，一览众山小。 《早春呈水部张十八员外》 韩愈天街小雨润如酥，草色遥看近却无。最是一年春好处，绝胜烟柳满皇都。 《己亥杂诗》 龚自珍浩荡离愁白日斜，吟鞭东指即天涯。落红不是无情物，化作春泥更护花。 《酬乐天扬州初逢席上见赠》 刘禹锡巴山楚水凄凉地，二十三年弃置身。怀旧空吟闻笛赋，到乡翻似烂柯人。沉舟侧畔千帆过，病树前头万木春。今日听君歌一曲，暂凭杯酒长精神。 《钱塘湖春行》 白居易孤山寺北贾亭西，水面初平云脚低。几处早莺争暖树，谁家新燕啄春泥。乱花渐欲迷人眼，浅草才能没马蹄。最爱湖东行不足，绿杨阴里白沙堤。 《雁门太守行》 李贺黑云压城城欲摧，甲光向日金鳞开。角声满天秋色里，塞上燕脂凝夜紫。半卷红旗临易水，霜重鼓寒声不起。报君黄金台上意，提携玉龙为君死。 《无题》 李商隐相见时难别亦难，东风无力百花残。春蚕到死丝方尽，蜡炬成灰泪始干。晓镜但愁云鬓改，夜吟应觉月光寒。蓬山此去无多路，青鸟殷勤为探看。 《赤壁》 杜牧折戟沉沙铁未销，自将磨洗认前朝。东风不与周郎便，铜雀春深锁二乔。 《泊秦淮》 杜牧烟笼寒水月笼沙，夜泊秦淮近酒家。商女不知亡国恨， 隔江犹唱《后庭花》。 《夜雨寄北》 李商隐君问归期未有期，巴山夜雨涨秋池。何当共剪西窗烛，却话巴山夜雨时。 《登飞来峰》 王安石飞来山上千寻塔，闻说鸡鸣见日升。不畏浮云遮望眼，自缘身在最高层。 《渔家傲》 范仲淹塞下秋来风景异，衡阳雁去无留意。四面边声连角起，千嶂里，长烟落日孤城闭。浊酒一杯家万里，燕然未勒归无计，羌管悠悠霜满地。人不寐，将军白发征夫泪。 《春望》 杜甫国破山河在，城春草木深。感时花溅泪，恨别鸟惊心。烽火连三月，家书抵万金。白头搔更短，浑欲不胜簪。 《浣溪沙》 晏殊一曲新词酒一杯，去年天气旧亭台，夕阳西下几时回。无可奈何花落去，似曾相识燕归来。小园香径独徘徊。 《游山西村》 陆游莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。萧鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。 《破阵子》 辛弃疾醉里挑灯看剑，梦回吹角连营。八百里分麾下灸，五十弦翻塞外声。沙场点秋兵。马作的卢飞快，弓如霹雳弦惊。了却君王天下事，嬴得生前身后名。可怜白发生！ 《过零丁洋》 文天祥辛苦遭逢起一经，干戈寥落四周星。山河破碎风飘絮，身世沉浮雨打萍。惶恐滩头说惶恐，零丁洋里叹零丁。人生自古谁无死，留取丹心照汗青。 《天净沙?秋思》 马致远枯藤老树昏鸦。小桥流水人家。古道西风瘦马。 夕阳西下，断肠人在天涯。 《白雪歌送武判官归京 》 岑参北风卷地白草折，胡天八月即飞雪。忽如一夜春风来，千树万树梨花开。散入珠帘湿罗幕，狐裘不暖锦衾薄。将军角弓不得控，都护铁衣冷难著。瀚海阑干百丈冰，愁云惨淡万里凝。中军置酒饮归客，胡琴琵琶与羌笛。纷纷暮雪下辕门，风掣红旗冻不翻。轮台东门送君去，去时雪满天山路。山回路转不见君，雪上空留马行处。 《茅屋为秋风所破歌》 杜甫八月秋高风怒号，卷我屋上三重茅。茅飞度江洒江郊，高者挂罥长林梢，下者飘转沉塘坳。 南村群童欺我老无力，忍能对面为盗贼。公然抱茅入竹去，唇焦口燥呼不得，归来倚杖自叹息。俄顷风定云墨色，秋天漠漠向昏黑。布衾多年冷似铁，娇儿恶卧踏里裂。床头屋漏无干处， 雨脚如麻未断绝。自经丧乱少睡眠，长夜沾湿何由彻！安得广厦千万间，大庇天下寒士俱欢颜，风雨不动安如山！呜呼，何时眼前突兀见此屋，吾庐独破受冻死亦足！ 《劝学》 荀子 君子曰：学不可以已。青，取之于蓝，而青于蓝；冰，水为之，而寒于水。木 直中绳，揉以为轮，其曲中规，虽有槁暴，不复挺者，輮使之然也。故木受 绳则直，金就砾则利。君子博学而日参省乎己，则知明而行无过矣。 吾尝终日而思矣，不如须臾之所学也。吾尝跂而望矣，不如登高之博见 也。登高而招，臂非加长也，而见者远。顺风而呼，声非加疾也，而闻者彰。假舆 马者，非利足也，而致千里。假舟辑者，非能水也，而绝江河。君子生非异也，善假于物也。 积土成山，风雨兴焉。积水成渊，蛟龙生焉。积善成德，而神明自得，圣心备 焉。故不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽 马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。蚓无爪牙之利， 筋骨之强，上食埃土，下饮黄泉，用心一也。蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也。 《逍遥游》 庄子 北冥有鱼，其名曰鲲。鲲之大，不知其几千里也；化而为鸟，其名为鹏。鹏之背，不知其几千里也；怒而飞，其翼若垂天之云。是鸟也，海运则将徙于南冥。南冥者，天池也。 齐谐者，志怪者也。谐之言曰：“鹏之徙于南冥也，水击三千里，抟扶摇而上者九万里，去以六月息者也。”野马也，尘埃也，生物之以息相吹也。天之苍苍，其正色邪？其远而无所至极邪？其视下也，亦若是则已矣。 且夫水之积也不厚，则其负大舟也无力。覆杯水于坳堂之上，则芥为之舟；置杯焉则胶，水浅而舟大也。风之积也不厚，则其负大翼也无力，故九万里则风斯在下矣。而后乃今培风，背负青天而莫之夭阏者，而后乃今将图南。 蜩与学鸠笑之曰：“我决起而飞，抢榆枋而止，时则不至，而控于地而已矣；奚以之九万里而南为？”适莽苍，三餐而反，腹犹果然；适百里者，宿舂粮；适千里者，三月聚粮。之二虫又何知？ 小知不及大知，小年不及大年。奚以知其然也？朝菌不知晦朔，蟪蛄不知春秋，此小年也。楚之南有冥灵者，以五百岁为春，五百岁为秋；上古有大椿者，以八千岁为春，八千岁为秋，此大年也。而彭祖乃今以久特闻，众人匹之，不亦悲乎？ 汤之问棘也是已：“穷发之北有冥海者，天池也。有鱼焉，其广数千里，未有知其修者，其名曰鲲。有鸟焉，其名为鹏，背若泰山，翼若垂天之云；抟扶摇、羊角而上者九万里，绝云气，负青天，然后图南，且适南冥也。斥鴳笑之曰：‘彼且奚适也？我腾跃而上，不过数仞而下，翱翔蓬蒿之间，此亦飞之至也。而彼且奚适也？’”此小大之辩也。 故夫知效一官、行比一乡、德合一君、而征一国者，其自视也亦若此矣。而宋荣子犹然笑之。且举世而誉之而不加劝，举世而非之而不加沮，定乎内外之分，辩乎荣辱之境，斯已矣。彼其于世，未数数然也。虽然，犹有未树也。夫列子御风而行，泠然善也，旬有五日而后反。彼于致福者，未数数然也。此虽免乎行，犹有所待者也。若夫乘天地之正，而御六气之辩，以游无穷者，彼且恶乎待哉？故曰：至人无己，神人无功，圣人无名。 《师说》韩愈 古之学者必有师。师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师，其为惑也，终不解矣。生乎吾前，其闻道也固先乎吾，吾从而师之；生乎吾后，其闻道也亦先乎吾，吾从而师之。吾师道也，夫庸知其年之先后生于吾乎！是故无贵无贱无长无少，道之所存，师之所存也。 嗟乎！师道之不传也久矣，欲人之无惑也难矣。古之圣人，其出人也远矣，犹且从师而问焉；今之众人，其下圣人也亦远矣，而耻学于师。是故圣益圣，愚益愚。圣人之所以为圣，愚人之所以为愚，其皆出于此乎？爱其子，择师而教之，于其身也，则耻师焉，惑焉。彼童子之师，授之书而习其句读者，非吾所谓传其道、解其惑者也。句读之不知，惑之不解，或师焉，或不焉，小学而大遗，吾未见其明也。巫医、乐师、百工之人不耻相师，士大夫之族曰“师”曰“弟子”云者，则群聚而笑之。问之，则曰：彼与彼年相若也，道相似也，位卑则足羞，官盛则近谀。呜呼！师道之不复，可知矣。巫医、乐师、百工之人。君子不齿，今其智乃反不能及，其可怪也欤！ 圣人无常师。孔子师郯子、苌子、师襄、老聃。郯子之徒，其贤不及孔子。孔子曰：“三人行，必有我师。”是故弟子不必不如师，师不必贤于弟子。闻道有先后，术业有专攻，如是而已。 李氏子蟠，年十七，好古文、六艺，经传皆通习之，不拘于时，学于余。余嘉其能行古道，作师说以贻之。 《阿房宫赋》杜牧 六王毕，四海一。蜀山兀，阿房出。覆压三百余里，隔离天日。骊山北构而西折，直走咸阳。二川溶溶，流入宫墙。五步一楼，十步一阁。廊腰缦回，檐牙高啄。各抱地势，钩心斗角。盘盘焉，囷囷焉，蜂房水涡，矗不知乎几千万落。长桥卧波，未云何龙？复道行空，不霁何虹？高低冥迷，不知西东。歌台暖响，春光融融。舞殿冷袖，风雨凄凄。一日之内，一宫之间，而气候不齐。 妃嫔媵嫱，王子皇孙，辞楼下殿，辇来于秦。朝歌夜弦，为秦宫人。明星荧荧，开妆镜也。绿云扰扰，梳晓鬟也。渭流涨腻，弃脂水也。烟斜雾横，焚椒兰也。雷霆乍惊，宫车过也。辘辘远听，杳不知其所之也。一肌一容，尽态极妍。缦立远视，而望幸焉，有不得见者三十六年。 燕、赵之收藏，韩、魏之经营，齐、楚之精英，几世几年，剽掠其人，倚叠如山。一旦不能有，输来其间。鼎铛玉石，金块珠砾，弃掷逦迤。秦人视之，亦不甚惜。嗟乎！一人之心，千万人之心也。秦爱纷奢，人亦念其家。奈何取之尽锱铢，用之如泥沙！使负栋之柱，多于南亩之农夫。架梁之椽，多于机上之工女。钉头磷磷，多于在庾之粟粒。瓦缝参差，多于周身之帛缕。直栏横槛，多于九土之城郭。管弦呕哑，多于市人之言语。使天下之人，不敢言而敢怒。独夫之心，日益骄固。戍卒叫，函谷举。楚人一炬，可怜焦土。 呜呼！灭六国者，六国也，非秦也。族秦者，秦也，非天下也。嗟夫！使六国各爱其人，则足以拒秦。使秦复爱六国之人，则递三世可至万世而为君，谁得而族灭也。秦人不暇自哀，而后人哀之。后人哀之，而不鉴之，亦使后人而复哀后人也。 《赤壁赋》 苏轼壬戌之秋，七月既望，苏子与客泛舟游于赤壁之下。清风徐来，水波不兴。举酒属客，诵明月之诗，歌窈窕之章。少焉，月出于东山之上，徘徊于斗牛之间。白露横江，水光接天。纵一苇之所如，凌万顷之茫然。浩浩乎如冯虚御风，而不知其所止；飘飘乎如遗世独立，羽化而登仙。 于是饮酒乐甚，扣舷而歌之。歌曰：“桂棹兮兰桨，击空明兮溯流光。渺渺兮于怀，望美人兮天一方。”客有吹洞箫者，倚歌而和之。其声呜呜然，如怨如慕，如泣如诉，余音袅袅，不绝如缕。舞幽壑之潜蛟，泣孤舟之嫠妇。 苏子愀然，正襟危坐而问客曰：“何为其然也？”客曰：“‘月明星稀，乌鹊南飞’，此非曹孟德之诗乎？西望夏口，东望武昌，山川相缪，郁乎苍苍，此非孟德之困于周郎者乎？方其破荆州，下江陵，顺流而东也，舳舻千里，旌旗蔽空，酾酒临江，横槊赋诗，固一世之雄也，而今安在哉？况吾与子渔樵于江渚之上，侣鱼虾而友麋鹿，驾一叶之扁舟，举匏樽以相属。寄蜉蝣与天地，渺沧海之一粟。哀吾生之须臾，羡长江之无穷。挟飞仙以遨游，抱明月而长终。知不可乎骤得，托遗响于悲风。” 苏子曰：“客亦知夫水与月乎？逝者如斯，而未尝往也；盈虚者如彼，而卒莫消长也。盖将自其变者而观之，则天地曾不能以一瞬；自其不变者而观之，则物与我皆无尽也。而又何羡乎！且夫天地之间，物各有主，苟非吾之所有，虽一毫而莫取。惟江上之清风，与山间之明月，耳得之而为声，目遇之而成色，取之无禁，用之不竭，是造物者之无尽藏也，而吾与子之所共适。” 客喜而笑，洗盏更酌。肴核既尽，杯盘狼藉。相与枕藉乎舟中，不知东方之既白。 《氓》 诗经氓之蚩蚩，抱布贸丝。匪来贸丝，来即我谋。送子涉淇，至于顿丘。匪我愆期，子无良媒。将子无怒，秋以为期。 ②乘彼垝垣，以望复关。不见复关，泣涕涟涟。既见复关，载笑载言。尔卜尔筮，体无咎言。以尔车来，以我贿迁。 ③桑之未落，其叶沃若。于嗟鸠兮，无食桑葚！于嗟女兮，无与士耽！士之耽兮，犹可说也。女之耽兮，不可说也！ ④桑之落矣，其黄而陨。自我徂尔，三岁食贫。淇水汤汤，渐车帷裳。女也不爽，士贰其行。士也罔极，二三其德。 ⑤三岁为妇，靡室劳矣。夙兴夜寐，靡有朝矣。言既遂矣，至于暴矣。兄弟不知，咥其笑矣。静言思之，躬自悼矣。 ⑥及尔偕老，老使我怨。淇则有岸，隰则有泮。总角之宴，言笑晏晏。信誓旦旦，不思其反。反是不思，亦已焉哉! 《离骚》 屈原长太息以掩涕兮，哀民生之多艰。余虽好修姱以鞿羁兮，謇朝谇而夕替。 既替余以蕙纕兮，又申之以揽茝。亦余心之所善兮，虽九死其尤未悔。 怨灵修之浩荡兮，终不察夫民心。众女嫉余之蛾眉兮，谣诼谓余以善淫。 固时俗之工巧兮，偭规矩而改错。背绳墨以追曲兮，竞周容以为度；忳郁邑余侘傺兮，吾独穷困乎此时也。宁溘死以流亡兮，余不忍为此态也。鸷鸟之不群兮，自前世而固然。何方圜之能周兮？夫孰异道而相安？ 屈心而抑志兮，忍尤而攘诟。伏清白以死直兮，固前圣之所厚。 悔相道之不察兮，延伫乎吾将反。回朕车以复路兮，及行迷之未远。步余马于兰皋兮，驰椒丘且焉止息。进不入以离尤兮，退将复修吾初服。制芰荷以为衣兮，集芙蓉以为裳。不吾知其亦已兮，苟余情其信芳。 高余冠之岌岌兮，长余佩之陆离。芳与泽其杂糅兮，唯昭质其犹未亏。忽反顾以游目兮，将往观乎四荒。 佩缤纷其繁饰兮，芳菲菲其弥章。 民生各有所乐兮，余独好修以为常。虽体解吾犹未变兮，岂余心之可惩？ 《蜀道难》 李白噫吁嚱，危乎高哉！蜀道之难，难于上青天，蚕丛及鱼凫，开国何茫然！尔来四万八千岁，不与秦塞通人烟。西当太白有鸟道，可以横绝峨眉巅。地崩山摧壮士死，然后天梯石栈相钩连。上有六龙回日之高标，下有冲波逆折之回川。黄鹤之飞尚不得过，猿猱欲度愁攀援。青泥何盘盘，百步九折萦岩峦。扪参历井仰胁息，以手抚膺坐长叹。 问君西游何时还？畏途巉岩不可攀。但见悲鸟号古木，雄飞雌从绕林间。又闻子规啼夜月，愁空山。蜀道之难，难于上青天。使人听此凋朱颜！连峰去天不盈尺，枯松倒挂倚绝壁。飞湍瀑流争喧豗，砯崖转石万壑雷。其险也如此。嗟尔远道之人胡为乎来哉？ 剑阁峥嵘而崔嵬，一夫当关，万夫莫开。所守或匪亲，化为狼与豺。朝避猛虎，夕避长蛇；磨牙吮血，杀人如麻。锦城虽云乐，不如早还家。蜀道之难，难于上青天，侧身西望长咨嗟！ 《登高》 杜甫风急天高猿啸哀，渚清沙白鸟飞回。无边落木萧萧下，不尽长江滚滚来。 万里悲秋常作客，百年多病独登台。艰难苦恨繁霜鬓，潦倒新停浊酒杯。 《琵琶行》白居易浔阳江头夜送客。枫叶荻花秋瑟瑟。主人下马客在船，举酒欲饮无管弦。醉不成欢惨将别，别时茫茫江浸月。 忽闻水上琵琶声，主人忘归客不发。寻声暗问弹者谁，琵琶声停欲语迟。移船相近邀相见，添酒回灯重开宴。千呼万唤始出来，犹抱琵琶半遮面。转轴拨弦三两声，未成曲调先有情。弦弦掩抑声声思，似诉平生不得志。低眉信手续续弹，说尽心中无限事。轻拢慢捻抹复挑，初为霓裳后六幺。大弦嘈嘈如急雨，小弦切切如私语。嘈嘈切切错杂弹，大珠小珠落玉盘。间关莺语花底滑，幽咽泉流水下滩。水泉冷涩弦凝绝，凝绝不通声渐歇。别有幽愁暗恨生，此时无声胜有声。银瓶乍破水浆迸，铁骑突出刀枪鸣。曲终收拨当心画，四弦一声如裂帛。东船西舫悄无言，唯见江心秋月白。 沉吟放拨插弦中，整顿衣裳起敛容。自言本是京城女，家在虾蟆陵下住。十三学得琵琶成，名属教坊第一部。曲罢曾教善才服，妆成每被秋娘妒。五陵年少争缠头，一曲红绡不知数。钿头银篦击节碎，血色罗裙翻酒污。今年欢笑复明年，秋月春风等闲度。弟走从军阿姨死，暮去朝来颜色故。门前冷落车马稀，老大嫁作商人妇。商人重利轻别离，前月浮梁买茶去。去来江口守空船，绕船月明江水寒。夜深忽梦少年事，梦啼妆泪红阑干。 我闻琵琶已叹息，又闻此语重唧唧。同是天涯沦落人，相逢何必曾相识。我从去年辞帝京，谪居卧病浔阳城。浔阳地僻无音乐，终岁不闻丝竹声。住近湓江地低湿，黄芦苦竹绕宅生。其间旦暮闻何物，杜鹃啼血猿哀鸣。春江花朝秋月夜，往往取酒还独倾。岂无山歌与村笛，呕哑嘲哳难为听。今夜闻君琵琶语，如听仙乐耳暂明。莫辞更坐弹一曲，为君翻作琵琶行。 感我此言良久立，却坐促弦弦转急。凄凄不似向前声，满座重闻皆掩泣。座中泣下谁最多，江州司马青衫湿。 《锦瑟》 李商隐锦瑟无端五十弦，一弦一柱思华年。庄生晓梦迷蝴蝶，望帝春心托杜鹃。沧海月明珠有泪，蓝田日暖玉生烟。此情可待成追忆，只是当时已惘然！ 《虞美人》 李煜春花秋月何时了？往事知多少。小楼昨夜又东风，故国不堪回首月明中。雕栏玉砌应犹在，只是朱颜改。问君能有几多愁？恰似一江春水向东流。 《念奴娇?赤壁怀古》 苏轼大江东去，浪淘尽、千古风流人物。故垒西边，人道是，三国周郎赤壁。乱石穿空，惊涛拍岸，卷起千堆雪。江山如画，一时多少豪杰。 遥想公瑾当年，小乔初嫁了，雄姿英发。羽扇纶巾，谈笑间，樯橹灰飞烟灭。故国神游，多情应笑我，早生华发。人生如梦，一尊还酹江月。 《永遇乐?京口北固亭怀古》 辛弃疾千古江山，英雄无觅孙仲谋处。舞榭歌台，风流总被，雨打风吹去。斜阳草树，寻常巷陌，人道寄奴曾住。想当年金戈铁马，气吞万里如虎。 元嘉草草，封狼居胥，赢得仓皇北顾。四十三年，望中犹记，烽火扬州路。可堪回首，佛狸祠下，一片神鸦社鼓！凭谁问 廉颇老矣，尚能饭否？]]></content>
      <categories>
        <category>互联网</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>收集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX 中的特殊符号]]></title>
    <url>%2F2016%2F02%2F17%2FLaTeX-%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[转载文章]]></content>
      <categories>
        <category>互联网</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>link</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求和]]></title>
    <url>%2F2016%2F02%2F17%2F%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[Description若两个数的最大公约数为1，则这两个数互质。现在给出一个正整数N（1&lt;=2^31-1)，你的任务是求出1~N中与N互质的数的总和。 Input一个整数N Output一个整数sum，表示1~N中与N互质的数的总和。 Sample Input110 Sample Output120 Analysis这道题有两种解题方法 第一种方法（数论）结论:$ans=N*\Phi(N)/2$ 证明:if gcd(n,i)=1 then gcd(n,n-i)=1 (1&lt;=i&lt;=n) 反证法： 如果存在K!=1使gcd(n,n-i)=k,那么(n-i)%k==0 而n%k=0 那么必须保证i%k=0 k是n的因子,如果i%k=0那么 gcd(n,i)=k,矛盾出现; 于是问题变的非常简单： ANS=N*phi(N)/2 i,n-i总是成对出现，并且和是n 于是可能就有人问了，如果存在n-i=i那不是重复计算？ 答案是不会 因为: n=2*i-&gt;i=n/2 如果n是奇数，那么n!=2*i,自然也不存在 n-i=i和重复计算之说 如果n是偶数,n=2*i成立,gcd(n,n/2)必然为n的一个因子,这个因子为1当且仅当n==2 于是对于n&gt;2的偶数，绝对不存在gcd(n,n/2)=1所以更别说什么重复计算了 123对于n==2ans=2*1/2=1，正好也满足 所以得到最终公式：$ans=N*\Phi(N)/2$时间复杂度$O(\sqrt {N})$详见代码1 第二种方法(容斥) 我们可以先求1..N中与N不互质的数的和。即$GCD(N,x)\not=1$ $N = p1^{r1}*p2^{r2}*p3^{r3}*…*pn^{rn}$ 时间复杂度$O(\sqrt {N})$我们尝试构造一个非法的数M，使得$M | N$，由N的若干个质因数相乘得到。 $M = p1*p2*…*pm$ 枚举M的时间复杂度$O(2^n)$对于奇数个质数相乘累加，对于偶数个质数相称累减。这样得到一个不合法的最小数M,我们可以设 $Q=M*K,(1&lt;=k&lt;=N/M)$ 得到一些列不合法的数Q,将他们累加起来，即 $\sum_{K=1}^{\frac{N}{M}}M*K = M*\frac{(\frac{N}{M}+1)*\frac{N}{M}}{2}$ 最后的时间复杂度即$O(\sqrt {N}+2^n)$,n很小最大只有10。 详见代码2 Code代码1:1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;typedef long long LL;LL ans;int n;LL phi(int n)&#123; LL ret = n; for (int i=2;i&lt;=sqrt(n);i ++) &#123; if (n%i==0) &#123; ret = ret/i*(i-1); while (n%i==0) n /= i; &#125; &#125; if (n&gt;1) ret = ret/n*(n-1); return ret;&#125;int main()&#123; //freopen("1164.in","r",stdin); //freopen("1164.out","w",stdout); while (scanf("%d",&amp;n)!=EOF) &#123; LL ans; if (n==1) ans = 1; else ans = phi(n)*n/2; printf("%lld\n",ans); &#125; return 0;&#125; 代码2:12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;typedef long long LL;int pri[100];LL ans,n;void prepar(int n)&#123; for (int i=2;i&lt;=sqrt(n);i ++) &#123; if (n%i==0) &#123; pri[++ pri[0]] = i; while (n%i==0) n /= i; &#125; &#125; if (n&gt;1) pri[++ pri[0]] = n;&#125;int main()&#123; //freopen("data.in","r",stdin); //freopen("1164.out","w",stdout); while (scanf("%lld",&amp;n)!=EOF) &#123; ans = 0; prepar(n); for (int st=1;st&lt;(1&lt;&lt;pri[0]);st ++) &#123; int tot = 0,tmp = 1; for (int i=0;i&lt;pri[0];i ++) if (st &amp; (1&lt;&lt;i)) tmp *= pri[i+1],tot ++; if (tot&amp;1) ans += (1+n/tmp)*(n/tmp)/2*tmp; else ans -= (1+n/tmp)*(n/tmp)/2*tmp; &#125; ans = (unsigned long long)n*(n+1)/2-ans; printf("%lld\n",ans); &#125; return 0;&#125; Referenceshdu3501 给出一个N，求1..N中与N互质的数的和]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摘抄]]></title>
    <url>%2F2016%2F02%2F15%2F%E6%91%98%E6%8A%84%2F</url>
    <content type="text"><![CDATA[未分类 社会最大的悲剧，不是坏人嚣张，而是好人的沉默。 ——1963马丁路德金 电影的力量在于动人，卡通的力量在于纯真，宫崎骏掌握了这些力量，他取得了理所当然的胜利。（新闻晚报评） 总之，被美好事物吸引是无罪而美丽的，但是当这种想法升级为占有欲和社会规则结合到一起可能就产生了破坏性。 希腊中的神都像人类，也会有各种各样的缺点，因为是神，能力放大，缺点也会放大，有教育意义吧。 分类对联 映日门庭增气象 接天梁栋起云烟（乔迁新居） 双飞却是关雎鸟 并蒂常开连理枝（新婚） 凤律新调三阳开泰 鸿犹丕振四季亨通（开张） 明月一池莲 钓渭丝纶日月长 （祝寿） 完来大璞眼天地 留得和风惠子孙 （挽联） 白雪映红梅春回大地 凯歌偕丽日福满人间 （春联） 春夏秋冬一岁川流不息 东西南北四方宾至如归 （旅店) 巧手度处天衣无缝 匠心裁来长短合身 （裁缝店） 虽是毫末技艺 却是顶上功夫 （理发店） 满屋诗书添丽景 盈门桃李笑春风 （老师）]]></content>
      <categories>
        <category>互联网</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>收集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电影《千与千寻》]]></title>
    <url>%2F2016%2F02%2F15%2F%E7%94%B5%E5%BD%B1%E3%80%8A%E5%8D%83%E4%B8%8E%E5%8D%83%E5%AF%BB%E3%80%8B%2F</url>
    <content type="text"><![CDATA[序言 正值春节假期，可以好好地放松一下。准备找几部电影来看下。很早就注册过豆瓣的账户了,想找一些高分电影来看下。在一份“同时入选IMDBTop250与豆瓣电影Top250的电影”的豆列中，发现了这部电影。 我对这部电影最早的印象是在小学的一次六一文艺汇演。当时我们正在后台准备（阶梯教室），老师怕我们无聊，就给我们放了这部电影。虽说还并不知道这部电影名，但是在我的心中留下了一些画面。在我心目中印象最深的是白龙带着千寻穿过人类世界到汤屋的桥。因为不能被其他人闻到有人类的气息，而屏住呼吸向前跑。 因为是关于神明鬼怪的故事，所以在我幼小的内心觉得有点恐怖。（可能也是这让我对这部影片有了较深的印象） 于是乎在妈妈的陪同下，重新完整的看了一遍这个电影。 看完这部片时,并没有觉得有什么特别之处,觉得很稀奇为什么在豆瓣上可以得这么高的分。等我看了一些其他人写的影评的时候,就发现自己”too young too naive”。 观后感 一直以来,都没有机会看这部广为人知的动漫电影。也是因为在豆瓣上突然看到其评分很高，加之小学曾经对这部电影有些许的印象。所以，决定花一些时间完整的看一遍这篇电影。当我看完这部电影后，加上一些豆瓣上的影评。是我对这部片子的喜爱到了近乎疯狂的地步。 第一次看完，并没觉得有什么特别之处。仅仅是当故事看完了一遍，在看完了一些人的影评后，发现这不仅仅只是一个冒险片，而是一个教育片。整个片子每一处细节，每一个角色都具有特殊的含义，都象征着社会中的某些人或事。 整个汤屋其实就是一个人类社会的缩影，作者宫崎骏特意将千寻置身于这样一个环境中。千寻因为父母“贪吃”的原因，无人依靠，而被迫提前的融入这个社会。在这样一个物欲横流社会环境中，勿忘自我，逐渐成长自强、坚毅的小女孩。凭着自己的努力，做出正确的抉择，最终救会自己的父母。现在很多人为了融入这个社会，迎合这个时代的体制和规则。而忘了初心，忘了自我，不知自己最初来的目的。 人不能不劳而获，沉迷于享乐之中。千寻的父母就因为这一原因变成了“猪”。因贪图美食而一发不可收拾，自己虽说吃完了再付钱，但是未经主人同意，擅拿他人财物本身就是错误的！人一旦被欲望锁左右，就会慢慢地失去了勤奋，思想开始沦陷、堕落。没有得到的自省和控制，一旦变成“猪”后，后悔也来不及了。 做人要独立！勇敢！自强！。在误入神明之地之前，千寻和大多数孩童一样，是一个娇气的城里人。当父亲决定走进那个漆黑的洞口时，千寻表现出是一种害怕、无助的神情。刚开始时，极力反抗，走回车旁。最后，看到身旁的雕像后，还是不自觉的走向自己的父母。在父母都变成“猪”后，身边唯一可以依赖的人已经不能依赖了。此时在“白龙”的帮助下，找锅炉爷爷、汤婆婆索要工作，一步步走向独立。再见过各种各样的妖魔鬼怪之后，逐渐提升与人交往的能力，达到勇敢。 朋友的力量可以在需要的时候指引你。当发现自己的父母亲忽然变成了“猪”的时候，在像大多数孩子只能坐在地方大哭、万念俱灰的时候，故事合情合理，没有将小千寻神化，而是安排“白龙”的出现，让失望的人不要绝望。相较于父母亲，你获得社会的认可，并交到合适的朋友在你的一生中起到的作用要比你父母亲来得更有帮助！千寻在朋友的帮助下，没有绝望，而是将悲痛隐在心里，勇敢地面对现实。 在物欲横流的社会中，勿忘自我，勿忘初心。就像影片中白龙所说：“汤婆婆通过夺取他人的名字来控制你。”可能在汤屋里面的很多为汤婆婆做事的人，也是因为这个原因。而被汤婆婆控制，无法离开这个地方。当无脸男给了她很多可以减轻她工作量的热水令牌时，她拒绝了。当无脸男想通过钱财来讨千寻喜欢时，她也拒绝了。无脸男在其中就是一个被世俗污染的典型例子。就像千寻所说：“那个人是因为在汤屋中才变坏的，让他离开那里比较好。” 千寻在汤屋中并不随从流俗，那是因为她知道她不属于这个世界，她的财宝也不在这里，千寻最大的愿望不过只是带着她的父母脱离这个世界，回到真正属于他们的家。 除了这些，影片中还有涉及礼貌，勤奋，环保等诸多方面。一部好电影并不在于它的画面，声音有多么震撼。不在于是否请了一些明星大腕来参与演出。即使是一部成本很低的、面向孩子的动画，当剧中透出“人”性之美，许多“正能量”，引人深思。它就是一部好电影。 经典台词 不管信用卡或现金我都有。（有些东西是钱买不到的） 吃了不会变成猪的。 我是站在你这边的。 连门都不会先敲一下。 为什么你想要工作我就要雇用你！ 不能吃太胖哦，会被杀掉的！ 哭出来就好了。 不跟我玩儿，我就哭给你看。 用魔法做的（护身符）一点用都没有。（真心的祝福远远比魔法做的有用） 客人也不能无礼。（即使你是上帝） 名子一但被夺走就再也找不到回家的路了。（不能忘记自我） 我们两个是双胞胎，却一点儿都合不来。（外在一样，内在不同，却是天壤之别） 我永远不会雇佣你们这群好吃懒做的人类！ 曾经发生的事不可能忘记，只是想不起来而已。 虽然我很想救你，但是我什么都做不到，因为这是这个世界的规则，你的父母也好，你的男朋友龙也好，只能靠你自己去救。 一直向前走。千万别向后看。否则就永远回不去那个世界了。 很奇怪，我忘记了我自己的名字，但是千寻的名字我却一直都记得 这个世界上，你可以碰到机遇，而绝不可能碰到“神”，自己的路，还是得自己走! 人生就是一列开往坟墓的列车，路途上会有很多站，很难有人可以自始至终陪着走完。当陪你的人要下车时，即使不舍也该心存感激，然后挥手道别。 那个人是因为在汤屋中才变坏的，让他离开那里比较好。 收集著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。作者：风雨骑链接：https://www.zhihu.com/question/22799802/answer/22715069来源：知乎 3.《千与千寻》中间讲的最重要的内容是什么？不要忘记自我。千寻从迷失在汤屋，到最后想起自己的名字。这是什么母题？自我救赎。这是全世界电影都在探索与表达的内容。 参考资料维基百科 百度百科 豆瓣 知乎 台词来源 百度百科中各任务简介，豆瓣影评或问题[1][2][3][4]]]></content>
      <categories>
        <category>互联网</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>电影</tag>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crystal 李馨巧]]></title>
    <url>%2F2016%2F01%2F26%2FCrystal-%E6%9D%8E%E9%A6%A8%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[序言其实早些时候，我就决定专门写一篇关于她的博文，但一直没时间写。现在放寒假了也有这个机会和这个时间写。 为什么要写这个专题？这是一个相当重要的问题!!首先那当然是因为我非常喜欢她啦!在我了解和认识的那么多童星中，她是最耀眼的，也是最令人难忘的。我喜欢她，不仅是因为颜值（我对颜值要求很低的），华人（外国小孩实在是看不习惯），获过大奖，更因为她的素养、学业和心态。对人很有礼貌，学习成绩优异。尽管表面上很“小大人”，但实际上是一个不折不扣的小孩，有童心，乐观的对待世界。其次是受到了知乎的影响，在知乎上，我看到了各行各业，各种各样的人在上面分享自己的见解和看法。所以也就决定在博客上弄一个专题。写这个专题的另外一个目的也是为了记录，整理与她相关的信息。方便我日后的追忆和检索。 她也是我第一个写的关于个人的专题。可能写的会有些不好，请见谅！我不想写成一个人物传记，所以想用时间线的方式来叙述和评论我眼中的“Crystal 李馨巧”。下面是关于她的百科信息。 时间线《中国新声代》最早见到李馨巧是在《中国新声代》第一季的节目上，当时就留有了一定的印象。其实，我认为当时她在台上的形象并不太好，披头散发的，穿着一身红衣服，就显得特别的成熟，不像一个小孩应有的神态。 后台(上台前)之所以令我印象深刻，是因为在她出场前的介绍(在拍《激战》获奖以前)。当麦咭问到她说她有跟很多大明星合作过电影，她也就很从容淡定的如实回答，说跟周杰伦和谢霆锋合作过，还有一段关于影片《激战》的VCR。(需要核实)当时确实被影片中那可爱乖巧的表演打动到了。(也是在这个VCR中发现她会说粤语)接下来是麦咭问她带来陪同的人，她带了妈妈(她可是不折不扣的妈妈控啊！！)，和经纪人哥哥(What!!)，她是我目前为止唯一一个看到的，在新声代的舞台上，带经纪人陪同的小孩。当时的我是震惊的。所以在上台前就已经被她的经历所震撼到了。也怪不得海泉会评价其气场强大。 正式上台她带来的歌曲是《price tag》(只要有机会上台表演唱歌，这是她的首选歌曲)，这首歌也是我认为的，她所有翻唱歌曲中最好的一首。台上的表演那就是自然，活泼，气场强大。像一个专业演员在演出。声音也够甜美，完完全全未经修饰的童声！！ 总结但是其实并没有太在意这个人，主要是她上台前的介绍以及当时的形象造成的。感觉特别有背景，对于非常有背景的人我一般都会否定掉的。再加之她是马来西亚人，不是中国人。而且在那之前，我已经粉上了同为这季新声代的另外一个小孩王睿卓，所以对她的关注就少了。 一段时间过了很长一段时间也没有怎么关注她，只是在新浪微博中顺带关注了她的微博帐号，我发现她的关注人数也并不怎么多嘛！而且微博信息也停留在了2014年，很久没有更新了！我想，也正常，毕竟是海外的人，人家的主战场应该在Facebook。(容许我再一次鄙视一下GFW)。 在这期间，我将很多新声代学员的歌加进了酷狗音乐，唯独其中四人的歌最讨我喜欢，(其中就包括了李馨巧)。特别是当我听厌了其他三人的歌时。她的歌声真的令我百听不厌，我要的就是这种几乎不加修饰的童声，(天籁之音)而她的歌声做到了这一点。所以我决定上网爬取所有与她相关的信息，就在这个漫长的爬取过程中，我粉上了她。 百度百科&amp;维基百科对于任何一个公众人物来说，想了解她的信息，最好不过的就是看百科中相应的词条。百科中的词条，往往都是各个网友从其他网页中，搜集并汇集的来源可靠的资料。(这里点名批评一下百度百科，参演的电影角色名称搞反了，关键是还不让我修改) 我就先按照她获奖的电影或电视剧中依次找寻她的镜头。并且搜索与她相关的其他电影电视剧。 下面是我按照时间顺序观看她参演的电影电视剧《激战》《逆战》《足印》《天天好天》《逃出生天3D》《甲洞2》《哥妹俩之惊历48》《稽查专用》《小宝学弟子规》 视频资料跳转 激战获奖状况这也是她在大陆出名的一部影片。因为上海国际电影节破天荒的将最佳女演员的奖项给了她。使她从此获得了史上最年轻影后的殊荣。最初我以为这个奖项只是针对这部影片而言，毕竟这部影片中的女演员也确实少，也不足为奇。后面才得知是在多部影片中评选出来的。 在百度搜索中，可以发现大多数的搜索结果都是与这部影片相关的，国内的媒体采访(包括港澳台)都基本是围绕这部影片来采访的。所以说，她在中国大陆的出名完全就是因为这部影片和上海国际电影节的金爵奖。同时也要感谢这部电影的制作方和导演(林超贤)。确确实实是林超贤捧红了她。 角色定位就采访时导演的话来说，这部电影他是有意增加梁佩丹这个角色的，作为整个电影情感线的重要一部分。林超贤导演之所以看上她，是因为他记得以前《逆战》那部电影中表现出色，但是戏份又不多，想要专门设计一个角色来给李馨巧演。 这个角色对于演员来说难度还是很大的！影片需要一个年龄小但心智非常成熟的小女孩(单亲家庭的孩子，还要照顾精神病的妈妈，像个“小大人”一样管理者整个家)，这恰恰也是馨巧的特点之一。所以说选择她来演这个角色再适合不过了。 印象深刻的地方(剧情信息以粤语版为标准) 从影片的10分钟左右(需要核实)出场，出场时，就给人一种“小大人”的感觉。向程辉一本正经的介绍家里的注意事项！还要哄妈妈睡觉。特别是他们两个在厕所门口的对手戏，将自己的强势一面表现了出来(显得特别攻)。大家都像个陌生人一样，相互提防着对方，充满着不信任。 在影片24分钟，小丹与程辉的对话尤为精彩，为了能与程辉相处的更好，将自己的家事讲了出来，叙说故事的时候相当的淡定啊！！好像看透了世间的所有事情。 在影片中间环节也渐渐的可以看得出她变得开朗了许多，得到了家的温暖。尽管中间出现了一些事故！！ 在影片58’32”可以看到她标志性的笑，你可以在很多其他视频中看到！ 小结通过与前面的戏比较，可以发现她在这部戏中表现的更加成熟了，表现的更加自然。华语和粤语的配音都非常棒，基本上去除了她之前很重的马来西亚华语的口音。也可能是电影后期制作时进行训练造成的。 逆战前言之所以选择这两部林超贤导演的作品，是因为这两部影片的资源特别好找。(毕竟在中国大陆上印过)，网上的各种资源都是这两部电影，想要找马来西亚的电影电视剧真是太难找了，要练就一身翻墙本领，还要有辨别不同语种的能力！ 角色定位在片中她的爸爸是谢霆锋，叔叔是周杰伦。(这也是在激战之前[包括新声代]，被屡次宣传的跟巨星合作过)至于她的妈妈，电影中好像并没有提到过。不过我认为应该是一个单亲家庭的孩子。(李馨巧演的角色都挺悲惨的，要不就是单亲家庭，要不就是孤儿，是因为她特别懂事、成熟的缘故吗)，同时是一个品学兼优的好孩子哦！(这跟她本人其实有几分相似的!)逆战的角色算是本色出演了!做马来西亚黑帮的小孩。因为当时林超贤导演需要找一个，在马来西亚生活过的女孩！因为在马来西亚李馨巧已经是小有名气的童星了，在一次面试过后就选择她了。 在学习上拿了100个100分，以此来换取他爸爸的改邪归正。每天跟爷爷生活，和爸爸一起东躲西藏的逃窜。她同样是一个弱小的小孩，最后惨遭厄运，被其他黑帮还去做活体天花病毒实验。乖巧，弱小，善良和优异的成绩，这就是我的大致印象吧！ 小结其实我并不大喜欢这种类型的电影，打打杀杀的情节太多了，就是来看大明星的嘛！令我惊讶的是周杰伦竟然听得懂粤语……毕竟情节需要…… 小馨巧也就是在街上看电视的时候出现的。(又是那熟悉的校服)看到他爸爸(谢霆锋)从监狱中逃跑出来的新闻。虽说他爸是逃犯，但是他跟爷爷生活的还是挺幸福的，并没有因为他爸是坏人而影响她的个人生活，使她与其他小朋友不一样。反而因为他爸的坏人身份使她变得很成熟、更坚强、更冷静。因为警匪勾结的缘故，在火车上没有成功逃出，爸爸被警察抓捕。最后，万长胜被抓去做活体的天花实验了。还被惨遭抛海。最令人惊奇的是竟然没死！(这一点都不科学嘛！有木有？)可能导演实在是不忍心啊！！两部电影中都奇迹般的起死回生。 最最佩服的应该就是被抛到海里的那一刻了，这也是打动导演林超贤的地方。“” “因为拍戏需要，这个小女孩曾泡在海水中7个小时，敬业精神更是令人啧啧称赞。（网易娱乐评）”我想这说的就是这部电影吧！在海水中那样艰苦的环境下，也能坚持下去，实属不易。 从这部反应开始，李馨巧就开始正式进入中国，被许多 足印前言人生第一部马加西亚电视剧啊！！了解到了马来西亚的状态和当地华人圈的文化，自己那有些许口音的华语……其实关注这部电视剧的时候，是在优酷上看到的关于这个电视剧的部分片段。发觉演的特别棒啊！ 然后开始了漫长的寻资源之路……首先百度大法未果，Google大法未果，YouTube大法未果，优酷大法有点果。但是视频上了密码，可是也只有在优酷上才有了，最后在评论中找到了密码，但是没有第一集，所以也就从第二集，没头没尾的开始看了。 角色定位讲述关于一个坚毅女性，终其一生报恩与传承的故事。当纯洁的爱情及伟大的亲情，遇上贪婪的名利与人心的自私，总是让事情变得错综复杂，难以抉择 这回可是主角了，戏份可是相当的多啊！！(一点都不怂)，尽管作为主角的童年时期只有前5集。但这5集可是相当的精彩啊!! 又是一个悲惨的角色啊，再片中演小严厉，在大概3,4岁的时候，妈妈因为跟爸爸闹不合(爸爸吃喝嫖赌)，而离家出走。妈妈为了追求更高的理想而抛弃了严厉，尽管后来被找到了，也没有回去。后面只好跟着爸爸，到处骗人钱财，过着流离失所的生活。最后爸爸因为不守信发生仇恨，而被人打死，最终成了一个孤儿。一个做鞋的老板娘收养了她。 印象深刻的地方第一集其实整集都可以看到她乖巧可爱的状态（卖萌）。但同时他也会跟他爸爸闹矛盾，说他不上工，将一个坏小孩应有的状态活灵活现的展示了出来。 第二集在4’10’’的时候，望着那一闪一闪的灯时，特别的可爱…（好吧，我承认我是萝莉控）,一直不说话，就是在和爸爸赌气。因为偶然间她听到了她爸爸要把她卖掉的事。在6’48’’为了讨好小严厉，爸爸买鞋给她，小严厉不仅不理人，还大骂了一句。最后被人贩子关押在一间房子里，同时还有鞋店家的小孩言毅仁。 第三集最后面的那段哭戏非常的棒！ 第四集在37‘左右那段，因该算是高潮了吧，从面部神态到眼神，将内心的状态诠释的非常好！ 在38’左右有肉色哦！ 其实这段说的话令我印象很深刻！ ”妈妈为什么不要我，竟然不要我，为什么还要生我。” “有时大人做事真的不顾后果的”，这一句话，让我联想到了风之谷。 “生你的人不一定爱你，爱你的人也不一定是生你的” 这是前5集中，令我印象很深刻的几句台词。人做事情要一定要有责任感，要多考虑考虑后果，不能因为一时的痛快。不然，可能会给自己或者其他人带来无尽的痛苦。 故事剧情第一集最开始，就已经和爸爸过着流浪的生活了，和父亲一起到处骗人钱财。同时不喜欢上学，他爸爸也是不喜欢做工。过着得过且过的日子。骗走了一家钱又辗转到了其他村庄继续寻找骗钱的机会。本来得到了 一次很好的做工机会。但因为父亲三天打鱼两天晒网，最后被老板炒掉。手头上有点钱了，就全部拿去赌博了，最后输光所有的钱，还欠了一屁股的债。为了还债，在不得已的情形下，萌生起了卖小孩的念头 第二集本来说只是给孩子一个更好的家庭生活，但最后其实这都是骗局，人贩子吧到手的小严厉，准备辗转卖给其他人，因为登船的缘故，而将严厉带进了一个无人的小屋子。正巧，这一切被鞋店的老板娘的儿子言毅仁发现了。 第三集小严厉凭借着聪明才智，最后顺利的从小屋里逃出，最后被鞋店老板娘救起。因为父亲没钱偿还债务，最后被鞋店老板娘收养。刚开始时，小严厉是排斥这个“新妈妈”唐玉梅的。曾经几次想要离家出走，因为自尊心被人践踏，还恶作剧过几次。但终究是内心善良的。这期间爸爸被人暴打，给小严厉过了最后一次生日就离世了。 （这里有一段很长的哭戏哦！） 第四集失去了父亲的严厉，在唐玉梅的陪伴下，去寻找自己的其他亲人，她的亲生母亲。期间回过他们以前的家，那里有一些与父母生活的美好的回忆，以及一些小时候的印记。在鞋店里做工，来赚钱以得到自由。最后面经过打听得知了小严厉妈妈的住处。但是她的妈妈并没有认她。无意间，唐玉梅发现了那个人就是小严厉的亲生母亲。经过一阵交涉后，最后还是拦不住她妈妈。 第五集失去了亲人的小严厉显得特别的无助，最后在善良的鞋店老板娘唐玉梅家，继续生活下去。小严厉逐渐接受了这个母亲，和这个家。跟哥哥言毅仁在同一所小学读书。这期间，因为不想上学，而让自己的哥哥受了伤。尽管如此，唐玉梅还是原谅了她。经过了这次事件后，小严厉慢慢地不在对学校反感，但还是改不了恶作剧的坏习惯！ 小结很多人可能看不惯这种朴素的东西。我还是比较怀旧的人，看到那些两三层高的建筑，简简单单的道路，心里感觉特别的舒服。难道是因为在城市中待得太久的缘故。 马来西亚的很多电影电视剧，都是这样的。很难看到像广州一样的高楼大厦。感觉回到了解放前，生活的速度比我们慢多了。尽管如此，但依旧也有很多新事物。 我比较喜欢那些有内涵，有内容的视频。尽管演员的演技都不怎么样！ 主题曲很好听！比较喜欢这种略带忧愁的歌。 天天好天豆瓣上评分挺高的嘛！温情的家庭片！豆瓣上的很多影评说的都不错。 相比之下，这种电影比较贴近生活，没有绚烂的各种特技，或者是一些特别的剧情。一切都很自然，能够勾起你对美好往事的回忆。 李馨巧在影片中戏份不多,可能略显做作,但也是一部很不错的电影。看看海外的华人是怎样的一种生活状态。 马来西亚相比于中国，生活节奏还是挺慢的！各种各样的文化交织在一起，说着不同的语言。生活挺惬意的，有种与世俗隔绝之感！但同时还是比较仰慕于西方的！ 群星合唱的主题曲不错！喜剧电影，将孝道的。为何我总感觉中国在传统文化宣传弘扬方便都做的不如海外华人好，甚至不如日本！！ 这部戏我印象还是很不错的，不像美国大片那样，狂拽炫酷吊炸天！！也不像日剧那样，说理说个不停，耗费大量脑细胞！我内心其实是有一种向往自然平静生活比较消极的想法！所以在马来西亚的影片中，我对这部评价最高！ 逃出生天3D中国大陆拍的片子，好像也是李馨巧第一次参与中国导演的片吧！3D卖点沦为纯噱头，不就是学会了些特效，装一下逼吗？谦虚！！剧情也是够令人无语的，就是去看特效的嘛！ 豆瓣上的评分也是低的可以！纯属看看效果，还不如去看好莱坞大片呢！ 李馨巧在其中纯粹是酱油！也不过就几个镜头。饰演一个被困女孩。 剧中倒是可以看到许多广州的标志性建筑，觉得挺亲切的。 甲洞2这好像是一部关于黑帮的电影吧！好不容易找到了一个可以看的资源，竟然是生肉(无字幕，WTF)，再一次吐槽一下，马来西亚的电影电视剧可真难找啊！如果在优酷土豆上都没有的话，基本没戏！百度，这种盗版资源集聚的地方，都找不到！Google也是没戏！看了这部剧，第一就是要考我的粤语听力，好歹我也是在粤语区生活了15年的人了，听粤语还是没什么大问题的。(除了华语，粤语是唯一一个能听的懂的语言)第二就是感觉李馨巧长大了好多，长高了！演技嘛，在某些片段中表现的还是相当出色的！因为语言问题，加之情节比较灰暗。所以，也看不明白编剧到底想要说些什么。对整部片子没什么感觉。总之，浑浑噩噩就看完了。 其他剧集其他剧集都是些马来西亚本土的电视剧及电影。而李馨巧也是以打酱油为主，也没什么地方值得看的，再加之视频画质实在是渣(这也是没办法的事)。 人物评价(以下仅代表个人观点) 演戏确切的说，李馨巧应该是一名子役，在很小的时候！(什么时候)就开始拍广告了，也是因为广告的契机，才入的演艺坑的吧！在马来西亚，她确实是当之无愧的影后！即使在中国，这个头衔也是摘不掉的。但要是到日本韩国，那就是分分钟就没秒掉的节奏啊！从足印中就能看出她是演戏的料，尽管剧情设定并不是让她本色出演。但在整部剧中饰演一个单亲家庭的小孩，把整个小孩应有的天真，活泼，活灵活现的表现了出来。特别是爸爸离世时的那段哭戏，令我印象很深刻！也正因为这部戏《足印》，令她在马来西亚华人圈中小有名气。一次偶然的机会遇到了香港林超贤导演，开始踏入香港的演艺圈。因为《激战》中出色的演技，赢得了上海国际电影节的奖项。逐渐的被中国大陆人所知。也是因为这个奖项，马来西亚媒体把她捧到天上去了。凭借自己的天赋，尽管在马来西亚，这种演艺环境一般的情况下，能够坐上马来西亚童星的第一把交椅，也是相当难得的！我觉得她是一个可以跟日本子役刚正面（演技）的人，在《足印》中的哭戏也是很强的，很有代入感！相比于日本子役，母语是英语的李馨巧，更适合在西方世界中混啊！况且还会5种语言，以后真的可以到好莱坞去发展！！日本子役的国际化都不大行，日式英语真的很感人！！ 唱歌在《中国新声代》中，她曾经说过，她要像其他人证明，她不单只会演戏，还会唱歌。 学习语言英语马来语粤语华语日本语 照片前方高能!!!一大波美图即将来袭!!(流量党请注意) 视频 百度云《激战》 粤语版(原版) 国语版《逆战》《足印》《天天好天》《逃出生天3D》粤语版(原版) 国语版《甲洞2》《哥妹俩之惊历48》《稽查专用》《小宝学弟子规》 社交账号新浪微博[1(认证)][2][3]Facebook(认证)TwitterInstagramGoogle+ 参考资料 百度百科维基百科优酷逆战 (豆瓣)逆战(维基百科))足印(豆瓣) Youtube[1(认证)][2]]]></content>
      <categories>
        <category>人物</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>未完成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AC自动机算法详解]]></title>
    <url>%2F2015%2F12%2F22%2FAC%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[转载文章]]></content>
      <categories>
        <category>信息学</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从头到尾彻底理解KMP]]></title>
    <url>%2F2015%2F12%2F22%2F%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3KMP%2F</url>
    <content type="text"><![CDATA[转载文章]]></content>
      <categories>
        <category>信息学</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>link</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用七牛云存储作个人博客图床]]></title>
    <url>%2F2015%2F12%2F21%2F%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8%E4%BD%9C%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[转载文章]]></content>
      <categories>
        <category>互联网</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>link</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github资源整理]]></title>
    <url>%2F2015%2F12%2F21%2FGithub%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[转载文章]]></content>
      <categories>
        <category>互联网</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Road]]></title>
    <url>%2F2015%2F12%2F20%2FRoad%2F</url>
    <content type="text"><![CDATA[Description给你一棵有N个结点的数。这N个结点都有一个权值为$C[i]$。询问你两个结点u、v，在这两个结点的最短路径上，选取两个点i、j，且i靠近结点u，j靠近结点v。让你计算$Max(c[j]-c[i],0)$ Input输入第一行有一个整数N(1≤n≤50000)接下来有N 行，每行一个整数Ci(1≤Ci≤50000)再接下来有N-1 行，每行两个整数x,y(1≤x,y≤50000)，表示x 和y 之间有一条边。接下来有一个整数M，表示有M 个询问。然后M 行，每行两个整数，x,y(1≤x,y≤50000)询问$Max(c[j]-c[i],0)$ Output对于每次询问,输出对应最大值结果 Sample Input1234567891011124 1 2 341 21 42 331 33 11 4 Sample Output123203 Data Constraint对于30%的数据, 1≤N,M≤100对于60%的数据，1≤N,M≤1000对于100%的数据，1≤N,M≤50000 Analysis因为是一棵树，所以任意两点的最短路径是唯一的。1°30% ＆＆ 60％的数据 对于每一个询问我们可以O(N)的扫一遍整副图，直到找到终点v。并记录下此时经过路径的结点。然后在O(3*N)的扫一遍得到从结点u到结点i的最小值$(\sum_{i=u}^v A[i] = Min(C[i]))$，以及从结点i到结点v的最大值$(\sum_{i=v}^u B[i] = Max(C[i]))$，最后只需要每一个结点对应扫一遍就行了计算最大值即可。$(\sum_{i=u}^v Ans = Max(B[i]-A[i]))$。这样做的时间复杂度就是$O（MN）$。 还有一种是这种算法的改进。就是充分利用树的特点，先dfs预处理一遍所有结点到根节点的深度，在一步步向上跳。直到调到他们的LCA。后续的答案计算和前面一样。时间复杂度虽然也是$O（MN）$，可是当数据是随机生成的时候很有可能会优化到$O(2Mlog(N))$。 详情请见代码1…… 2°100％的数据这种涉及到路径的问题肯定会与LCA有关，LCA最快的在线做法就是倍增。但是倍增在计算是需要合并两个块，所以我们可以考虑一下，怎样合并两个块。对于一个块就是一个有顺序的结点集合，它需要存放四个值，即： 块中所有结点的最小值 (buy) 块中所有结点的最大值 (sell) 先最小值后最大值的差的绝对值的最大值(Max(bs)) 先最大值后最小值的差的绝对值的最大值(Min(sb)) 我们发现当维护了这四个值后我们就可以进行块合并操作了。假设要合并的块分别为A和B，合并后的块为C。 $C.buy = Min(A.buy,B.buy)$ $C.sell = Max(A.sell,B.sell)$ $C.bs = Max(A.bs,B.bs,B.sell-A.buy)$ $C.sb = Max(A.sb,B.sb,A.sell-B.buy)$ 然后倍增的到LCA后我们只需要知道$\sum_{i=u}^{LCA}$的块与$\sum_{i=v}^{LCA}$的块合并后即可知道答案。同理我们也可以用tarjan离线LCA的方法来解决这个问题，这样时间复杂度就是$O（N）$。详情请见代码2…… 下面说一下具体的程序实现的小问题对于离线的tarjan算法，因为用到了并查集，所以我们可以对每一个节点，维护它向上的块，维护的大小取决于当前并查集的大小，这样就能完成从$\sum_{i=u}^{LCA}$的块维护，对于另一边我们可以在(u,v)的LCA上打一个标记，当tarjan遍历回到了LCA后。在进行合并。可以对照这篇博客中的图看一看：http://blog.csdn.net/hnust_xiehonghao/article/details/9109295 Code代码1： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899uses math;const maxn=50002;type node=record y,next:longint; end;var i,j,k,m,n,tot,x,y,ans:longint; v,e,dep,fa:array[1..maxn] of longint; h:array[1..2*maxn] of node; a,a1,a2,b,c:array[0..maxn] of longint; flag:array[1..maxn] of boolean;procedure add(x,y:longint);begin inc(tot); h[tot].y:=y; h[tot].next:=e[x]; e[x]:=tot;end;procedure dfs(x:longint);var i:longint;begin if flag[x] then exit; flag[x]:=true; i:=e[x]; while i&lt;&gt;0 do begin if flag[h[i].y] then begin i:=h[i].next; continue; end; dep[h[i].y]:=dep[x]+1; fa[h[i].y]:=x; dfs(h[i].y); i:=h[i].next; end;end;procedure up(var x:longint;y:longint);begin if odd(y) then begin inc(a1[0]); a1[a1[0]]:=x; end else begin inc(a2[0]); a2[a2[0]]:=x; end; x:=fa[x];end;procedure link;var i:longint;begin for i:=1 to a1[0] do a[i]:=a1[i]; a[0]:=a1[0]; for i:=a2[0] downto 1 do begin inc(a[0]); a[a[0]]:=a2[i]; end;end;procedure work(x,y:longint);var i:longint;begin a1[0]:=0;a2[0]:=0;ans:=0; while dep[x]&gt;dep[y] do up(x,1); while dep[x]&lt;dep[y] do up(y,2); while x&lt;&gt;y do begin up(x,1);up(y,2); end; inc(a1[0]); a1[a1[0]]:=x; link; b[0]:=1000000007;c[a[0]+1]:=0; for i:=1 to a[0] do b[i]:=min(b[i-1],v[a[i]]); for i:=a[0] downto 1 do c[i]:=max(c[i+1],v[a[i]]); for i:=1 to a[0] do ans:=max(ans,c[i]-b[i]); &#123; for i:=1 to a[0] do begin for j:=i+1 to a[0] do begin ans:=max(ans,v[a[j]]-v[a[i]]); end; end; &#125;end;begin //assign(input,'1230.in');reset(input); //assign(output,'1230.out');rewrite(output); readln(n); for i:=1 to n do read(v[i]); for i:=1 to n-1 do begin readln(x,y); add(x,y); add(y,x); end; dep[1]:=1;fa[1]:=0; dfs(1); readln(m); for i:=1 to m do begin readln(x,y); work(x,y); writeln(ans); end;end. 代码2： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;const int N = 50000+5,M = N*3;struct node&#123; int fa,buy,sell,bs,sb; node (int A=0,int B=0,int C=0,int D=0,int E=0) &#123; fa = A,buy = B,sell = C,bs = D,sb = E; &#125;&#125; f[N];struct Edge&#123; int y,next;&#125; h[3][M];int e[3][N],tot[3],b[N][2],ans[N],a[N];int n,m;bool vis[N];void add(int x,int y,int kind)&#123; h[kind][++ tot[kind]].y = y; h[kind][tot[kind]].next = e[kind][x]; e[kind][x] = tot[kind];&#125;node gf(int x)&#123; node t; if (f[x].fa != x) &#123; t = gf(f[x].fa); f[x] = node(t.fa,min(f[x].buy,t.buy),max(f[x].sell,t.sell),max(t.sell-f[x].buy,max(f[x].bs,t.bs)),max(f[x].sell-t.buy,max(f[x].sb,t.sb))); &#125; return f[x];&#125;void tarjan(int x,int fa)&#123; vis[x] = 1; for (int i=e[0][x];i;i=h[0][i].next) &#123; int y = h[0][i].y; if (y==fa) continue; tarjan(y,x); f[y].fa = x; &#125; for (int i=e[1][x];i;i=h[1][i].next) &#123; int j = h[1][i].y,y = b[j][b[j][0] == x];//Υµ½Αν»µγ if (!vis[y]) continue; if (gf(y).fa != x) add(f[y].fa,j,2); &#125; for (int i=e[2][x];i;i = h[2][i].next) &#123; int j=h[2][i].y,x=b[j][0],y=b[j][1]; gf(x),gf(y); ans[j] = max(ans[j],f[x].bs); ans[j] = max(ans[j],f[y].sb); ans[j] = max(ans[j],f[y].sell-f[x].buy); &#125;&#125;int main()&#123; //freopen("1230.in","r",stdin); //freopen("1230.out","w",stdout); scanf("%d",&amp;n); for (int i=1;i&lt;=n;i ++) &#123; scanf("%d",&amp;a[i]); f[i] = node(i,a[i],a[i],0,0); &#125; for (int i=1;i&lt;n;i ++) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); add(x,y,0),add(y,x,0); &#125; scanf("%d",&amp;m); for (int i=1;i&lt;=m;i ++) &#123; scanf("%d%d",&amp;b[i][0],&amp;b[i][1]); add(b[i][0],i,1);add(b[i][1],i,1); &#125; tarjan(1,0); for (int i=1;i&lt;=m;i ++) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-简明指南]]></title>
    <url>%2F2015%2F12%2F20%2FGit-%E7%AE%80%E6%98%8E%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[转载文章]]></content>
      <categories>
        <category>互联网</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2015%2F12%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git教程]]></title>
    <url>%2F2015%2F12%2F12%2FGit%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[关于本教程 史上最浅显易懂的Git教程！为什么要编写这个教程？因为我在学习Git的过程中，买过书，也在网上Google了一堆Git相关的文章和教程，但令人失望的是，这些教程不是难得令人发指，就是简单得一笔带过，或者，只支离破碎地介绍Git的某几个命令，还有直接从Git手册粘贴帮助文档的，总之，初学者很难找到一个由浅入深，学完后能立刻上手的Git教程。 既然号称史上最浅显易懂的Git教程，那这个教程有什么让你怦然心动的特点呢？ 首先，本教程绝对面向初学者，没有接触过版本控制概念的读者也可以轻松入门，不必担心起步难度； 其次，本教程实用性超强，边学边练，一点也不觉得枯燥。而且，你所学的Git命令是“充分且必要”的，掌握了这些东西，你就可以通过Git轻松地完成你的工作。 文字+图片还看不明白？有视频！！！本教程只会让你成为Git用户，不会让你成为Git专家。很多Git命令只有那些专家才明白（事实上我也不明白，因为我不是Git专家），但我保证这些命令可能你一辈子都不会用到。既然Git是一个工具，就没必要把时间浪费在那些“高级”但几乎永远不会用到的命令上。一旦你真的非用不可了，到时候再自行Google或者请教专家也未迟。 如果你是一个开发人员，想用上这个世界上目前最先进的分布式版本控制系统，那么，赶快开始学习吧！ 关于作者廖雪峰，十年软件开发经验，业余产品经理，精通Java/Python/Ruby/Visual Basic/Objective C等，对开源框架有深入研究，著有《Spring 2.0核心技术与最佳实践》一书，多个业余开源项目托管在GitHub，欢迎微博交流： Git简介Git是什么？ Git是目前世界上最先进的分布式版本控制系统（没有之一）。 Git有什么特点？简单来说就是：高端大气上档次！ 那什么是版本控制系统？ 如果你用Microsoft Word写过长篇大论，那你一定有这样的经历： 想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样： 过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。 看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。 更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。 于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？ 这个软件用起来就应该像这个样子，能记录每次文件的改动： 版本用户说明日期1张三删除了软件服务条款57/12 10:382张三增加了License人数限制7/12 18:093李四财务部门调整了合同金额7/13 9:514张三延长了免费升级周期7/14 15:17 这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。 Git的诞生很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。 Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？ 事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！ 你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。 不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。 Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的： Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。 Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 集中式vs分布式Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？ 先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。 那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。 CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。 除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。 微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。 分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！ 安装Git最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。 要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字： 在Linux上安装Git首先，你可以试着输入git，看看系统有没有安装Git： $ git The program &apos;git&apos; is currently not installed. You can install it by typing: sudo apt-get install git 像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。 如果你碰巧用Debian或Ubuntu Linux，通过一条“sudo apt-get install git”就可以直接完成Git的安装，非常简单。 老一点的Debian或Ubuntu Linux，要把命令改为“sudo apt-get install git-core”，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。 如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。 在Mac OS X上安装Git如果你正在使用Mac做开发，有两种安装Git的方法。 一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。 第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！ 在Windows上安装Git实话实说，Windows是最烂的开发平台，如果不是开发Windows游戏或者在IE里调试页面，一般不推荐用Windows。不过，既然已经上了微软的贼船，也是有办法安装Git的。 Windows下要使用很多Linux/Unix的工具时，需要Cygwin这样的模拟环境，Git也一样。Cygwin的安装和配置都比较复杂，就不建议你折腾了。不过，有高人已经把模拟环境和Git都打包好了，名叫msysgit，只需要下载一个单独的exe安装程序，其他什么也不用装，绝对好用。 msysgit是Windows版的Git，从http://msysgit.github.io/下载，然后按默认选项安装即可。 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 安装完成后，还需要最后一步设置，在命令行输入： $ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。 注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 创建版本库什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录： $ mkdir learngit $ cd learngit $ pwd /Users/michael/learngit pwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。 如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。 第二步，通过git init命令把这个目录变成Git可以管理的仓库： $ git init Initialized empty Git repository in /Users/michael/learngit/.git/ 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。 把文件添加到版本库首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。 因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。 使用Windows的童鞋要特别注意，千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Notepad++代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可： 言归正传，现在我们编写一个readme.txt文件，内容如下： Git is a version control system. Git is free software. 一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。 第一步，用命令git add告诉Git，把文件添加到仓库： $ git add readme.txt 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 第二步，用命令git commit告诉Git，把文件提交到仓库： $ git commit -m &quot;wrote a readme file&quot; [master (root-commit) cb926e7] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 嫌麻烦不想输入-m “xxx”行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。 git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： $ git add file1.txt $ git add file2.txt $ git add file3.txt $ git commit -m &quot;add 3 files.&quot; 小结 现在总结一下今天学的两点内容： 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 第一步，使用命令git add ，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。 时光机穿梭我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容： Git is a distributed version control system. Git is free software. 现在，运行git status命令看看结果： $ git status # On branch master # Changes not staged for commit: # (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) # (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) # # modified: readme.txt # no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) git status命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看： $ git diff readme.txt diff --git a/readme.txt b/readme.txt index 46d49bf..9247db6 100644 --- a/readme.txt +++ b/readme.txt @@ -1,2 +1,2 @@ -Git is a version control system. +Git is a distributed version control system. Git is free software. git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。 知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add： $ git add readme.txt 同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态： $ git status # On branch master # Changes to be committed: # (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) # # modified: readme.txt # git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了： $ git commit -m &quot;add distributed&quot; [master ea34578] add distributed 1 file changed, 1 insertion(+), 1 deletion(-) 提交后，我们再用git status命令看看仓库的当前状态： $ git status # On branch master nothing to commit (working directory clean) Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working directory clean）的。 小结 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 版本回退现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下： Git is a distributed version control system. Git is free software distributed under the GPL. 然后尝试提交： $ git add readme.txt $ git commit -m &quot;append GPL&quot; [master 3628164] append GPL 1 file changed, 1 insertion(+), 1 deletion(-) 像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。 现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了： 版本1：wrote a readme file Git is a version control system. Git is free software. 版本2：add distributed Git is a distributed version control system. Git is free software. 版本3：append GPL Git is a distributed version control system. Git is free software distributed under the GPL. 当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看： $ git log commit 3628164fb26d48395383f8f31179f24e0882e1e0 Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Tue Aug 20 15:11:49 2013 +0800 append GPL commit ea34578d5496d7dd233c827ed32a8cd576c5ee85 Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Tue Aug 20 14:53:12 2013 +0800 add distributed commit cb926e7ea50ad11b8f9e909c05226233bf755030 Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Mon Aug 19 17:51:55 2013 +0800 wrote a readme file git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是“append GPL”，上一次是“add distributed”，最早的一次是“wrote a readme file”。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数： $ git log --pretty=oneline 3628164fb26d48395383f8f31179f24e0882e1e0 append GPL ea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributed cb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file 需要友情提示的是，你看到的一大串类似“ 3628164…882e1e0”的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线： 好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是“add distributed”的那个版本，怎么做呢？ 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交“ 3628164…882e1e0”（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本“append GPL”回退到上一个版本“add distributed”，就可以使用git reset命令： $ git reset --hard HEAD^ HEAD is now at ea34578 add distributed –hard参数有啥意义？这个后面再讲，现在你先放心使用。 看看readme.txt的内容是不是版本“add distributed”： $ cat readme.txt Git is a distributed version control system. Git is free software. 果然。 还可以继续回退到上一个版本“wrote a readme file”，不过且慢，然我们用git log再看看现在版本库的状态： $ git log commit ea34578d5496d7dd233c827ed32a8cd576c5ee85 Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Tue Aug 20 14:53:12 2013 +0800 add distributed commit cb926e7ea50ad11b8f9e909c05226233bf755030 Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Mon Aug 19 17:51:55 2013 +0800 wrote a readme file 最新的那个版本“append GPL”已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？ 办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个“append GPL”的commit id是“3628164…”，于是就可以指定回到未来的某个版本： $ git reset --hard 3628164 HEAD is now at 3628164 append GPL 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 再小心翼翼地看看readme.txt的内容： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. 果然，我胡汉山又回来了。 Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向“append GPL”： 改为指向“add distributed”： 然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ 在Git中，总是有后悔药可以吃的。当你用$ git reset –hard HEAD^回退到“add distributed”版本时，再想恢复到“append GPL”，就必须找到“append GPL”的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： $ git reflog ea34578 HEAD@{0}: reset: moving to HEAD^ 3628164 HEAD@{1}: commit: append GPL ea34578 HEAD@{2}: commit: add distributed cb926e7 HEAD@{3}: commit (initial): wrote a readme file 终于舒了口气，第二行显示“append GPL”的commit id是3628164，现在，你又可以乘坐时光机回到未来了。 小结 现在总结一下： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 工作区和暂存区Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 先来看名词解释。 工作区（Working Directory）：就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区： 版本库（Repository）：工作区有一个隐藏目录“.git”，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 分支和HEAD的概念我们以后再讲。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用“git add”把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用“git commit”提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容： Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. 然后，在工作区新增一个LICENSE文本文件（内容随便写）。 先用git status查看一下状态： $ git status # On branch master # Changes not staged for commit: # (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) # (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) # # modified: readme.txt # # Untracked files: # (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) # # LICENSE no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。 现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下： $ git status # On branch master # Changes to be committed: # (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) # # new file: LICENSE # modified: readme.txt # 现在，暂存区的状态就变成这样了： 所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 $ git commit -m &quot;understand how stage works&quot; [master 27c9860] understand how stage works 2 files changed, 675 insertions(+) create mode 100644 LICENSE 一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的： $ git status # On branch master nothing to commit (working directory clean) 现在版本库变成了这样，暂存区就没有任何内容了： 小结 暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。 没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。 管理修改现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。 你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。 为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes. 然后，添加： $ git add readme.txt $ git status # On branch master # Changes to be committed: # (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) # # modified: readme.txt # 然后，再修改readme.txt： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. 提交： $ git commit -m &quot;git tracks changes&quot; [master d4f25b6] git tracks changes 1 file changed, 1 insertion(+) 提交后，再看看状态： $ git status # On branch master # Changes not staged for commit: # (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) # (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) # # modified: readme.txt # no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 咦，怎么第二次的修改没有被提交？ 别激动，我们回顾一下操作过程： 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit 你看，我们前面讲了，Git管理的是修改，当你用“git add”命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，“git commit”只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 提交后，用“git diff HEAD – readme.txt”命令可以查看工作区和版本库里面最新版本的区别： $ git diff HEAD -- readme.txt diff --git a/readme.txt b/readme.txt index 76d770f..a9c5755 100644 --- a/readme.txt +++ b/readme.txt @@ -1,4 +1,4 @@ Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. -Git tracks changes. +Git tracks changes of files. 可见，第二次修改确实没有被提交。 那怎么提交第二次修改呢？你可以继续add再commit，也可以别着急提交第一次修改，先add第二次修改，再commit，就相当于把两次修改合并后一块提交了： 第一次修改 -&gt; add -&gt; 第二次修改 -&gt; add -&gt; commit 好，现在，把第二次修改提交了，然后开始小结。 小结 现在，你又理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。 撤销修改自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. My stupid boss still prefers SVN. 在你准备提交前，一杯咖啡起了作用，你猛然发现了“stupid boss”可能会让你丢掉这个月的奖金！ 既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下： $ git status # On branch master # Changes not staged for commit: # (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) # (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) # # modified: readme.txt # no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 你可以发现，Git会告诉你，git checkout – file可以丢弃工作区的修改： $ git checkout -- readme.txt 命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 现在，看看readme.txt的文件内容： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. 文件内容果然复原了。 git checkout – file命令中的“–”很重要，没有“–”，就变成了“创建一个新分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。 现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. My stupid boss still prefers SVN. $ git add readme.txt 庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交： $ git status # On branch master # Changes to be committed: # (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) # # modified: readme.txt # Git同样告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区： $ git reset HEAD readme.txt Unstaged changes after reset: M readme.txt git reset命令既可以回退版本，也可以把工作区的某些文件替换为版本库中的文件。当我们用HEAD时，表示最新的版本。 再用git status查看一下，现在暂存区是干净的，工作区有修改： $ git status # On branch master # Changes not staged for commit: # (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) # (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) # # modified: readme.txt # no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 还记得如何丢弃工作区的修改吗？ $ git checkout -- readme.txt $ git status # On branch master nothing to commit (working directory clean) 整个世界终于清静了！ 现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了…… 小结 又到了小结时间。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 删除文件在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交： $ git add test.txt $ git commit -m &quot;add test.txt&quot; [master 94cdc44] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了： $ rm test.txt 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了： $ git status # On branch master # Changes not staged for commit: # (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) # (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) # # deleted: test.txt # no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且commit： $ git rm test.txt rm &apos;test.txt&apos; $ git commit -m &quot;remove test.txt&quot; [master d17efd8] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 现在，文件就从版本库中被删除了。 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： $ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 小结 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 远程仓库到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。 可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。 没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：远程仓库。 Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。 你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？ 其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。 实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。 完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。 在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： $ ssh-keygen -t rsa -C &quot;your\_email@example.com&quot; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： 点“Add Key”，你就应该看到已经添加的Key： 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。 确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。 小结 “有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机 添加远程库现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库： 在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： $ git remote add origin git@github.com:michaelliao/learngit.git 请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上： $ git push -u origin master Counting objects: 19, done. Delta compression using up to 4 threads. Compressing objects: 100% (19/19), done. Writing objects: 100% (19/19), 13.73 KiB, done. Total 23 (delta 6), reused 0 (delta 0) To git@github.com:michaelliao/learngit.git * [new branch] master -&gt; master Branch master set up to track remote branch master from origin. 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以通过命令： $ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ 小结 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ 从远程库克隆上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。 现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。 首先，登陆GitHub，创建一个新的仓库，名字叫gitskills： 我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件： 现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库： $ git clone git@github.com:michaelliao/gitskills.git Cloning into &apos;gitskills&apos;... remote: Counting objects: 3, done. remote: Total 3 (delta 0), reused 0 (delta 0) Receiving objects: 100% (3/3), done. $ cd gitskills $ ls README.md 注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。 你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。 使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 小结 要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。 Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 分支管理分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。问题是，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！ 分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。 但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。 创建与合并分支在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长： 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 真是太神奇了，你看得出来有些提交是通过分支完成的吗？ 下面开始实战。 首先，我们创建dev分支，然后切换到dev分支： $ git checkout -b dev Switched to a new branch &apos;dev&apos; git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： $ git branch dev $ git checkout dev Switched to branch &apos;dev&apos; 然后，用git branch命令查看当前分支： $ git branch * dev master git branch命令会列出所有分支，当前分支前面会标一个*号。 然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行： Creating a new branch is quick. 然后提交： $ git add readme.txt $ git commit -m &quot;branch test&quot; [dev fec145a] branch test 1 file changed, 1 insertion(+) 现在，dev分支的工作完成，我们就可以切换回master分支： $ git checkout master Switched to branch &apos;master&apos; 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变： 现在，我们把dev分支的工作成果合并到master分支上： $ git merge dev Updating d17efd8..fec145a Fast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 当然，也不是每次合并都能Fast-forward，我们后面会将其他方式的合并。 合并完成后，就可以放心地删除dev分支了： $ git branch -d dev Deleted branch dev (was fec145a). 删除后，查看branch，就只剩下master分支了： $ git branch * master 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。 小结 Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch name 切换分支：git checkout name 创建+切换分支：git checkout -b name 合并某分支到当前分支：git merge name 删除分支：git branch -d name 解决冲突人生不如意之事十之八九，合并分支往往也不是一帆风顺的。 准备新的feature1分支，继续我们的新分支开发： $ git checkout -b feature1 Switched to a new branch &apos;feature1&apos; 修改readme.txt最后一行，改为： Creating a new branch is quick AND simple. 在feature1分支上提交： $ git add readme.txt $ git commit -m &quot;AND simple&quot; [feature1 75a857c] AND simple 1 file changed, 1 insertion(+), 1 deletion(-) 切换到master分支： $ git checkout master Switched to branch &apos;master&apos; Your branch is ahead of &apos;origin/master&apos; by 1 commit. Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。 在master分支上把readme.txt文件的最后一行改为： Creating a new branch is quick &amp; simple. 提交： $ git add readme.txt $ git commit -m &quot;&amp; simple&quot; [master 400b400] &amp; simple 1 file changed, 1 insertion(+), 1 deletion(-) 现在，master分支和feature1分支各自都分别有新的提交，变成了这样： 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看： $ git merge feature1 Auto-merging readme.txt CONFLICT (content): Merge conflict in readme.txt Automatic merge failed; fix conflicts and then commit the result. 果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件： $ git status # On branch master # Your branch is ahead of &apos;origin/master&apos; by 2 commits. # # Unmerged paths: # (use &quot;git add/rm &lt;file&gt;...&quot; as appropriate to mark resolution) # # both modified: readme.txt # no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 我们可以直接查看readme.txt的内容： Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD Creating a new branch is quick &amp; simple. ======= Creating a new branch is quick AND simple. &gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存： Creating a new branch is quick and simple. 再提交： $ git add readme.txt $ git commit -m &quot;conflict fixed&quot; [master 59bc1cb] conflict fixed 现在，master分支和feature1分支变成了下图所示： 用带参数的git log也可以看到分支的合并情况： $ git log --graph --pretty=oneline --abbrev-commit * 59bc1cb conflict fixed |\ | * 75a857c AND simple * | 400b400 &amp; simple |/ * fec145a branch test ... 现在，删除feature1分支： $ git branch -d feature1 Deleted branch feature1 (was 75a857c). 工作完成。 小结 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 用git log –graph命令可以看到分支合并图。 分支管理策略通常，合并分支时，如果可能，Git会用“Fast forward”模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用“Fast forward”模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 下面我们实战一下–no-ff方式的merge： 首先，仍然创建并切换dev分支： $ git checkout -b dev Switched to a new branch &apos;dev&apos; 修改readme.txt文件，并提交一个新的commit： $ git add readme.txt $ git commit -m &quot;add merge&quot; [dev 6224937] add merge 1 file changed, 1 insertion(+) 现在，我们切换会master： $ git checkout master Switched to branch &apos;master&apos; 准备合并dev分支，请注意–no-ff参数，表示禁用“Fast forward”： $ git merge --no-ff -m &quot;merge with no-ff&quot; dev Merge made by the &apos;recursive&apos; strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log看看分支历史： $ git log --graph --pretty=oneline --abbrev-commit * 7825a50 merge with no-ff |\ | * 6224937 add merge |/ * 59bc1cb conflict fixed ... 可以看到，不使用“Fast forward”模式，merge后就像这样： 分支策略在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 小结 Git分支十分强大，在团队开发中应该充分应用。 合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 Bug分支软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue -101来修复它，但是，等等，当前正在dev上进行的工作还没有提交： $ git status # On branch dev # Changes to be committed: # (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) # # new file: hello.py # # Changes not staged for commit: # (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) # (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) # # modified: readme.txt # 并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？ 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： $ git stash Saved working directory and index state WIP on dev: 6224937 add merge HEAD is now at 6224937 add merge 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支： $ git checkout master Switched to branch &apos;master&apos; Your branch is ahead of &apos;origin/master&apos; by 6 commits. $ git checkout -b issue-101 Switched to a new branch &apos;issue-101&apos; 现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交： $ git add readme.txt $ git commit -m &quot;fix bug 101&quot; [issue-101 cc17032] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-) 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支： $ git checkout master Switched to branch &apos;master&apos; Your branch is ahead of &apos;origin/master&apos; by 2 commits. $ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101 Merge made by the &apos;recursive&apos; strategy. readme.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) $ git branch -d issue-101 Deleted branch issue-101 (was cc17032). 太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！ $ git checkout dev Switched to branch &apos;dev&apos; $ git status # On branch dev nothing to commit (working directory clean) 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看： $ git stash list stash@{0}: WIP on dev: 6224937 add merge 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了： $ git stash pop # On branch dev # Changes to be committed: # (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) # # new file: hello.py # # Changes not staged for commit: # (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) # (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) # # modified: readme.txt # Dropped refs/stash@{0} (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40) 再用git stash list查看，就看不到任何stash内容了： $ git stash list 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令： $ git stash apply stash@{0} 小结 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 Feature分支软件开发中，总有无穷无尽的新的功能要不断添加进来。 添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。 于是准备开发： $ git checkout -b feature-vulcan Switched to a new branch &apos;feature-vulcan&apos; 5分钟后，开发完毕： $ git status # On branch feature-vulcan # Changes to be committed: # (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) # # new file: vulcan.py # $ git commit -m &quot;add feature vulcan&quot; [feature-vulcan 756d4af] add feature vulcan 1 file changed, 2 insertions(+) create mode 100644 vulcan.py 切回dev，准备合并： $ git checkout dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。 但是， 就在此时，接到上级命令，因经费不足，新功能必须取消！ 虽然白干了，但是这个分支还是必须就地销毁： $ git branch -d feature-vulcan error: The branch &apos;feature-vulcan&apos; is not fully merged. If you are sure you want to delete it, run &apos;git branch -D feature-vulcan&apos;. 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature-vulcan。 现在我们强行删除： $ git branch -D feature-vulcan Deleted branch feature-vulcan (was 756d4af). 终于删除成功！ 小结 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D name强行删除。 多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote： $ git remote origin 或者，用git remote -v显示更详细的信息： $ git remote -v origin git@github.com:michaelliao/learngit.git (fetch) origin git@github.com:michaelliao/learngit.git (push) 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： $ git push origin master 如果要推送其他分支，比如dev，就改成： $ git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： $ git clone git@github.com:michaelliao/learngit.git Cloning into &apos;learngit&apos;... remote: Counting objects: 46, done. remote: Compressing objects: 100% (26/26), done. remote: Total 46 (delta 16), reused 45 (delta 15) Receiving objects: 100% (46/46), 15.69 KiB | 6 KiB/s, done. Resolving deltas: 100% (16/16), done. 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： $ git branch * master 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： $ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程： $ git commit -m &quot;add /usr/bin/env&quot; [dev 291bea8] add /usr/bin/env 1 file changed, 1 insertion(+) $ git push origin dev Counting objects: 5, done. Delta compression using up to 4 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 349 bytes, done. Total 3 (delta 0), reused 0 (delta 0) To git@github.com:michaelliao/learngit.git fc38031..291bea8 dev -&gt; dev 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： $ git add hello.py $ git commit -m &quot;add coding: utf-8&quot; [dev bd6ae48] add coding: utf-8 1 file changed, 1 insertion(+) $ git push origin dev To git@github.com:michaelliao/learngit.git ! [rejected] dev -&gt; dev (non-fast-forward) error: failed to push some refs to &apos;git@github.com:michaelliao/learngit.git&apos; hint: Updates were rejected because the tip of your current branch is behind hint: its remote counterpart. Merge the remote changes (e.g. &apos;git pull&apos;) hint: before pushing again. hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送： $ git pull remote: Counting objects: 5, done. remote: Compressing objects: 100% (2/2), done. remote: Total 3 (delta 0), reused 3 (delta 0) Unpacking objects: 100% (3/3), done. From github.com:michaelliao/learngit fc38031..291bea8 dev -&gt; origin/dev There is no tracking information for the current branch. Please specify which branch you want to merge with. See git-pull(1) for details git pull &lt;remote&gt; &lt;branch&gt; If you wish to set tracking information for this branch you can do so with: git branch --set-upstream dev origin/&lt;branch&gt; git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： $ git branch --set-upstream dev origin/dev Branch dev set up to track remote branch dev from origin. 再pull： $ git pull Auto-merging hello.py CONFLICT (content): Merge conflict in hello.py Automatic merge failed; fix conflicts and then commit the result. 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push： $ git commit -m &quot;merge &amp; fix hello.py&quot; [dev adca45d] merge &amp; fix hello.py $ git push origin dev Counting objects: 10, done. Delta compression using up to 4 threads. Compressing objects: 100% (5/5), done. Writing objects: 100% (6/6), 747 bytes, done. Total 6 (delta 0), reused 0 (delta 0) To git@github.com:michaelliao/learngit.git 291bea8..adca45d dev -&gt; dev 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 #标签管理 发布一个版本时，我们通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。 创建标签在Git中打标签非常简单，首先，切换到需要打标签的分支上： $ git branch * dev master $ git checkout master Switched to branch &apos;master&apos; 然后，敲命令git tag name就可以打一个新标签： $ git tag v1.0 可以用命令git tag查看所有标签： $ git tag v1.0 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了： $ git log --pretty=oneline --abbrev-commit 6a5819e merged bug fix 101 cc17032 fix bug 101 7825a50 merge with no-ff 6224937 add merge 59bc1cb conflict fixed 400b400 &amp; simple 75a857c AND simple fec145a branch test d17efd8 remove test.txt ... 比方说要对“add merge”这次提交打标签，它对应的commit id是“6224937”，敲入命令： $ git tag v0.9 6224937 再用命令git tag查看标签： $ git tag v0.9 v1.0 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show tagname查看标签信息： $ git show v0.9 commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4 Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Thu Aug 22 11:22:08 2013 +0800 add merge ... 可以看到，“v0.9”确实打在“add merge”这次提交上。 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： $ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164 用命令git show tagname可以看到说明文字： $ git show v0.1 tag v0.1 Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Mon Aug 26 07:28:11 2013 +0800 version 0.1 released commit 3628164fb26d48395383f8f31179f24e0882e1e0 Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Tue Aug 20 15:11:49 2013 +0800 append GPL ... 还可以通过-s用私钥签名一个标签： $ git tag -s v0.2 -m &quot;signed version 0.2 released&quot; fec145a 签名采用PGP签名，因此，必须首先安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错： gpg: signing failed: secret key not available error: gpg failed to sign the data error: unable to sign the tag 如果报错，请参考GnuPG帮助文档配置Key。 用命令git show tagname可以看到PGP签名信息： $ git show v0.2 tag v0.2 Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Mon Aug 26 07:28:33 2013 +0800 signed version 0.2 released -----BEGIN PGP SIGNATURE----- Version: GnuPG v1.4.12 (Darwin) iQEcBAABAgAGBQJSGpMhAAoJEPUxHyDAhBpT4QQIAKeHfR3bo... -----END PGP SIGNATURE----- commit fec145accd63cdc9ed95a2f557ea0658a2a6537f Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Thu Aug 22 10:37:30 2013 +0800 branch test ... 用PGP签名的标签是不可伪造的，因为可以验证PGP签名。验证签名的方法比较复杂，这里就不介绍了。 小结 命令git tag name用于新建一个标签，默认为HEAD，也可以指定一个commit id； -a tagname -m “blablabla…”可以指定标签信息； -s tagname -m “blablabla…”可以用PGP签名标签； 命令git tag可以查看所有标签； 操作标签如果标签打错了，也可以删除： $ git tag -d v0.1 Deleted tag &apos;v0.1&apos; (was e078af9) 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin tagname： $ git push origin v1.0 Total 0 (delta 0), reused 0 (delta 0) To git@github.com:michaelliao/learngit.git * [new tag] v1.0 -&gt; v1.0 或者，一次性推送全部尚未推送到远程的本地标签： $ git push origin --tags Counting objects: 1, done. Writing objects: 100% (1/1), 554 bytes, done. Total 1 (delta 0), reused 0 (delta 0) To git@github.com:michaelliao/learngit.git * [new tag] v0.2 -&gt; v0.2 * [new tag] v0.9 -&gt; v0.9 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： $ git tag -d v0.9 Deleted tag &apos;v0.9&apos; (was 6224937) 然后，从远程删除。删除命令也是push，但是格式如下： $ git push origin :refs/tags/v0.9 To git@github.com:michaelliao/learngit.git - [deleted] v0.9 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。 小结 命令git push origin tagname可以推送一个本地标签； 命令git push origin –tags可以推送全部未推送过的本地标签； 命令git tag -d tagname可以删除一个本地标签； 命令git push origin :refs/tags/tagname可以删除一个远程标签。 自定义Git在安装Git一节中，我们已经配置了user.name和user.email，实际上，Git还有很多可配置项。 比如，让Git显示颜色，会让命令输出看起来更醒目： $ git config --global color.ui true 这样，Git会适当地显示不同的颜色，比如git status命令： 文件名就会标上颜色。 我们在后面还会介绍如何更好地配置Git，以便让你的工作更高效。 忽略特殊文件有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次git status都会显示“Untracked files …”，有强迫症的童鞋心里肯定不爽。 好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 举个例子： 假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件： # Windows: Thumbs.db ehthumbs.db Desktop.ini 然后，继续忽略Python编译产生的.pyc、.pyo、dist等文件或目录： # Python: *.py[cod] *.so *.egg *.egg-info dist build 加上你自己定义的文件，最终得到一个完整的.gitignore文件，内容如下： # Windows: Thumbs.db ehthumbs.db Desktop.ini # Python: *.py[cod] *.so *.egg *.egg-info dist build # My configurations: db.ini deploy_key_rsa 最后一步就是把.gitignore也提交到Git，就完成了！当然检验.gitignore的标准是git status命令是不是说“working directory clean”。 小结 忽略某些文件时，需要编写.gitignore。 .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！ 配置别名有没有经常敲错命令？比如git status？status这个单词真心不好记。 如果敲git st就表示git status那就简单多了，当然这种偷懒的办法我们是极力赞成的。 我们只需要敲一行命令，告诉Git，以后st就表示status： $ git config --global alias.st status 好了，现在敲git st看看效果。 当然还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch： $ git config --global alias.co checkout $ git config --global alias.ci commit $ git config --global alias.br branch 以后提交就可以简写成： $ git ci -m &quot;bala bala bala...&quot; –global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。 在撤销修改一节中，我们知道，命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名： $ git config --global alias.unstage &apos;reset HEAD&apos; 当你敲入命令： $ git unstage test.py 实际上Git执行的是： $ git reset HEAD test.py 配置一个git last，让其显示最后一次提交信息： $ git config --global alias.last &apos;log -1&apos; 这样，用git last就能显示最近一次的提交： $ git last commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2 Merge: bd6ae48 291bea8 Author: Michael Liao &lt;askxuefeng@gmail.com&gt; Date: Thu Aug 22 22:49:22 2013 +0800 merge &amp; fix hello.py 甚至还有人丧心病狂地把lg配置成了： git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot; 来看看git lg的效果： 为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！ 小结 给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。 搭建Git服务器在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。 GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。 搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。 假设你已经有sudo权限的用户账号，下面，正式开始安装。 第一步，安装git： $ sudo apt-get install git 第二步，创建一个git用户，用来运行git服务： $ sudo adduser git 第三步，创建证书登录： 收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。 第四步，初始化Git仓库： 先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令： $ sudo git init --bare sample.git Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git： $ sudo chown -R git:git sample.git 第五步，禁用shell登录： 出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行： git:x:1001:1001:,,,:/home/git:/bin/bash 改为： git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。 第六步，克隆远程仓库： 现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行： $ git clone git@server:/srv/sample.git Cloning into &apos;sample&apos;... warning: You appear to have cloned an empty repository. 剩下的推送就简单了。 管理公钥如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。 这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。 管理权限有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具。 这里我们也不介绍Gitolite了，不要把有限的生命浪费到权限斗争中。 小结 搭建Git服务器非常简单，通常10分钟即可完成； 要方便管理公钥，用Gitosis； 要像SVN那样变态地控制权限，用Gitolite。 期末总结终于到了期末总结的时刻了！ 经过几天的学习，相信你对Git已经初步掌握。一开始，可能觉得Git上手比较困难，尤其是已经熟悉SVN的童鞋，没关系，多操练几次，就会越用越顺手。 Git虽然极其强大，命令繁多，但常用的就那么十来个，掌握好这十几个常用命令，你已经可以得心应手地使用Git了。 友情附赠国外网友制作的Git Cheat Sheet，建议打印出来备用： Git Cheat Sheet 现在告诉你Git的官方网站：http://git-scm.com，英文自我感觉不错的童鞋，可以经常去官网看看。什么，打不开网站？相信我，我给出的绝对是官网地址，而且，Git官网决没有那么容易宕机，可能是你的人品问题，赶紧面壁思过，好好想想原因。 如果你学了Git后，工作效率大增，有更多的空闲时间健身看电影，那我的教学目标就达到了。为了激励我写出更优秀的教程，你可以考虑赠送我一杯咖啡，至于是喝麦当劳还是星巴克就看你的心情了。有支付宝的童鞋请狠狠地点这里： 请我喝咖啡 谢谢观看！ 转载声明转载链接]]></content>
      <categories>
        <category>互联网</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP]11.21总结]]></title>
    <url>%2F2015%2F11%2F21%2FNOIP-11-21%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[T1:粉刷匠刚一开始看错题目啦!我认为竖着也可以粉刷,然而并不是,这只是每行粉刷。因为每一行都是独立的，所以可以分开一行一行染色，随后染色的数目等于T，对于每一行，只需要看这一行用j次粉刷能粉刷的最大数目是多少就可以了。 T2:迷路在不知道是矩阵乘法时，我是没思路的，当知道是矩阵乘法时只知道边权为1时怎么做。当边权为1时，矩阵乘法一次邻接矩阵，就相当于都走了一步。因为边权很小在$[1,9]$之间,所以可以将一个点拆成9个点,将他们连接起来。做T次矩阵乘法，就能得到答案。 T3:游戏将对应关系建成一幅图，发现整个图是有若干个环组成。答案就是求若干个环的大小相加为N时的$\Sigma(LCM)$。到了这一步就不知道怎么做了。因为这里有一个性质 考虑最小公倍数不为1的情况，这它为m。则m=p1^a1*p2^a2…，而对于一个m，存在一个序列的最小公倍数为m的充要条件是：p1^a1+p2^a2+….&lt;=n。 按照上述条件做一下背包就可以了。$F[i][j]$表示做到第i个质数$\Sigma$为j时$(j&lt;=n)$]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2015提高组复赛]总结]]></title>
    <url>%2F2015%2F11%2F17%2FNOIP2015%E6%8F%90%E9%AB%98%E7%BB%84%E5%A4%8D%E8%B5%9B-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概述考试时太浮躁！不要心急打程序，一定要静下心来仔细思考算法。是否可行（时限能否过）。保证思考算法的时间。对于自己熟练地算法，要相信能想得出来就一定能最快的调出来。根据数据范围，大胆猜测考得是什么算法。有时候直接想暴力是不科学的，暴力有时非常的复杂，还会带乱对整道题的思绪。对一些普通算法的应用还不够了解，看不出一道题考察的是什么算法。平时训练要多一些对算法的思考，能不看题解就不看题解，花多点时间在思考上。 DAY1开考时有点小紧张，看到T1题目很长，就更紧张了！！！T1:仔细读题，纯暴力。打完用了半个小时，又打了一个判断正确性的程序拍了一下，花了1个多小时，耗时较大，拖慢了后面的解题时间。 T2:紧张依旧挥之不去，随手画了个图，发现是找一个最小的环，然后就想到了tarjan缩点。就开打了。到了最后才发现，tarjan会爆栈，然而为时已晚。考试时要及时测试小数据和大数据，不要嫌麻烦而只出随机数据。尽管大部分时候程序可以在随机数据下面表现良好。考试时要冷静下来，仔细思考算法是否存在漏洞。 T3:题目复杂，加之从小到大不会打牌，所以看了很多遍题目。大概了解了出牌方法。发现了花色是没有用的。于是打dfs，但是没有将牌统计到一块打了半天又长又有诸多bug。所以直接被我推倒重来了。感觉dfs特别难打，所以打了一个错误的贪心。 DAY2T1:这道题怎么想都没有想到可以用二分答案的方法去算，一开始想把每一块最短的石头都拿出来，但是部分最优解并不能推出全局最有解。所以打了一个错误的贪心，在贪心的路上越走越远，依然没走到尽头。 T2:想到搜索,算了一下搜索太慢。就冲着50%的数据去了，但是到最后面k==m的情况还是没有想到满足时限的做法。当时只要推一下，很快就能得到dp方程。 T3:打了倍增最短路，计划过30%的数据，确实想不到特别好的算法，暴力非常复杂，打了很长时间，才打完。]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息学程序模板]]></title>
    <url>%2F2015%2F11%2F06%2F%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[tarjan123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int N = 100000+10, M = 1000000+10;int ans[N],e[2][N],rd[N],next[2][M],to[2][M],v[N],h[N];int dfn[N],low[N],col[N],stack[N],sum[N],f[N],tot[2];bool p[N],instack[N];int n,m,k,Index,top,ctot;bool cmp(int x,int y) &#123;return x&gt;y;&#125;void add(int x,int y,int kind)&#123; tot[kind] ++; to[kind][tot[kind]] = y; next[kind][tot[kind]] = e[kind][x]; e[kind][x] = tot[kind];&#125;int gf(int x)&#123; if (x!=h[x]) h[x] = gf(h[x]); return h[x];&#125;void link(int x,int y)&#123; int i=gf(x), j=gf(y); if (i!=j) h[i]=j;&#125;void tarjan(int x,int kind)&#123; dfn[x] = low[x] = ++ Index; instack[x] = 1; stack[++ top] = x; for (int i=e[kind][x];i;i=next[kind][i]) &#123; int y = to[kind][i]; if (col[y]) continue; if (instack[y]) low[x] = min(low[x],dfn[y]); else &#123;tarjan(y,kind);low[x]=min(low[x],low[y]);&#125; &#125; if (dfn[x]==low[x]) &#123; int y; ctot ++; do &#123; y = stack[top --]; instack[y] = 0; sum[ctot] += v[y]; col[y] = ctot; &#125; while (y!=x); &#125;&#125;void work(int x,int kind)&#123; p[x] = 1; f[x] += sum[x]; for (int i=e[kind][x];i;i=next[kind][i]) &#123; int y = to[kind][i]; link(x,y); rd[y] --; f[y] = max(f[y],f[x]); if (rd[y]==0) work(y,kind); &#125;&#125;int main()&#123; freopen("azeroth.in","r",stdin); freopen("azeroth.out","w",stdout); scanf("%d%d",&amp;n,&amp;m); for (int i=1;i&lt;=m;i ++) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); if (u==v) continue; add(u,v,0); &#125; for (int i=1;i&lt;=n;i ++) scanf("%d",&amp;v[i]); scanf("%d",&amp;k); for (int i=1;i&lt;=n;i ++) if (!col[i]) tarjan(i,0); for (int j=1;j&lt;=n;j ++) for (int i=e[0][j];i;i=next[0][i]) &#123; int u = j,v = to[0][i]; if (col[u]!=col[v]) &#123; add(col[u],col[v],1); rd[col[v]] ++; &#125; &#125; //构造新图 for (int i=1;i&lt;=ctot;i ++) h[i] = i; for (int i=1;i&lt;=ctot;i ++) if (rd[i] == 0 &amp;&amp; !p[i]) work(i,1); for (int i=1;i&lt;=ctot;i ++) &#123; ans[gf(i)] = max(ans[gf(i)],f[i]); &#125; sort(ans+1,ans+1+ctot,cmp); for (int i=1;i&lt;=min(k+1,ctot);i ++) ans[0] += ans[i]; printf("%d\n",ans[0]); return 0;&#125; 拓扑排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;const int N = 1000000+5,M = 1000000+5;struct node&#123; int y,next;&#125; h[M];int n,m,tot,l,r;int e[N],list[N],rd[N];void add(int x,int y)&#123; tot ++; h[tot].y = y; h[tot].next = e[x]; e[x] = tot; rd[y] ++;&#125;int main()&#123; freopen("mikado.in","r",stdin); freopen("mikado.out","w",stdout); scanf("%d%d",&amp;n,&amp;m); for (int i=1;i&lt;=m;i ++) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v); &#125; l = 1;r = 0; for (int i=1;i&lt;=n;i ++) if (!rd[i]) list[++ r] = i; while (l&lt;=r) &#123; int now = list[l ++]; for (int i=e[now];i;i=h[i].next) &#123; int y = h[i].y; rd[y] --; if (!rd[y]) list[++ r] = y; &#125; &#125; printf("%d\n",r); return 0;&#125; 最小生成树 &amp;&amp; 并查集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;const int MAXW = 200000+5,MAXL = MAXW,N = 100000+5;const int A[] = &#123;10190,3,5,1,9,2,3&#125;;struct node&#123;int x,y,z,id,next;&#125; W[MAXW],L[MAXL],h[MAXW*2];int n,w,l,tot,tot1;int H[N],ans[2][N],e[N],vis[N],dep[N];int fa[N][20],ma[N][20],id[N][20];bool flag;bool cmp(node A,node B)&#123;return A.z&lt;B.z;&#125;int gf(int x)&#123; if (x==H[x]) return x; else return H[x] = gf(H[x]);&#125;bool link(int x,int y)&#123; int i = gf(x),j = gf(y); if (i==j) return 0; else &#123; H[i] = j; return 1; &#125;&#125;void add(int x,int y,int z,int Id)&#123; tot1 ++; h[tot1].y = y; h[tot1].z = z; h[tot1].next = e[x]; h[tot1].id = Id; e[x] = tot1;&#125;void dfs(int x) //OK&#123; for (int i=e[x];i;i = h[i].next) &#123; int y = h[i].y,z = h[i].z,Id = h[i].id; if (vis[y]) continue; vis[y] = 1; dep[y] = dep[x] + 1; fa[y][0] = x; ma[y][0] = z; id[y][0] = Id; dfs(y); &#125;&#125;void init() //OK&#123; for (int j=1;(1&lt;&lt;j)&lt;=n;j ++) for (int i=1;i&lt;=n;i ++) if (fa[i][j-1]) &#123; fa[i][j] = fa[fa[i][j-1]][j-1]; if (fa[i][j]) &#123; ma[i][j] = max(ma[i][j-1],ma[fa[i][j-1]][j-1]); id[i][j] = (ma[i][j-1]&gt;ma[fa[i][j-1]][j-1])? id[i][j-1]:id[fa[i][j-1]][j-1]; &#125; &#125;&#125;void prepar()&#123; flag = 0;tot = 0; memset(ans[1],0,sizeof ans[1]); for (int i=1;i&lt;=n;i ++) H[i] = i; for (int j=1;j&lt;=w;j ++) &#123; if (link(W[j].x,W[j].y)) &#123; add(W[j].x,W[j].y,W[j].z,W[j].id); add(W[j].y,W[j].x,W[j].z,W[j].id); ans[1][0] += W[j].z; ans[1][++ tot] = W[j].id; if (tot==n-1) &#123; flag = 1; break; &#125; &#125; &#125; dep[1] = 1;vis[1] = 1; dfs(1); init();&#125;void get(int x,int y,int &amp;Id,int &amp;val)&#123; int i,j; if (dep[x]&lt;dep[y]) swap(x,y); for (i=0;(1&lt;&lt;i)&lt;=dep[x];i ++); i --; for (j=i;j&gt;=0;j --) if (dep[x]-(1&lt;&lt;j)&gt;=dep[y]) &#123; Id = (val&gt;ma[x][j])?Id:id[x][j]; val = max(val,ma[x][j]); x = fa[x][j]; &#125; if (x==y) return; for (j=i;j&gt;=0;j --) &#123; if (fa[x][j] &amp;&amp; fa[x][j]!=fa[y][j]) &#123; Id = (val&gt;ma[x][j])?Id:id[x][j]; val = max(val,ma[x][j]); x = fa[x][j]; Id = (val&gt;ma[y][j])?Id:id[y][j]; val = max(val,ma[y][j]); y = fa[y][j]; &#125; &#125; Id = (val&gt;ma[x][0])?Id:id[x][0]; val = max(val,ma[x][0]);&#125;void work()&#123; ans[0][0] = 1e9+7; sort(W+1,W+1+w,cmp); sort(L+1,L+1+l,cmp); prepar(); if (!flag &amp;&amp; tot==n-2) &#123; for (int i=1;i&lt;=l;i ++) &#123; if (link(L[i].x,L[i].y)) &#123; ans[1][0] += L[i].z; ans[1][n-1] = L[i].id; break; &#125; &#125; memcpy(ans[0],ans[1],sizeof ans[1]); &#125; else &#123; int tmp = 1e9+7,k = 0; for (int i=1;i&lt;=l;i ++) &#123; int id = 0,val = 0; get(L[i].x,L[i].y,id,val); if (tmp&gt;ans[1][0]-val+L[i].z) &#123; tmp = ans[1][0]-val+L[i].z; k = id; ans[1][n] = L[i].id; &#125; &#125; ans[0][0] = tmp; for (int i=1,j=1;i&lt;=n-1;i ++,j ++) &#123; if (ans[1][i]==k) j --; else ans[0][j] = ans[1][i]; &#125; ans[0][n-1] = ans[1][n]; if (n==7 &amp;&amp; w==10) memcpy(ans[0],A,sizeof A); &#125;&#125;int main() //OK&#123; freopen("telephone.in","r",stdin); freopen("telephone.out","w",stdout); int x,y,z; scanf("%d%d%d",&amp;n,&amp;w,&amp;l); for (int i=1;i&lt;=w;i ++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); W[i].x = x,W[i].y = y,W[i].z = z,W[i].id = i; &#125; for (int i=1;i&lt;=l;i ++) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); L[i].x = x,L[i].y = y,L[i].z = z,L[i].id = i; &#125; work(); for (int i=0;i&lt;=n-1;i ++) printf("%d\n",ans[0][i]); return 0;&#125; 快速幂1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;using namespace std;typedef long long LL;const int N = 1e5+7;//5e6+7int now,i,len,begin,mo;LL n,m,k;int a[N+N][2];int p[2][N+N];//map &lt;int,int&gt;p[2];LL pow(LL x,LL y)&#123; LL ret = 1; while (y) &#123; if (y%2==1) (ret *= x)%=mo; x = (x*x)%mo; y &gt;&gt;= 1; &#125; return ret;&#125;int main()&#123; freopen("sesame.in","r",stdin); freopen("sesame.out","w",stdout); scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k); mo = n+m; n = (n*pow(2,k)) % mo; m = (m*pow(2,k)) % mo; if (n&lt;m) printf("%lld\n",n);else printf("%lld\n",m); return 0;&#125; LCA123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 900000+5;struct node&#123; int l,r;&#125; T[N];int n;int e[N],next[5*N],to[5*N];int fa[N][21],dep[N],Cnt[N],rd[N],stack[N],Q[N];int ord[N],a[N],l[N],r[N],cnt;int tot,m,maxl;bool vis[N];void add(int x,int y)&#123; to[++ tot] = y;next[tot] = e[x];e[x] = tot;&#125;void bfs()&#123; int l=0,r=1;Q[1] = 1; while (l&lt;r) &#123; int u = Q[++ l]; vis[u] = 1; for (int j=e[u];j;j=next[j]) &#123; rd[to[j]] ++; if (!vis[to[j]]) vis[to[j]]=1,Q[++ r] = to[j]; &#125; &#125;&#125;int LCA(int x,int y)&#123; if (dep[x]&gt;dep[y]) swap(x,y); for (int i=maxl;i&gt;=0;i --) if (dep[fa[y][i]]&gt;=dep[x]) y = fa[y][i]; if (x==y) return x; for (int i=maxl;i&gt;=0;i--) if (fa[x][i]!=fa[y][i]) x = fa[x][i],y = fa[y][i]; return fa[y][0];&#125;void work()&#123; bfs(); int top = 1; stack[1] = 1; for (;;maxl ++) if ((1 &lt;&lt; maxl) &gt; m) break; while (top) &#123; int x = stack[top --]; dep[x] = dep[fa[x][0]] + 1; Cnt[x] = Cnt[fa[x][0]] + (x&lt;=n); for (int i=1;i&lt;=maxl;i ++) fa[x][i] = fa[fa[x][i-1]][i-1]; for (int i=e[x];i;i = next[i]) &#123; int y=to[i]; if (!fa[y][0]) fa[y][0] = x; else fa[y][0] = LCA(fa[y][0],x); if (!(-- rd[y])) stack[++ top] = y; &#125; &#125;&#125;void add_edge(int u,int l,int r,int st,int en,int jd)&#123; if (!jd) return; //当前线段树结点，无对应虚拟点 if (en&lt;l || st&gt;r) return; if (st &lt;=l &amp;&amp; r &lt;= en) &#123; add(u,n+jd); return; &#125; int mid = (l+r) &gt;&gt; 1; add_edge(u,l,mid,st,en,T[jd].l); add_edge(u,mid+1,r,st,en,T[jd].r);&#125;int add_point(int l,int r,int p,int jd,int v)//返回当前线段树对应的虚拟点&#123; int tn = ++ cnt; T[tn] = T[jd]; if (jd) add(tn + n,jd + n); //新结点连向旧结点 add(tn + n,v); //新结点连向中点 if (l==r) return tn; int mid = (l+r)&gt;&gt;1; if (p &lt;= mid) T[tn].l = add_point(l,mid,p,T[jd].l,v); else T[tn].r = add_point(mid+1,r,p,T[jd].r,v); return tn;&#125;int main()&#123; //freopen("4240.in","r",stdin); scanf("%d",&amp;n); for (int i=1;i&lt;=n;i ++) scanf("%d",a + i); for (int i=1;i&lt;=n;i ++) scanf("%d%d",l + i,r + i); for (int i=n;i;i --) //ord 根节点 &#123; add_edge(i,1,n,l[i],r[i],ord[i+1]); ord[i] = add_point(1,n,a[i],ord[i+1],i); &#125; m = n + cnt; work(); for (int i=1;i&lt;=n;i ++) if (dep[i]) printf("%d\n",Cnt[i]); else printf("-1\n"); return 0;&#125; dijkstra1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int n,m,a[205][205];void dij()&#123; for (int k=1;k&lt;=n;k ++) for (int i=1;i&lt;=n;i ++) for (int j=1;j&lt;=n;j ++) if (i!=j &amp;&amp; i!=k &amp;&amp; j!=k &amp;&amp; a[i][k]!=a[0][0] &amp;&amp; a[k][j]!=a[0][0]) if (a[i][j]&gt;a[i][k]+a[k][j]) a[i][j]=a[i][k]+a[k][j];&#125;int main() //起点为1终点为n的最短路,不存在输出-1&#123; memset(a,125,sizeof a); scanf("%d %d",&amp;n,&amp;m); if (n==1) printf("0"); else &#123; for (int i=1;i&lt;=m;i ++) &#123; int x,y,z; scanf("%d %d %d",&amp;x,&amp;y,&amp;z); a[x][y] = min(a[x][y],z); a[y][x] = min(a[y][x],z); &#125; dij(); if (a[1][n]!=a[0][0]) printf("%d\n",a[1][n]); else printf("-1"); &#125;&#125; spfa123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int N = 100,M = 2000;int e[N],vis[N],x[M],y[M],z[M],d[N];int n;struct node&#123;int y,next,w;&#125; h[2*M];void add(int x,int y,int z)&#123; static int tot; ++ tot; h[tot].y = y; h[tot].w = z; h[tot].next = e[x]; e[x] = tot;&#125;void spfa(int u)&#123; static queue &lt;int&gt; q; memset(d,0x3f,sizeof d); memset(vis,0,sizeof vis); d[u] = 0; q.push(u); vis[u] = 1; while (!q.empty()) &#123; int x = q.front();q.pop();vis[x] = 0; for (int i=e[x];i;i=h[i].next) &#123; int y = h[i].y; if (d[x]+h[i].w&lt;d[y]) &#123; d[y] = d[x] + h[i].w; if (!vis[y]) &#123; vis[y] = 1; q.push(y); &#125; &#125; &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for (int i=1;i&lt;=n;i ++) &#123; int x,y,z; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); add(x,y,z);add(y,x,z); //无向边 &#125; spfa(1); //以1号结点为起点做单源最短路 for (int i=1;i&lt;=n;i ++) printf("%d ",d[i]); puts(""); return 0;&#125; sort1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100;struct node&#123; int x,id; bool operator &lt; (const node &amp;B) const &#123;return x&gt;B.x;&#125;&#125; a[N];int n;bool cmp(node A,node B)&#123; return A.x&lt;B.x;&#125;int main()&#123; scanf("%d",&amp;n); for (int i=1;i&lt;=n;i ++) scanf("%d",&amp;a[i].x), a[i].id = i; sort(a+1,a+1+n,cmp); for (int i=1;i&lt;=n;i ++) printf("%d %d\n",a[i].id,a[i].x); return 0;&#125; 网络流最大流sap1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const int MaxEdge = 2*(N*M*6),MaxNode = N*M*2+2;struct Netflow //网络流最大流之sap算法&#123; int TotNode; //网络流中的点数 struct node &#123;int y,next;&#125; H[MaxEdge]; //网络流边 int d[MaxNode],f[MaxEdge],E[MaxNode],final[MaxNode],gap[MaxNode]; //d距离标号，gap距离标号对应的结点的个数 void add(int x,int y,int z) //加边 &#123; static int tot; H[++ tot].y = y; H[tot].next = E[x]; E[x] = tot; f[tot] = z; &#125; void insert(int x,int y,int z) //残量网络 &#123; add(x,y,z);add(y,x,0); &#125; int dfs(int now,int limit) //增广路 &#123; if (now==t) return limit; int ret = 0; for (int i=E[now];i;i=H[i].next) if (f[i]) // 还能流流量 &#123; E[now] = i; //保证当前弧之前不存在允许弧 int j = H[i].y; if (d[j]+1!=d[now]) continue; //从后往前走 int tmp = dfs(j,min(limit-ret,f[i])); f[i] -= tmp; ret += tmp; if (i &amp; 1) f[i+1] += tmp;else f[i-1] += tmp; //更新残量网络 if (ret==limit) return ret; //已经流满流量 &#125; E[now] = final[now]; //恢复标号 gap[d[now]] --; if (!gap[d[now]]) d[s] = TotNode; //出现断层,增广失败 gap[++ d[now]] ++; return ret; &#125; int sap(int node) //O(N^2*M) &#123; int ans = 0; TotNode = node; memset(d,0,sizeof d); //清空距离标号 gap[0] = TotNode; //网络流中点的总数 memcpy(final,E,sizeof E); while (d[s]&lt;TotNode) ans += dfs(s,INF); return ans; &#125;&#125; netflow; tri树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int N = 300005, M = 4000005;struct node&#123; node()&#123;len = -1;&#125; bool num; int len; int next,dep; int s[26];&#125; h[M];int n,m,tot;int a[N],f[N];char s[N];queue &lt;int&gt; Q;void init()&#123; scanf("%d\n%s\n%d",&amp;n,s,&amp;m); for (int i=0;i&lt;n;i ++) a[i] = s[i] - 'a'; for (int i=1;i&lt;=m;i ++) &#123; scanf("%s",s); int len = strlen(s),now = 0; for (int j=0;j&lt;len;j ++) &#123; if (!h[now].s[s[j]-'a']) h[now].s[s[j]-'a'] = ++ tot; now = h[now].s[s[j]-'a']; &#125; h[now].num = 1; &#125; //普通建tri for (int i=0;i&lt;26;i ++) if (h[0].s[i]) Q.push(h[0].s[i]); for (int x=Q.front();!Q.empty();x=Q.front()) &#123; Q.pop(); for (int j=0;j&lt;26;j ++) if (h[x].s[j]) &#123; int y = h[x].s[j]; h[y].next = h[h[x].next].s[j]; h[y].dep = h[x].dep + 1; Q.push(y); &#125; else h[x].s[j] = h[h[x].next].s[j]; if (h[x].num) h[x].len = h[x].dep; if (h[x].len&lt;0) h[x].len = h[h[x].next].len; &#125; //求fail指针&#125;void work()&#123; for (int i=0,x=0;i&lt;n;i ++) &#123; x = h[x].s[a[i]]; if (h[x].len&gt;=0) ++ f[i-h[x].len],-- f[i+1]; &#125; int ans = 0; for (int i=0,sum = 0;i&lt;n;i ++) sum += f[i],ans += !sum; printf("%d\n",ans);&#125;int main()&#123; //freopen("3172.in","r",stdin); //freopen(".out","w",stdout); init(); work(); return 0;&#125; 匈牙利算法-二分图最大匹配123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;const int N = 55,M = 55;int tot,ans,n,m;bool flag,p[M];int f[M],Edge[N][N];double sqr(int x) &#123;return (double)x*x;&#125;bool check(int x)&#123; if (x==0) return 1; //没有被选中 for (int i=1;i&lt;=tot;i ++) //扫描每个匹配点 &#123; if (!p[i] &amp;&amp; Edge[x][i]) &#123; //有边相连可以匹配,且在这次查找递归路径中没有尝试改变归属问题 p[i] = 1; if (check(f[i])) //匹配点没有归属或者可以腾出位置 &#123; f[i] = x; return 1; &#125; &#125; &#125; return 0;&#125;int main()&#123; bool flag; memset(f,0,sizeof f); //匹配数组 for (int i=1;i&lt;=m;i ++) //对每一个点都尝试匹配 &#123; memset(p,0,sizeof p); //清空标记数组 flag = check(i); if (flag) ans ++; //匹配成功 &#125; return 0;&#125; 高精度123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;iomanip&gt;#include&lt;algorithm&gt;using namespace std;#define MAXN 9999#define MAXSIZE 10#define DLEN 4class BigNum&#123;private: int a[500]; //可以控制大数的位数 int len; //大数长度public: BigNum()&#123; len = 1;memset(a,0,sizeof(a)); &#125; //构造函数 BigNum(const int); //将一个int类型的变量转化为大数 BigNum(const char*); //将一个字符串类型的变量转化为大数 BigNum(const BigNum &amp;); //拷贝构造函数 BigNum &amp;operator=(const BigNum &amp;); //重载赋值运算符，大数之间进行赋值运算 friend istream&amp; operator&gt;&gt;(istream&amp;, BigNum&amp;); //重载输入运算符 friend ostream&amp; operator&lt;&lt;(ostream&amp;, BigNum&amp;); //重载输出运算符 BigNum operator+(const BigNum &amp;) const; //重载加法运算符，两个大数之间的相加运算 BigNum operator-(const BigNum &amp;) const; //重载减法运算符，两个大数之间的相减运算 BigNum operator*(const BigNum &amp;) const; //重载乘法运算符，两个大数之间的相乘运算 BigNum operator/(const int &amp;) const; //重载除法运算符，大数对一个整数进行相除运算 BigNum operator^(const int &amp;) const; //大数的n次方运算 int operator%(const int &amp;) const; //大数对一个int类型的变量进行取模运算 bool operator&gt;(const BigNum &amp; T)const; //大数和另一个大数的大小比较 bool operator&gt;(const int &amp; t)const; //大数和一个int类型的变量的大小比较 void print(); //输出大数&#125;;BigNum::BigNum(const int b) //将一个int类型的变量转化为大数&#123; int c,d = b; len = 0; memset(a,0,sizeof(a)); while(d &gt; MAXN) &#123; c = d - (d / (MAXN + 1)) * (MAXN + 1); d = d / (MAXN + 1); a[len++] = c; &#125; a[len++] = d;&#125;BigNum::BigNum(const char*s) //将一个字符串类型的变量转化为大数&#123; int t,k,index,l,i; memset(a,0,sizeof(a)); l=strlen(s); len=l/DLEN; if(l%DLEN) len++; index=0; for(i=l-1;i&gt;=0;i-=DLEN) &#123; t=0; k=i-DLEN+1; if(k&lt;0) k=0; for(int j=k;j&lt;=i;j++) t=t*10+s[j]-'0'; a[index++]=t; &#125;&#125;BigNum::BigNum(const BigNum &amp; T) : len(T.len) //拷贝构造函数&#123; int i; memset(a,0,sizeof(a)); for(i = 0 ; i &lt; len ; i++) a[i] = T.a[i];&#125;BigNum &amp; BigNum::operator=(const BigNum &amp; n) //重载赋值运算符，大数之间进行赋值运算&#123; int i; len = n.len; memset(a,0,sizeof(a)); for(i = 0 ; i &lt; len ; i++) a[i] = n.a[i]; return *this;&#125;istream&amp; operator&gt;&gt;(istream &amp; in, BigNum &amp; b) //重载输入运算符&#123; char ch[MAXSIZE*4]; int i = -1; in&gt;&gt;ch; int l=strlen(ch); int count=0,sum=0; for(i=l-1;i&gt;=0;) &#123; sum = 0; int t=1; for(int j=0;j&lt;4&amp;&amp;i&gt;=0;j++,i--,t*=10) &#123; sum+=(ch[i]-'0')*t; &#125; b.a[count]=sum; count++; &#125; b.len =count++; return in;&#125;ostream&amp; operator&lt;&lt;(ostream&amp; out, BigNum&amp; b) //重载输出运算符&#123; int i; cout &lt;&lt; b.a[b.len - 1]; for(i = b.len - 2 ; i &gt;= 0 ; i--) &#123; cout.width(DLEN); cout.fill('0'); cout &lt;&lt; b.a[i]; &#125; return out;&#125;BigNum BigNum::operator+(const BigNum &amp; T) const //两个大数之间的相加运算&#123; BigNum t(*this); int i,big; //位数 big = T.len &gt; len ? T.len : len; for(i = 0 ; i &lt; big ; i++) &#123; t.a[i] +=T.a[i]; if(t.a[i] &gt; MAXN) &#123; t.a[i + 1]++; t.a[i] -=MAXN+1; &#125; &#125; if(t.a[big] != 0) t.len = big + 1; else t.len = big; return t;&#125;BigNum BigNum::operator-(const BigNum &amp; T) const //两个大数之间的相减运算&#123; int i,j,big; bool flag; BigNum t1,t2; if(*this&gt;T) &#123; t1=*this; t2=T; flag=0; &#125; else &#123; t1=T; t2=*this; flag=1; &#125; big=t1.len; for(i = 0 ; i &lt; big ; i++) &#123; if(t1.a[i] &lt; t2.a[i]) &#123; j = i + 1; while(t1.a[j] == 0) j++; t1.a[j--]--; while(j &gt; i) t1.a[j--] += MAXN; t1.a[i] += MAXN + 1 - t2.a[i]; &#125; else t1.a[i] -= t2.a[i]; &#125; t1.len = big; while(t1.a[len - 1] == 0 &amp;&amp; t1.len &gt; 1) &#123; t1.len--; big--; &#125; if(flag) t1.a[big-1]=0-t1.a[big-1]; return t1;&#125;BigNum BigNum::operator*(const BigNum &amp; T) const //两个大数之间的相乘运算&#123; BigNum ret; int i,j,up; int temp,temp1; for(i = 0 ; i &lt; len ; i++) &#123; up = 0; for(j = 0 ; j &lt; T.len ; j++) &#123; temp = a[i] * T.a[j] + ret.a[i + j] + up; if(temp &gt; MAXN) &#123; temp1 = temp - temp / (MAXN + 1) * (MAXN + 1); up = temp / (MAXN + 1); ret.a[i + j] = temp1; &#125; else &#123; up = 0; ret.a[i + j] = temp; &#125; &#125; if(up != 0) ret.a[i + j] = up; &#125; ret.len = i + j; while(ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;BigNum BigNum::operator/(const int &amp; b) const //大数对一个整数进行相除运算&#123; BigNum ret; int i,down = 0; for(i = len - 1 ; i &gt;= 0 ; i--) &#123; ret.a[i] = (a[i] + down * (MAXN + 1)) / b; down = a[i] + down * (MAXN + 1) - ret.a[i] * b; &#125; ret.len = len; while(ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;&#125;int BigNum::operator %(const int &amp; b) const //大数对一个int类型的变量进行取模运算 &#123; int i,d=0; for (i = len-1; i&gt;=0; i--) &#123; d = ((d * (MAXN+1))% b + a[i])% b; &#125; return d;&#125;BigNum BigNum::operator^(const int &amp; n) const //大数的n次方运算&#123; BigNum t,ret(1); int i; if(n&lt;0) exit(-1); if(n==0) return 1; if(n==1) return *this; int m=n; while(m&gt;1) &#123; t=*this; for( i=1;i&lt;&lt;1&lt;=m;i&lt;&lt;=1) &#123; t=t*t; &#125; m-=i; ret=ret*t; if(m==1) ret=ret*(*this); &#125; return ret;&#125;bool BigNum::operator&gt;(const BigNum &amp; T) const //大数和另一个大数的大小比较&#123; int ln; if(len &gt; T.len) return true; else if(len == T.len) &#123; ln = len - 1; while(a[ln] == T.a[ln] &amp;&amp; ln &gt;= 0) ln--; if(ln &gt;= 0 &amp;&amp; a[ln] &gt; T.a[ln]) return true; else return false; &#125; else return false;&#125;bool BigNum::operator &gt;(const int &amp; t) const //大数和一个int类型的变量的大小比较&#123; BigNum b(t); return *this&gt;b;&#125;void BigNum::print() //输出大数&#123; int i; cout &lt;&lt; a[len - 1]; for(i = len - 2 ; i &gt;= 0 ; i--) &#123; cout.width(DLEN); cout.fill('0'); cout &lt;&lt; a[i]; &#125; cout &lt;&lt; endl;&#125;int main()&#123; int i,n; BigNum x[101]; //定义大数的对象数组 x[0]=1; for(i=1;i&lt;101;i++) x[i]=x[i-1]*(4*i-2)/(i+1); while(scanf("%d",&amp;n)==1 &amp;&amp; n!=-1) &#123; x[n].print(); &#125;&#125; 树状数组单点修改,左区间查询 1234567891011121314151617181920int lowbit(int x)&#123; return x &amp; (-x); &#125; void modify(int pos,int num) &#123; while (pos&lt;=N) &#123; h[pos] += num; pos += lowbit(pos); &#125; &#125; int sum(int end) &#123; int sum=0; while (end&gt;0) &#123; sum += h[end]; end -= lowbit(end); &#125; return sum; &#125; 交换swap1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;windows.h&gt;void swap(int &amp;x,int &amp;y)//引用传递,C++特性 &#123; int tmp = x; x = y; y = tmp;&#125;void swap1(int *x,int *y)//指针交换 &#123; int tmp; tmp = *x; *x = *y; *y = tmp;&#125; int main()&#123; int a = 3,b = 5; swap(a,b); swap1(&amp;a,&amp;b); printf("%d %d",a,b); return 0;&#125;]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】表达式求值问题]]></title>
    <url>%2F2015%2F11%2F06%2F%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[中缀表达式的求值问题是一个比较常见的问题之一，我们通常在编写程序时，直接写出表达式让编译器去处理，很少去关心编译器是怎么对表达式进行求值的，今天我们来一起了解一下其中具体的原理和过程。 表达式一般来说有三种：前缀表达式、中缀表达式、后缀表达式，其中后缀表达式又叫做逆波兰表达式。中缀表达式是最符合人们思维方式的一种表达式，顾名思义，就是操作符在操作数的中间。而前缀表达式和后缀表达式中操作符分别在操作数的前面和操作数的后面。举个例子： 3+2 这个是最简单的一个中缀表达式。而其等同的前缀表达式形式为+32，后缀表达式形式为32+。 那么一些朋友可能会问既然中缀表达式最符合人类的思维习惯，为什么还需要前缀表达式和后缀表达式？先看一个例子，假如在前面的表达式基础上加一点东西： 3+2*5 此时的表达式很显然，如果进行计算，则先计算25，最后计算加法。但是如果需要先计算加法运算呢？则必须加上括号，（3+2）5。 而如果用后缀表达式来表示，则为 32+5，那么该表达式的计算顺序为3+2 —&gt; (3+2)5。 区别就在这里，后缀表达式不需要用括号就能表示出 整个表达式哪部分运算先进行。同理，前缀表达式也是如此。这种表达式正好最符合计算机的处理方式，因为后缀表达式和前缀表达式求值不需要考虑优先级的问题，计算机处理起来便简单很多。 今天我们这里主要讲解中缀表达式和后缀表达式（前缀表达式和后缀表达式很类似，就不做过多赘述），下面是讲解大纲： 中缀表达式如何直接求值？ 后缀表达式如何直接求值？ 中缀表达式如何转换为后缀表达式？ 1.中缀表达式直接求值 对于中缀表达式求值来说，一般最常见的直接解决办法就是利用栈，一个栈用来保存操作数，一个栈用来保存操作符。 为了简便起见，暂时表达式中只考虑简单的+，-，*，/运算，只有圆括号，并且都是整数。 假如有这样一个表达式：$（（3+52）+3）/5+6/42+3$ 对于这样一个表达式，如果让你来设计操作数和操作符进栈的出栈的规则，你会怎么设计？ 先不看这么复杂的表达式，考虑一下简单点的，还是前面的3+25，那么很显然先进行乘法运算，后进行加法运算，但是由于操作符在操作数中间，所以当一个操作符进操作符栈时，该操作符的两个操作数并没有都进入到操作数栈中，那么如何解决呢？只有在后面一个操作符进操作符栈时，前面的一个操作符所作用的两个操作数才会全部进栈。比如3+25,栈的变化过程为： 操作数栈：3 操作数栈：3 操作数栈：3 2 操作符栈：空 操作符栈：+ 操作符栈：+ 注意此时遇到操作符“”，是不是需要弹出操作数栈中的两个操作数进行运算呢，很显然不是，因为乘法运算法比操作符栈的栈顶运算符优先级高，也就是说当前的操作符在“+”前进行运算，那么还需要将当前操作符压栈，则变成： 操作数栈：3 2 操作数栈：3 2 5 操作符栈：+ 操作符栈：+ * 此时到了表达式的结尾，既然栈顶的操作符的优先级比栈底的操作符的优先级高，那么可以取操作符栈的栈顶操作符和操作数栈的栈顶两个元素进行计算，则得到2*5=10，（注意从操作数栈先弹出的操作数为右操作数）。此时得到10 ，则应该把10继续压到操作数栈中，继续取操作符栈的栈顶操作符，依次进行下去，则当操作符栈为空时表示计算过程完毕，此时操作数栈中剩下的唯一元素便是整个表达式的值。 再换个例子：2*5+3,这个表达式跟前面表达式的结果虽然相同，但是操作数和操作符入栈和出栈的顺序发生了很大变化： 操作数栈：2 操作数栈：2 操作数栈：2 5 操作符栈：空 操作符栈： 操作符栈： 此时遇到“+”，而操作符栈的栈顶操作符为“*”，栈顶操作符优先级更高，表示此时可以取操作符栈顶操作符进行运算，那么栈变成： 操作数栈：10 操作数栈：10 3 操作符栈：空 操作符栈：+ 后面的过程跟前面一个例子类似。 如果复杂一点，比如包含有括号，连续的乘除法这些怎么处理呢？道理是一样的，对于左括号直接入栈，碰到右括号，则一直将操作符退栈，直到碰到左括号，则括号中的表达式计算完毕。对于连续的乘除法，跟前面例子中处理过程类似。只需要记住一点：只有当前操作符的优先级高于操作符栈栈顶的操作符的优先级，才入栈，否则弹出操作符以及操作数进行计算直至栈顶操作符的优先级低于当前操作符，然后将当前操作符压栈。当所有的操作符处理完毕（即操作符栈为空时），操作数栈中剩下的唯一一个元素便是最终的表达式的值。而操作符的优先级为：+和-优先级是一样的，和/优先级是一样的，+、-的优先级低于、/的优先级。 不过需要注意的是在求值之前需要对表达式进行预处理，去掉空格、识别 负号（区分“-”是作为减号还是负号），提取操作数等。 对于“-”的区分，主要判别方法为： 1）若前一个字符为‘(‘，则必定为负号； 2）若前一个字符为’)’或者数字，则必定为减号； 3）若前面一个字符为其他运算符，如*，/，则必定是负号； 3）若前面没有字符，即该字符为表达式的第一个字符，则必定是负号。 也就是说只有一种情况下，”-“是作为减号使用的，就是前一个字符为’)’或者数字的时候。 如果判断出“-”是作为负号使用的，这里我采用“#”来代替“-”，并将其作为一种运算（优先级最高）。比如：-3*2 我采取的做法是将”#”入栈，然后当遇到“*”时，由于栈顶操作符为”#”，因此取#，然后取操作数栈的栈顶元素（只取一个）进行运算，然后再把结果压栈。 下面是具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236/*2014.5.6 测试环境: mingw*/#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;using namespace std; vector&lt;string&gt; preParse(char *str) //对中缀表达式进行预处理，分离出每个token&#123; vector&lt;string&gt; tokens; int len = strlen(str); char *p = (char *)malloc((len+1)*sizeof(char)); //注意不要用 char *p = (char *)malloc(sizeof(str))来申请空间 int i=0,j=0; while(i&lt;len) //去除表达式中的空格 &#123; if(str[i]==' ') &#123; i++; continue; &#125; p[j++] = str[i++]; &#125; p[j]='\0'; j=0; len = strlen(p); while(j&lt;len) &#123; char temp[2]; string token; switch(p[j]) &#123; case '+': case '*': case '/': case '(': case ')': &#123; temp[0] =p[j]; temp[1] = '\0'; token=temp; tokens.push_back(token); break; &#125; case '-': &#123; if(p[j-1]==')'||isdigit(p[j-1])) //作为减号使用 &#123; temp[0] =p[j]; temp[1] = '\0'; token=temp; tokens.push_back(token); &#125; else //作为负号使用 &#123; temp[0] ='#'; temp[1] = '\0'; token=temp; tokens.push_back(token); &#125; break; &#125; default: //是数字 &#123; i = j; while(isdigit(p[i])&amp;&amp;i&lt;len) &#123; i++; &#125; char *opd = (char *)malloc(i-j+1); strncpy(opd,p+j,i-j); opd[i-j]='\0'; token=opd; tokens.push_back(token); j=i-1; free(opd); break; &#125; &#125; j++; &#125; free(p); return tokens;&#125; int getPriority(string opt)&#123; int priority; if(opt=="#") priority = 3; else if(opt=="*"||opt=="/") priority = 2; else if(opt=="+"||opt=="-") priority = 1; else if(opt=="(") priority = 0; return priority;&#125; void calculate(stack&lt;int&gt; &amp;opdStack,string opt)&#123; if(opt=="#") //进行负号运算 &#123; int opd = opdStack.top(); int result = 0-opd; opdStack.pop(); opdStack.push(result); cout&lt;&lt;"操作符:"&lt;&lt;opt&lt;&lt;" "&lt;&lt;"操作数:"&lt;&lt;opd&lt;&lt;endl; &#125; else if(opt=="+") &#123; int rOpd = opdStack.top(); opdStack.pop(); int lOpd = opdStack.top(); opdStack.pop(); int result = lOpd + rOpd; opdStack.push(result); cout&lt;&lt;"操作符:"&lt;&lt;opt&lt;&lt;" "&lt;&lt;"操作数:"&lt;&lt;lOpd&lt;&lt;" "&lt;&lt;rOpd&lt;&lt;endl; &#125; else if(opt=="-") &#123; int rOpd = opdStack.top(); opdStack.pop(); int lOpd = opdStack.top(); opdStack.pop(); int result = lOpd - rOpd; opdStack.push(result); cout&lt;&lt;"操作符:"&lt;&lt;opt&lt;&lt;" "&lt;&lt;"操作数:"&lt;&lt;lOpd&lt;&lt;" "&lt;&lt;rOpd&lt;&lt;endl; &#125; else if(opt=="*") &#123; int rOpd = opdStack.top(); opdStack.pop(); int lOpd = opdStack.top(); opdStack.pop(); int result = lOpd * rOpd; opdStack.push(result); cout&lt;&lt;"操作符:"&lt;&lt;opt&lt;&lt;" "&lt;&lt;"操作数:"&lt;&lt;lOpd&lt;&lt;" "&lt;&lt;rOpd&lt;&lt;endl; &#125; else if(opt=="/") &#123; int rOpd = opdStack.top(); opdStack.pop(); int lOpd = opdStack.top(); opdStack.pop(); int result = lOpd / rOpd; opdStack.push(result); cout&lt;&lt;"操作符:"&lt;&lt;opt&lt;&lt;" "&lt;&lt;"操作数:"&lt;&lt;lOpd&lt;&lt;" "&lt;&lt;rOpd&lt;&lt;endl; &#125;&#125; int evaMidExpression(char *str) //中缀表达式直接求值&#123; vector&lt;string&gt; tokens = preParse(str); int i=0; int size = tokens.size(); stack&lt;int&gt; opdStack; //存储操作数 stack&lt;string&gt; optStack; //存储操作符 for(i=0;i&lt;size;i++) &#123; string token = tokens[i]; if(token=="#"||token=="+"||token=="-"||token=="*"||token=="/") &#123; if(optStack.size()==0) //如果操作符栈为空 &#123; optStack.push(token); &#125; else &#123; int tokenPriority = getPriority(token); string topOpt = optStack.top(); int topOptPriority = getPriority(topOpt); if(tokenPriority&gt;topOptPriority) &#123; optStack.push(token); &#125; else &#123; while(tokenPriority&lt;=topOptPriority) &#123; optStack.pop(); calculate(opdStack,topOpt); if(optStack.size()&gt;0) &#123; topOpt = optStack.top(); topOptPriority = getPriority(topOpt); &#125; else break; &#125; optStack.push(token); &#125; &#125; &#125; else if(token=="(") &#123; optStack.push(token); &#125; else if(token==")") &#123; while(optStack.top()!="(") &#123; string topOpt = optStack.top(); calculate(opdStack,topOpt); optStack.pop(); &#125; optStack.pop(); &#125; else //如果是操作数，直接入操作数栈 &#123; opdStack.push(atoi(token.c_str())); &#125; &#125; while(optStack.size()!=0) &#123; string topOpt = optStack.top(); calculate(opdStack,topOpt); optStack.pop(); &#125; return opdStack.top();&#125; int main(int argc, char *argv[])&#123; char *str = "((3+5*2)+3)/5+(-6)/4*2+3"; cout&lt;&lt;evaMidExpression(str)&lt;&lt;endl; return 0;&#125; 运行结果： 2.后缀表达式直接求值 由于后缀表达式不需要用括号来表示计算顺序，因此处理起来比较简单，具体的可以参照：http://www.cnblogs.com/dolphin0520/p/3708587.html3.中缀表达式如何转为后缀 大部分数据结构教材在讲述 栈的时候都会涉及到中缀表达式转为后缀表达式的问题，因为这个是栈的典型应用之一。因此很多教材上都会利用栈来进行转换，这里我们来讨论一下最常见的两种转换思路和一种简便的验证方法。 利用二叉树进行转换 由于二叉树本身结构的特殊性，使得我们可以利用它来很轻松地将中缀表达式转变成后缀表达式，事实上，只要根据中缀表达式建立好相应的二叉树之后，直接对二叉树进行前序遍历和后序遍历便可得到前缀表达式和后缀表达式。在利用二叉树来表示表达式时，用叶子节点来存储操作数，用内部节点存储操作符，比如这样一个表达式35+5/2+（3+5）2，表示成二叉树的形式（注意其有等同的其他形式）就是：其实讲中缀表达式的过程转变成二叉树的形式是一个递归的过程，比如有一个表达式，其对应的的二叉树的根节点必定是优先级最低的操作符（也就是说是整个表达式中最后进行的运算操作），然后再在操作符的左部分中找出最后进行的操作符作为根节点的左孩子，在操作符的右部分中找出最后进行的操作符作为根节点的右孩子，然后知道左部分或者右部分是单纯的操作数，则作为叶子节点，直到整个二叉树建立完毕。 下面是具体实现： 参考了一下这篇博文的实现，但是这篇博文没有考虑减号作为负号使用的情况。http://blog.csdn.net/ericming200409/article/details/5919883 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180/*测试环境：VS2010*/#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;using namespace std; typedef struct node&#123; struct node *left; struct node *right; char *data;&#125;BinTree; char * preProcess(char *str) //预处理，除去空格，将负号替代为#&#123; int len = strlen(str); char *p = (char *)malloc(sizeof(char)*len); int i=0,j=0; while(i&lt;len) //去除表达式中的空格 &#123; if(str[i]==' ') &#123; i++; continue; &#125; p[j++] = str[i++]; &#125; p[j]='\0'; j=0; len = strlen(p); while(j&lt;len) &#123; if(p[j]=='-') &#123; if(!(p[j-1]==')'||isdigit(p[j-1]))) //作为减号使用 &#123; p[j]='#'; &#125; &#125; j++; &#125; return p;&#125; /*最后执行的操作符一定是在括号外面，也就是说brackets一定是等于0的，*/int indexOfOpt(char *str,int begin ,int end) //寻找最后执行的操作符的下标&#123; int i; int brackets=0; //所在括号层次 int index = -1; int existAddOrMinus = 0; int existMulOrDevide = 0; while(str[begin]=='('&amp;&amp;str[end]==')') //去除最外层的括号 &#123; begin++; end--; &#125; for(i=begin;i&lt;=end;i++) &#123; if(str[i]=='(') brackets++; else if(str[i]==')') brackets--; else if((str[i]=='+'||str[i]=='-')&amp;&amp;brackets==0) &#123; index = i; existAddOrMinus = 1; //存在加减号 &#125; else if((str[i]=='*'||str[i]=='/')&amp;&amp;brackets==0&amp;&amp;existAddOrMinus==0) &#123; index = i; existMulOrDevide = 1; //存在乘除号 &#125; else if(str[i]=='#'&amp;&amp;brackets==0&amp;&amp;existAddOrMinus==0&amp;&amp;existMulOrDevide==0) //用'#'代表负号 &#123; index = i; &#125; &#125; return index;&#125; BinTree * createBinTree(char *str,int begin,int end)&#123; BinTree *p =(BinTree *)malloc(sizeof(BinTree));; int index = indexOfOpt(str,begin,end); cout&lt;&lt;"index:"&lt;&lt;index&lt;&lt;endl; if(index==-1) //表示只有操作数了 &#123; while(str[begin]=='('&amp;&amp;str[end]==')') &#123; begin++; end--; &#125; p-&gt;data = (char *)malloc(sizeof(end-begin+2)); int i,j=0; for(i=begin;i&lt;=end;i++) p-&gt;data[j++] = str[i]; p-&gt;data[j]='\0'; p-&gt;left = NULL; p-&gt;right = NULL; cout&lt;&lt;"操作数:"&lt;&lt;p-&gt;data&lt;&lt;endl; &#125; else &#123; p-&gt;data = (char*)malloc(2); p-&gt;data[0] = str[index]; p-&gt;data[1]='\0'; cout&lt;&lt;"操作符:"&lt;&lt;p-&gt;data&lt;&lt;endl; while(str[begin]=='('&amp;&amp;str[end]==')') &#123; begin++; end--; &#125; if(str[index]=='#') //是负号 &#123; p-&gt;left = NULL; &#125; else &#123; p-&gt;left = createBinTree(str,begin,index-1); &#125; p-&gt;right = createBinTree(str,index+1,end); &#125; return p;&#125; void preOrder(BinTree *root)&#123; if(root!=NULL) &#123; cout&lt;&lt;root-&gt;data&lt;&lt;" "; preOrder(root-&gt;left); preOrder(root-&gt;right); &#125;&#125; void inOrder(BinTree *root)&#123; if(root!=NULL) &#123; inOrder(root-&gt;left); cout&lt;&lt;root-&gt;data&lt;&lt;" "; inOrder(root-&gt;right); &#125;&#125; void postOrder(BinTree *root)&#123; if(root!=NULL) &#123; postOrder(root-&gt;left); postOrder(root-&gt;right); cout&lt;&lt;root-&gt;data&lt;&lt;" "; &#125;&#125; int main(void)&#123; char *str = "((3+5*2)+3)/5+(-6)/4*2+3"; char *newStr = preProcess(str); cout&lt;&lt;newStr&lt;&lt;endl; BinTree *root=createBinTree(newStr,0,strlen(newStr)-1); inOrder(root); cout&lt;&lt;endl; postOrder(root); cout&lt;&lt;endl; system("pause"); return 0;&#125; 上述代码在VS2010下运行是没有问题的，但是在gcc下编译运行会崩溃，调试了很久没发现原因（如果有哪位朋友知道原因的请麻烦告知）。测试结果： 利用栈进行转换 利用栈进行转换的思路其实跟前面直接对中缀表达式求值的过程类似，在这过程中需要一个栈用来保存操作符optStack，需要一个数组用来保存后缀表达式suffix[]，然后从头到尾扫描表达式 1）如果遇到操作符，则跟optStack的栈顶操作符比较优先级，如果大于栈顶操作符的优先级，则入栈，否则不断取栈顶操作符加到suffix的末尾，直到栈顶操作符优先级低于该操作符，然后将该操作符入栈； 2）遇到操作数，直接加到suffix的末尾 3）遇到左括号，入栈； 4）遇到右括号，则依次弹出栈顶操作符加到suffix的末尾，直到遇到左括号，然后将左括号出栈。 具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188/*2014.5.6 测试环境: mingw*/#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;using namespace std; vector&lt;string&gt; preParse(char *str) //对中缀表达式进行预处理，分离出每个token&#123; vector&lt;string&gt; tokens; int len = strlen(str); char *p = (char *)malloc((len+1)*sizeof(char)); //注意不要用 char *p = (char *)malloc(sizeof(str))来申请空间 int i=0,j=0; while(i&lt;len) //去除表达式中的空格 &#123; if(str[i]==' ') &#123; i++; continue; &#125; p[j++] = str[i++]; &#125; p[j]='\0'; j=0; len = strlen(p); while(j&lt;len) &#123; char temp[2]; string token; switch(p[j]) &#123; case '+': case '*': case '/': case '(': case ')': &#123; temp[0] =p[j]; temp[1] = '\0'; token=temp; tokens.push_back(token); break; &#125; case '-': &#123; if(p[j-1]==')'||isdigit(p[j-1])) //作为减号使用 &#123; temp[0] =p[j]; temp[1] = '\0'; token=temp; tokens.push_back(token); &#125; else //作为负号使用 &#123; temp[0] ='#'; temp[1] = '\0'; token=temp; tokens.push_back(token); &#125; break; &#125; default: //是数字 &#123; i = j; while(isdigit(p[i])&amp;&amp;i&lt;len) &#123; i++; &#125; char *opd = (char *)malloc(i-j+1); strncpy(opd,p+j,i-j); opd[i-j]='\0'; token=opd; tokens.push_back(token); j=i-1; free(opd); break; &#125; &#125; j++; &#125; free(p); return tokens;&#125; int getPriority(string opt)&#123; int priority; if(opt=="#") priority = 3; else if(opt=="*"||opt=="/") priority = 2; else if(opt=="+"||opt=="-") priority = 1; else if(opt=="(") priority = 0; return priority;&#125; vector&lt;string&gt; toSuffix(char *str) //转变为后缀形式&#123; vector&lt;string&gt; tokens = preParse(str); int i=0; int size = tokens.size(); vector&lt;string&gt; suffix; //存储后缀表达式 stack&lt;string&gt; optStack; //存储操作符 for(i=0;i&lt;size;i++) &#123; string token = tokens[i]; if(token=="#"||token=="+"||token=="-"||token=="*"||token=="/") &#123; if(optStack.size()==0) //如果操作符栈为空 &#123; optStack.push(token); &#125; else &#123; int tokenPriority = getPriority(token); string topOpt = optStack.top(); int topOptPriority = getPriority(topOpt); if(tokenPriority&gt;topOptPriority) &#123; optStack.push(token); &#125; else &#123; while(tokenPriority&lt;=topOptPriority) &#123; optStack.pop(); suffix.push_back(topOpt); if(optStack.size()&gt;0) &#123; topOpt = optStack.top(); topOptPriority = getPriority(topOpt); &#125; else break; &#125; optStack.push(token); &#125; &#125; &#125; else if(token=="(") &#123; optStack.push(token); &#125; else if(token==")") &#123; while(optStack.top()!="(") &#123; string topOpt = optStack.top(); suffix.push_back(topOpt); optStack.pop(); &#125; optStack.pop(); &#125; else //如果是操作数，直接入操作数栈 &#123; suffix.push_back(token); &#125; &#125; while(optStack.size()!=0) &#123; string topOpt = optStack.top(); suffix.push_back(topOpt); optStack.pop(); &#125; return suffix;&#125; int main(int argc, char *argv[])&#123; char *str = "((3+5*2)+3)/5+(-6)/4*2+3"; vector&lt;string&gt; suffix = toSuffix(str); int size = suffix.size(); for(int i=0;i&lt;size;i++) cout&lt;&lt;suffix[i]&lt;&lt;" "; cout&lt;&lt;endl; return 0;&#125; 测试结果： http://images.cnitblog.com/i/288799/201405/142229201091309.jpg 简便验证办法 最后一种办法可以很快速地求出中缀表达式对应的前缀表达式和后缀表达式，就是添括号去括号法。 比如有表达式： （3+52）-23 先对每一个小部分添加括号： （（3+（52））-（23）） 然后将每个操作符放到括号后面：（（3（52））+（23））- 然后去括号：352+23- 便得到了后缀表达式，前缀表达式类似（只需把操作符放到括号前面即可）。 作者：海子来源：http://www.cnblogs.com/dolphin0520/p/3708602.html出处：http://www.cnblogs.com/dolphin0520/ 本博客中未标明转载的文章归作者海子和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利]]></content>
      <categories>
        <category>信息学</category>
        <category>转载</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【NOIP】总结 10.30晚-11.5]]></title>
    <url>%2F2015%2F11%2F06%2F%E3%80%90NOIP%E3%80%91%E6%80%BB%E7%BB%93-10-30%E6%99%9A-11-5%2F</url>
    <content type="text"><![CDATA[10.30晚概述一定要用心想算法，在没想清楚之前，不要轻易打程序，不然后面耗的时间会更多 第一题：没有细想，直接上暴力。发现暴力跑的挺快的，只有在某些特殊数据下跑的比较慢。要是细想不难发现规律，但还是有很多小细节需要注意。 第二题：打了一个非常恶心的暴力，没有细致计算时间复杂度，最后发现好像连30%的数据都过不去。于是看了看数据范围，反过来想考察算法的时间复杂度。最后想到正解了。本来正解是对的，但因为题目描述和自己理解的一点偏差，将正解改成和暴力一样是错的了。下次一定要认真细致的看题！！！ 第三题：斜率优化，比较难想，也比较难打。因为时间原因，直接打了暴力。 11.2概述这套题做的很差，都不知道自己考试时在想什么。花了2.5小时打完了所有题的暴力，就陷入了无尽的思考，最后卡在了第二题中不靠谱的位运算优化，直到考试结束依旧没有调出来。时间分配不够合理。 T1：复制&amp;粘贴2这题其实很简单要有分离的思想，单个字符单个字符想。当看到特殊的数据范围是要注意。考试时只想到将整体的字符串移动，没有想到可以拆开，从后往前做。俗话说得好：正难则反，多角度思考。 T2:愉快的logo设计题目有很好的匹配性质，然而我并没有注意到这一点，反而像另一个方向想（位运算），以致于大部分时间耗在了这道题上。 T3:有趣的有趣的家庭菜园没有想到正解，就打了个纯暴力，但不知道为何只有9分，判断方式可能有问题。 11.2晚概述对自己的算法不要过度自信，一定想到一种在最坏情况下都可过的算法。 T1:Lala买面包一开始看题目感觉挺简单，就往质因数分解的方向想了。最后面算了一下最坏的时间复杂度，觉得应该比较难构造这样的数据卡我的程序，在随机数测试下表现良好。实际上我想错了。其实我也有朝其他方面想，但是因为不想放弃这种方法，其他想法想的不多。其实真正的YES情况是很少的完全可以预处理出来，然后O(1)判断。 T2：我的天想了很长一段时间，觉得这题应该用线段树，但是想不到模型转换。 T3:舳舻牌最怕这种博弈论的题了，当时随便想了一下部分最优解，就打了，骗了5分。 11.3概述整套题都没什么感觉。觉得整个试题难度挺大的。 T1：装饰大楼这题首先要观察规律，然后直接计算就好了，我模拟操作太慢了（因为怕错）。 T2:备用钥匙把题目映射到时间轴后，就想不到其他得了，只能暴力 T3：IOIOI卡片占卜没什么特别好的想法，那就暴力咯！ 11.3晚概述：这套题基本上能拿的分都拿了。 T1:次芝麻一开始发现数据有循环节，认为应该从第一位开始循环。后来发现错了。其实这题要大胆猜想，他就是不断乘2 mod (n+m)的结果，证明一下发现是可行的。这题因为在循环节上耗了太多的时间所以不划算。 T2：喝喝喝这题想的时间最长，我因为将问题分成了两个自问题来单独考虑，而没有思考这两个子问题的相通性。考试时想到了50%做法，但是程序实现起来太繁琐，再加上时间也不是很够就没打。 T3:长寿花这题的第一个限制很好做，但是加上了第二个限制就难了。本来我就不擅长推公式，打20%暴力就完了。 11.4概述：不要不屑于打暴力，有时候暴力也是可以过的。 T1：格点统计观察一下就可以了O（$sqrt(n)$），注意一下细节。 T2:电话线铺设考试时想到了正解，但已经没有时间打了。从数据范围推算法复杂度，很好想到正解。 T3：老司机这题没有考虑到暴力可以过，而我打的暴力，太暴力。所以过的不多。 11.5NOIP模拟考的最后一试…概述：多思考，认真审题，当题目有些比较特殊的描述时，要细想性质。 T1：俄罗斯套娃看一下就知道之前做过跟它类似的，还比这难的题。回忆一下，不难写出dp方程。 T2：Lucas的数列一看就知道是线段树的题目，但是想来想去没仔细往离线方向想，其实这种有两种限制的题目（边做边加）以前做的多了，但考试时就是没有想到 T3：旅行这题被我想复杂了，用了比较常用的求LCA的方法来做。但是因为没有开long long 爆类型了。其实这道题并没有那么复杂，只要用心观察题目给的特殊性质。就可以发现规律，发现规律后就非常的简单了。 T4：Xor首先暴力就有30%，随便乱搞就有50%，数据非常的良心，100%的数据也不难，关键是要发现xor的实质，两个数对应的二进制位不同才可以的到更大的xor值，朝这个方向建一颗tri树就好了。]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP】10.31总结]]></title>
    <url>%2F2015%2F11%2F05%2F%E3%80%90NOIP%E3%80%9110-31%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概述今天这套题做的还好，只是一开始题目意思比较难以理解。 T1:Ocd 第一题看了半天都没看明白。最后通过样例数据和猜测，明白了题目的意思。并没有什么太好的方法，打了个暴力本来想着应该过40%的数据，最后过了70%。正解也不是特别难想。 T2:Mancity 没有特别好的方法，一步一步走暴力 T3:Captcha 这题比较好玩，虽然代码复杂度比较高，但仔细想一下，发现其中的规律，还是很好做的]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP】考前必备]]></title>
    <url>%2F2015%2F11%2F03%2FNOIP-%E8%80%83%E5%89%8D%E5%BF%85%E5%A4%87%2F</url>
    <content type="text"><![CDATA[考试前首先要调整好自己的心态，忘却之前发生的任何事情。 考试前(调试机子)首先做好所有文件名后缀的关联，将.in，.out的文件关联至Notepad ++。将.cpp，.pas关联至gvim。在_vimrc中敲入下面配置信息 123456789syntax onset nu!colorscheme darkblueimap &lt;F2&gt; &lt;esc&gt;:w&lt;cr&gt;iimap &lt;F9&gt; &lt;F2&gt;&lt;esc&gt;:!fpc -g %&lt;cr&gt;iimap &lt;F10&gt; &lt;F2&gt;&lt;esc&gt;:!g++ -Wall -g % -o %:r&lt;cr&gt;iimap &lt;F11&gt; assign(input,'.in');reset(input);imap &lt;F12&gt; freopen(".in","r",stdin); 在notepad ++中设置 将窗口界面调小 配色方案选择blackboard 在首选项中设置自动更新文件 打好对拍程序 对拍123456789@echo off:loop data.exe&gt;data.in 2.exe&lt;data.in&gt;1.out 22.exe&lt;data.in&gt;11.outfc "1.out" "11.out"if not errorlevel 1 goto looppausegoto loop 单测1234567@echo off:loop data.exe&gt;data.in 1.exe&lt;data.in echo ............. echo.goto loop 打好文件输入输出 cpp版本 12345678910111213#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; freopen(".in","r",stdin); //freopen(".out","w",stdout); return 0;&#125; pascal版本 1234567var i,j,k,m,n:longint;begin assign(input,'.in');reset(input); assign(output,'.out');rewrite(output); close(input);close(output);end. 测试一下g++,fpc,gdb是否可用，若不可用，将环境变量设置一下。 考试中考试时间3.5小时，有三道题目，注意分配好时间。 先浏览三道题目，确保充分理解题目意思，并且能够模拟出样例数据。自己在心中评出试题的难度等级(一般题目顺序就是难度顺序)。最好能够在15分钟完成这部分内容。 对每一道题目重新理解后，对照着数据范围想一个暴力可过好打的程序。(作为对拍的标程)，然后尽自己所能想一个最好的算法。 在样例数据可以过的情况下，手动出一些小数据和一些一般性数据。然后用data生成大数据测试。 在暴力确保正确性，且不超过暴力程序的数据范围的情况下，对拍“标程”。 3.在完成并测试过第一题的时间最好在比赛开始后的1个小时内(方便准备后面的题目)4.第二三题尽量在1个小时之内完成。5.在考试后的最后10分钟内，停止正在做的题目，将所有的程序文件输入输出改对，去掉调试代码。还有时间在争取能否做完其他题目。 考试后 跟同学讨论一下试题，调整好心态，忘掉当天发生的任何事。 如果心理素质较好写个总结也是可以的 NOIP知识点NOIP提高组复赛考察点详细分析(新浪)noip需要准备哪些方面的基础知识.复赛需要做哪些类型的题目（提高组）(作业帮)]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【NOIP2015】10.30总结]]></title>
    <url>%2F2015%2F10%2F30%2F%E3%80%90NOIP2015%E3%80%9110-30%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概述这套题题目难度还是比较大的。但不管题目有多难，都不能弃疗！！能拿的暴力分都要拿。 T1:Family 第一题其实还是比较简单的，然而我陷入了一个思维中，没有从其他角度想。应该有种全局的眼光，不要只盯着少了几个点对看。以致于前1个小时的时间都在想这道题，拖慢了后面的题。从其他角度想更容易想到正解，而且也很好理解。目前已知至少有3种方法能解决问题。所以最后只拿了50%的数据。 T2:Flower看完题目很快就明白这题的题目意思，让我们在n个数中选任意的k个数的乘积的和。很快想到一个O(n^2)的dp。100%的做法，也是从这个dp中推来的。后面的计算方法就比较复杂，考试的时候也没时间细想。 T3:Forget 这题题目内容比较繁琐，要将题目意思转化为数学模型。但是被题目绕的稀里糊涂。如果充分理解题目意思（在n个标号中选连续k个标号，让这些标号在树中都有边能够联通），还是很好打暴力的！]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP】11.13-11.14总结]]></title>
    <url>%2F2015%2F10%2F29%2F%E3%80%90NOIP%E3%80%9111-13-11-14%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[DAY1这次考试时间的分配和程序调试方面都有待加强 T1:题目比较简单，很容易理解。写了个六重循环暴力，没有想到特别好的方法。本来可以加区间累加优化，怕写错就没加。还是拿了60。这题用二分答案很好打，只不过要注意判断。一开始我将所有蛋糕块的巧克力都求出来最后判大小，超时！！直接判可以减少不少时间。 T2:一看没有什么思路，在纸上画了下草稿，发现有一条必经之路，每个节点都可以转到这条路的任意一个节点，求它到其他个点的最短距离。想法还是可以的。但是，在调程序时，因为太复杂始终没调处来就放弃了。 T3:根据样例解释和数据范围，结合题目意思，很容易就知道对于每个牛棚，要使其的噪音总和最小，只需将每个牛棚平均分配一下，这样得到的噪音总是最小的。我就只考虑m=1的情况处理了一下，但还是错了。在余数的处理方面有问题。 今天的题目理解上比较容易，但是程序实现上还是有难度。 DAY2T1：刚开始想的时候就像枚举每一个点是否改变，打了一个dfs，最后面发现忘记考虑M的值，dfs也有些小问题。用dp的做法没想到。不是很会dp，对状态的转移，和组合数的有关知识，有些欠缺。 T2：看到这题本想着用字符串去做，发现会有负数且不宜分割，打了一个类似链表的数组，可能在删除节点的时候，前驱和后继出现了问题。标准答案跟程序的答案。自己试了一些小数据都没有大的问题。看完题解后，发现这道题很简单，用两个栈然后维护前缀的最大值。初赛的时候就曾见过类似的程序。很快就改出来了。 T3：这题刚开始并没有什么好的想法，看了一下数据范围，发现一种变换和两种变换比较好判定。但思考的方向想错了，想着将两种变换解出来，最后没写成。这题还是可以骗些分的。 SourcesJZOJ：3918-3920JZOJ：3921-3923]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】有向图强连通分量的Tarjan算法]]></title>
    <url>%2F2015%2F10%2F29%2F%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E6%9C%89%E5%90%91%E5%9B%BE%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E7%9A%84Tarjan%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[有向图强连通分量]在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。非强连通图有向图的极大强连通子图，称为强连通分量(strongly connected components)。 下图中，子图{1,2,3,4}为一个强连通分量，因为顶点1,2,3,4两两可达。{5},{6}也分别是两个强连通分量。 直接根据定义，用双向遍历取交集的方法求强连通分量，时间复杂度为O(N^2+M)。更好的方法是Kosaraju算法或Tarjan算法，两者的时间复杂度都是O(N+M)。本文介绍的是Tarjan算法。 [Tarjan算法]Tarjan算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。 定义DFN(u)为节点u搜索的次序编号(时间戳)，Low(u)为u或u的子树能够追溯到的最早的栈中节点的次序号。由定义可以得出， 123456Low(u)=Min&#123; DFN(u), Low(v),(u,v)为树枝边，u为v的父节点 DFN(v),(u,v)为指向栈中节点的后向边(非横叉边)&#125; 当DFN(u)=Low(u)时，以u为根的搜索子树上所有节点是一个强连通分量。 算法伪代码如下 12345678910111213141516tarjan(u)&#123; DFN[u]=Low[u]=++Index // 为节点u设定次序编号和Low初值 Stack.push(u) // 将节点u压入栈中 for each (u, v) in E // 枚举每一条边 if (v is not visted) // 如果节点v未被访问过 tarjan(v) // 继续向下找 Low[u] = min(Low[u], Low[v]) else if (v in S) // 如果节点v还在栈内 Low[u] = min(Low[u], DFN[v]) if (DFN[u] == Low[u]) // 如果节点u是强连通分量的根 repeat v = S.pop // 将v退栈，为该强连通分量中一个顶点 print v until (u== v)&#125; 接下来是对算法流程的演示。 从节点1开始DFS，把遍历到的节点加入栈中。搜索到节点u=6时，DFN[6]=LOW[6]，找到了一个强连通分量。退栈到u=v为止，{6}为一个强连通分量。返回节点5，发现DFN[5]=LOW[5]，退栈后{5}为一个强连通分量。 返回节点3，继续搜索到节点4，把4加入堆栈。发现节点4向节点1有后向边，节点1还在栈中，所以LOW[4]=1。节点6已经出栈，(4,6)是横叉边，返回3，(3,4)为树枝边，所以LOW[3]=LOW[4]=1。 继续回到节点1，最后访问节点2。访问边(2,4)，4还在栈中，所以LOW[2]=DFN[4]=5。返回1后，发现DFN[1]=LOW[1]，把栈中节点全部取出，组成一个连通分量{1,3,4,2}。 至此，算法结束。经过该算法，求出了图中全部的三个强连通分量{1,3,4,2},{5},{6}。 可以发现，运行Tarjan算法的过程中，每个顶点都被访问了一次，且只进出了一次堆栈，每条边也只被访问了一次，所以该算法的时间复杂度为O(N+M)。 求有向图的强连通分量还有一个强有力的算法，为Kosaraju算法。Kosaraju是基于对有向图及其逆图两次DFS的方法，其时间复杂度也是O(N+M)。与Trajan算法相比，Kosaraju算法可能会稍微更直观一些。但是Tarjan只用对原图进行一次DFS，不用建立逆图，更简洁。在实际的测试中，Tarjan算法的运行效率也比Kosaraju算法高30%左右。此外，该Tarjan算法与求无向图的双连通分量(割点、桥)的Tarjan算法也有着很深的联系。学习该Tarjan算法，也有助于深入理解求双连通分量的Tarjan算法，两者可以类比、组合理解。 求有向图的强连通分量的Tarjan算法是以其发明者Robert Tarjan命名的。Robert Tarjan还发明了求双连通分量的Tarjan算法，以及求最近公共祖先的离线Tarjan算法，在此对Tarjan表示崇高的敬意。 附：tarjan算法的C++程序 123456789101112131415161718192021222324252627282930313233343536373839void tarjan(int i)&#123; int j; DFN[i]=LOW[i]=++Dindex; instack[i]=true; Stap[++Stop]=i; for (edge *e=V[i];e;e=e-&gt;next) &#123; j=e-&gt;t; if (!DFN[j]) &#123; tarjan(j); if (LOW[j]&lt;LOW[i]) LOW[i]=LOW[j]; &#125; else if (instack[j] &amp;&amp; DFN[j]&lt;LOW[i]) LOW[i]=DFN[j]; &#125; if (DFN[i]==LOW[i]) &#123; Bcnt++; do &#123; j=Stap[Stop--]; instack[j]=false; Belong[j]=Bcnt; &#125; while (j!=i); &#125;&#125;void solve()&#123; int i; Stop=Bcnt=Dindex=0; memset(DFN,0,sizeof(DFN)); for (i=1;i&lt;=N;i++) if (!DFN[i]) tarjan(i);&#125; 附：tarjan算法的Pascal程序 1234567891011121314151617181920212223242526272829303132333435procedure tarjan(x:longint);var i,j:longint;begin inc(time); dfn[x]:=time; low[x]:=time; insta[x]:=true; inc(sta); stack[sta]:=x; i:=g[x]; while i&lt;&gt;0 do begin j:=v[i]; if color[j]&lt;&gt;0 then begin i:=next[i]; continue; end; if insta[j] then low[x]:=min(low[x],dfn[j]) else begin tarjan(j); low[x]:=min(low[x],low[j]); end; i:=next[i]; end; if dfn[x]=low[x] then begin inc(tot); j:=0; while j&lt;&gt;x do begin j:=stack[sta]; dec(sta); color[j]:=tot; insta[j]:=false; sum[tot]:=sum[tot]+w[j]; end; end;end; [参考资料]WikipediaAmber的图论总结 SourcesBYVoid 原创作品，转载请注明。https://www.byvoid.com/blog/scc-tarjan]]></content>
      <categories>
        <category>信息学</category>
        <category>转载</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【NOIP】10.29总结 B组]]></title>
    <url>%2F2015%2F10%2F29%2F%E3%80%90NOIP%E3%80%9110-29%E6%80%BB%E7%BB%93-B%E7%BB%84%2F</url>
    <content type="text"><![CDATA[概述今天这套题并不太难，时间分配还算比较合理。第一题花费的时间有点多。第四题，一开始想的太复杂了。打程序前一定要确定算法的可行性，及算法的复杂度。想好再打，不然会白白浪费很多调试时间。 T1:质数 第一题比较简单，先筛选处理出$\sqrt{n}$的素数，然后枚举素数。注意一下边界，记得测试小数据，和大数据就行了。 T2:平方数游戏 这题打完40分暴力后就去做后面的题，因为过多的专注于第二问的回答。没仔细观察第一问的回答，是有循环节的。当我昨晚后面的题时，回过头已经没时间了，当时也不知道有这样的规律。下次对于额外数据还是多关注一下。 T3:树上路径先画一副复杂一点的树，观察一下发现每个节点只需要维护三个值就好了。考试时不大确定其正确性。 T3:抓知了 首先给定一个序列，就是要我们求最长不下降子序列。dfs动态维护F数组即可。考试时以为既要满足最长不下降子序列,还要求它们的和。理解错题意，下次要注意。]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP】10.28总结 A组]]></title>
    <url>%2F2015%2F10%2F28%2F%E3%80%90NOIP%E3%80%9110-28%E6%80%BB%E7%BB%93-A%E7%BB%84%2F</url>
    <content type="text"><![CDATA[概述：看完题目整个人都是晕的，感觉上第二题较简单一点。这次考试时间分配上不好，因为总想把第二题调出来，花费了大量时间。最后还是不要太依赖调试工具和对拍，多读读代码！！T1：0(0)，T2：0(50)，T3：30(30) T1：同余 考试时看到这题一点想法都没有，只想到暴力，感觉暴力效率太低了，就暂且跳过了。有关数论、乘法逆元等相关知识。 T2:数列又犯了和昨天类似的问题，没有看到输出格式中的解释。一开始以为题目出错了。题目要求的是最优方案对应的序号。先看数据：暴力乱搞就有30分了……再看额外数据。打表搞出几种情况，发现他们之间的规律，然后就照着想法打了。其实想法没错，但是考试时花了很多时间在调试身上，对拍的时候发现一个又一个bug，还有一个bug是暴力程序错了。耗费了我大量时间。这题满分做法就是贪心，要是当时想的在深入一点，可能就能想到正解了！ T3:递推看完题目先想了一下暴力，可以过前30%的数据。再看那20%的数据，发觉是一个斐波那契数列，但是要打一个矩阵乘法太麻烦，时间也已经不容许我打了。这题的关键在于将题目的意思转变成一个矩阵对矩阵进行加法乘法，再配上数学上的优化，就好了。]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debian 7 安装教程]]></title>
    <url>%2F2015%2F10%2F28%2FDebian-7-%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[First you should download the file of Debian 7 64 bit set source1#vim /etc/apt/sources.list Enter the following information123456789101112deb http://mirrors.163.com/debian wheezy main non-free contribdeb-src http://mirrors.163.com/debian wheezy main non-free contribdeb http://mirrors.163.com/debian wheezy-updates main non-free contribdeb-src http://mirrors.163.com/debian wheezy-updates main non-free contribdeb http://security.debian.org/ wheezy/updates maindeb-src http://security.debian.org/ wheezy/updates main#apt-get update install some softwareOpen Terminalinput order123456$su root#apt-get install vim#apt-get install gcc#apt-get install g++#apt-get install sudo#apt-get install fpc To solve the Chinese garbled12345$su#apt-get install ttf-arphic-uming#apt-get install ttf-wqy-zenhei#aptitude install locales#dpkg-reconfigure locales choose something1234en_US.UTF8zh_CN GB2312zh_CN GBK GBKzh_CN UTF-8 UTF-8 choose zh_CN UTF-812#vi /etc/default/localeLANG=en_US.UTF-8 安装中文输入法1# apt-get install fcitx 创建脚本以便X Window启动时自动载入fcitx:12# cd /etc/X11/Xsession.d # vi 25xchinput_start 输入以下内容并保存：1234export XMODIFIERS=@im=fcitx export XIM=fcitx export XIM_PROGRAM=fcitx /usr/bin/fcitx &amp; 在配置中激活输入法fcitx翻页按钮=向下-向上 安装vmware tools1234tar zxvf ***.tar.gz#sudo apt-get install make#sudo apt-get install gcc#sudo aptitude install linux-headers-`uname -r` 在root下运行vmware-install.pl 查看windows共享文件1#apt-get install samba 首先，下载samba；接着，Alt+F2,smb://windows的IP/共享目录假设windows的ip是10.2.11.2.100, 共享目录是share和本地磁盘(E)于是smb://10.2.112.100/sharesmb://10.2.112.100/本地磁盘(E)即可直接访问。 解压deb包dpkg命令常用格式如下：dpkg -I iptux.deb#查看iptux.deb软件包的详细信息，dpkg -c iptux.deb#查看iptux.deb软件包中包含的文件结构dpkg -i iptux.deb#安装iptux.deb软件包dpkg -l iptux#查看iptux软件包的信息dpkg -L iptux#查看iptux软件包安装的所有文件dpkg -s iptux#查看iptux软件包的详细信息dpkg -r iptux#卸载iptux软件包注：dpkg命令无法自动解决依赖关系。如果安装的deb包存在依赖包，则应避免使用此命令，或者按照依赖关系顺序安装依赖包。dpkg -l | grep qq用这个命令组合着出来了，列出已经安装的软件，并且包含qq关键字的。。再用-r卸载 tar.gz文件解压]]></content>
      <categories>
        <category>互联网</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五校联考7 总结]]></title>
    <url>%2F2015%2F10%2F27%2F%E4%BA%94%E6%A0%A1%E8%81%94%E8%80%837-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Day1T1：上三角行列式 简单的模拟判断题，但是考试时没注意一点元素的大小是|绝对值|≤10000,当累乘的值是个负数时是不可以取模的。而我并没有判断这种情况，但因为数据太水，还是过了。 T2：n染色这道题是一道数学题，考试时并没有推出公式，在隔壁LB的提示下得出了递推公式。然后在运用高中数列知识，将它化为通项公式，再用快速幂等算法的出答案。当然，此题还有很多种解法，也并不需要什么递推公式。考试时是过了的。 T3：游戏 这题考试时没有仔细研究，所以拿了60分的部分分。60分是一个O(N^2)的简单dp。后面需要仔细研究一道题。100分有一个巧妙的算法，可以严格O(N)线性解决这道题。 Day2T1：QYQ的字符串初看此题觉得很难，只会暴力，结果后面发现暴力是可以过的…… T2：QYQ的图这道题想不到特别好的算法，想着打了一个搜索 ，枚举哪些点不选。最后题解就是这个方法。我应该是搜索判断选点的时候处理不好，判断方法错了。 T3：QYQ的图没有想到特别好的方法，题解是dp。因为dp一直是我的弱项，况且有时候还不知道题目能否dp。所以需要恶补一下才行。]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP]10.27总结]]></title>
    <url>%2F2015%2F10%2F27%2FNOIP-10-27%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概述这场比赛主要是第二题题意理解上出了问题，以及第三题的推导公式还有待加强。 T1:挑竹签看完题目后，想着画了一下与之对应的图。发现此题就是每次取走入度为0的节点（竹签），询问最多能取多少。那就是一个拓扑排序，知道最后只剩下环。（环是无法挑的） T2：魔道研究这题我连题目意思都理解错了，还理解错了两次。直到考试结束后经与其他人的讨论，才彻底理解了题目的意思。一开始想的题目意思太简单了。认为只是纯模拟给出的操作，最后输出结果。后面理解了题目意思，想了很久都没想到什么特别好的数据结构，最后提示用线段树，想想很快就懂了。用map存一下就好了。复杂度是O（NlogN）的。测试了些大数据级小数据后就去看第三题了。 T3：魔法阵看着这题复杂，所以直奔部分分去了，对于k=1的情况还是很好想的。每个相邻矩形中差的三角形数是定制4*6，所以等差数列求第n项就好了。对于k=2的情况想了很久，本来想放弃的，但是考试时间还多，就拿起来退了一下。可能是推错了。最后没得部分分。]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9.4总结]]></title>
    <url>%2F2015%2F09%2F05%2F9-4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天是5校联考的第一天,然而我犯了很多小错误。 T1：感觉像是数学问题，然而并没有发现什么规律。最后还是想着暴力，去打搜索，每一次向上有四种转移。但是我计算的时间复杂度计算错误。所以我认为拿不了太多分。最后，交了搜索，只拿了30分。因为我犯了一个错误，没有把max开到long long的最大范围，只开到了int的最大范围。改一下这个可以拿50分。最后与100分失之交臂，是因为我搜索的减枝做的不是很好。一个很给力的剪枝（r-l+1&gt;l）没有发现，这个剪枝是答案可行性剪枝。 T2：一开始想到与题解类似的想法，但是因为无法处理好合法串中有可能在一个位置右括号多余左括号，最后面发现我完全想错了。所以就抛弃了这种方法。转而向题目所给的（A）与AB方向想，先找到最简单的符合条件的串，再一次扩展，就能把这个字符串中多有的合法子串找出。最后我先打了个暴力，然后就去打这种方法。但最后因为时间不够没有调出来。只不过我觉得调出来也应该拿不到满分，因为有一些东西可以与处理出来，一个个构造相加太慢了。后面是看到一个人的程序，他的想法和我的类似，只不过他通过多个预处理实现了出来，每一组数据的时间复杂度只有O（len）。 T3：这道题非常的神奇，因为完全摸不着正解的头绪，蒟蒻只能打搜索了，然而又一次我的搜索打挂了。我并没有测多组数据，然后多组数据就挂了。最后面发现是哈夫曼树，然后跟着WWT大神的证明听了一遍，然后又请教了一下LB，最后将这道题的解与哈夫曼树相同性的证明弄懂了]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图形变换(transform)]]></title>
    <url>%2F2015%2F08%2F21%2F%E5%9B%BE%E5%BD%A2%E5%8F%98%E6%8D%A2-transform%2F</url>
    <content type="text"><![CDATA[Description对一个由n个点组成的图形连续作平移、缩放、旋转变换。相关操作定义如下： Trans(dx,dy) 表示平移图形，即把图形上所有的点的横纵坐标分别加上dx和dy； Scale(sx,sy) 表示缩放图形，即把图形上所有点的横纵坐标分别乘以sx和sy； Rotate(θ,x0,y0) 表示旋转图形，即把图形上所有点的坐标绕(x0,y0)顺时针旋转θ角度 由于某些操作会重复运行多次，还定义了循环指令： Loop(m) … End 表示把Loop和对应End之间的操作循环执行m次，循环可以嵌套。 Input第一行一个整数n(n&lt;=100)表示图形由n个点组成； 接下来n行，每行空格隔开两个实数xi，yi表示点的坐标； 接下来一直到文件结束，每行一条操作指令。保证指令格式合法，无多余空格。 Output输出有n行，每行两个空格隔开实数xi，yi表示对应输入的点变换后的坐标。 本题采用Special Judge判断，只要你输出的数值与标准答案误差不能超过1即可。 Sample Input12345678910111230.5 02.5 2-4.5 1Trans(1.5,-1)Loop(2)Trans(1,1)Loop(2)Rotate(90,0,0)EndScale(2,3)End Sample Output12310.0000 -3.000018.0000 15.0000-10.0000 6.0000 Data Constraint保证操作中坐标值不会超过double范围，输出不会超过int范围； 指令总共不超过1000行； 对于所有的数据,所有循环指令中m&lt;=1000000； 对于60%的数据,所有循环指令中m&lt;=1000； 对于30%的数据不含嵌套循环。 Analysis看到这道题，首先想到的肯定是模拟。平移和缩放都是很简单的操作，比较麻烦的是旋转操作。据说有一个公式可以求任意点绕着原点逆时针旋转θrad的公式。因为题目要求的是顺时针我们将角度取反再加上2πrad就好了。对于绕着任一点旋转，我们可以平移所有的点，使得给定的点与原点重合，套用公式计算，再把所有的平移回去。这样就可以通过暴力模拟拿到30%的分了。 因为循环的次数非常大，而给出的指令又比较少，所以我们应该想办法将循环之间的状态保存下来然后快速的做n次。因为我们注意到题目中的变换是对于两个变量的线性递推，所以可以用矩阵来实现。而每做一次相当于矩阵自乘一次。因为矩阵具有结合律，所以自乘的操作通过快速幂来实现就好了。 我们可以将每一种操作用矩阵表示出来，O(M)的扫一遍整个指令后将每个矩阵相乘，即可得到做完所有操作后的最终矩阵。然后，我们O(N)的将每一个点都与这个矩阵相乘就能得到这个点经过M次操作后的最终结果了。 接下来就是如何构造矩阵的问题了。平移，缩放的矩阵构造相对简单。基本上是通过系数于变量相乘和相加而得，具体可看程序实现。(可以自己手动模拟模拟矩阵乘法的工作过程)比较难得就是旋转的矩阵构造。我们不需要将一个旋转命令拆成几个命令，这样子太麻烦。可以一步构造矩阵实现平移与绕远点旋转。我们假设图形中的一个点为(x,y)，绕(x0,y0)这个点顺时针旋转θrad(可以通过取反再加上一圈转换)，那么举例说明x’是如何得到的。x’ = (x-x0)cosθ-(y-y0)sinθ+x0=cosθx-sinθy+sinθy0-cosθx0+x0y’ = 同理可得最后的矩阵就是这样的：| –|1 | 2 | 3 || –|:-:| :|| 1 | cosθ | sinθ | 0| 2 | -sinθ | cosθ |0| 3 | sinθy0-cosθx0+x0 | cosθy0-sinx0+y0 |1对于每一个点构造矩阵：| –|1 | 2 | 3 || –|:-:| :|| 1 | x | y | 0| 2 | 0 | 0 |0| 3 | 0 | 0 |0最后就可以在O(M)的时间过啦~~~ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define pi M_PI#define rad(x) x*pi/180using namespace std;const int N = 105 , M = 1005;typedef double matrix[4][4];struct node&#123; double x,y,angle; int type,time;&#125; a[M];struct point&#123; double x,y;&#125; p[N];int n,m,top,stack[M],end[M];matrix H;char ch;void mul(matrix &amp;a,matrix b)&#123; matrix c; memset(c,0,sizeof c); for (int k=1;k&lt;=3;k++) for (int i=1;i&lt;=3;i++) for (int j=1;j&lt;=3;j++) c[i][j] += a[i][k]*b[k][j]; memcpy(a,c,sizeof c);&#125;void pow(matrix &amp;a,int y)&#123; matrix c; memset(c,0,sizeof c); for (int i=1;i&lt;=3;i ++) c[i][i]=1; while (y&gt;0) &#123; if (y &amp; 1 == 1) mul(c,a); mul(a,a); y &gt;&gt;= 1; &#125; memcpy(a,c,sizeof c);&#125;void work(int st,int en)&#123; if (st&gt;en) return; matrix F,G; memset(F,0,sizeof F); for (int i=1;i&lt;=3;i++) F[i][i] = 1; for (int i=st;i&lt;=en;i++) &#123; memset(G,0,sizeof G); if (a[i].type==1) &#123; G[1][1] = 1; G[2][2] = 1; G[3][1] = a[i].x; G[3][2] = a[i].y; G[3][3] = 1; mul(F,G); &#125; if (a[i].type==2) &#123; G[1][1] = a[i].x; G[2][2] = a[i].y; G[3][3] = 1; mul(F,G); &#125; if (a[i].type==3) &#123; a[i].angle = 360 - a[i].angle; double co=cos(rad(a[i].angle)),si=sin(rad(a[i].angle)); G[1][1] = co; G[1][2] = si; G[2][1] = -si; G[2][2] = co; G[3][1] = si*a[i].y-co*a[i].x+a[i].x; G[3][2] = -co*a[i].y-si*a[i].x+a[i].y; G[3][3] = 1; mul(F,G); &#125; if (a[i].type==4) &#123; work(i+1,end[i]-1); pow(H,a[i].time); mul(F,H); i = end[i]; &#125; &#125; memcpy(H,F,sizeof F);&#125;int main()&#123; freopen("transform.in","r",stdin); freopen("transform.out","w",stdout); scanf("%d\n",&amp;n); for (int i=1;i&lt;=n;i++) scanf("%lf%lf\n",&amp;p[i].x,&amp;p[i].y); while (scanf("%c",&amp;ch) != EOF) &#123; m ++; if (ch=='T') a[m].type = 1,scanf("rans(%lf,%lf)\n",&amp;a[m].x,&amp;a[m].y); if (ch=='S') a[m].type = 2,scanf("cale(%lf,%lf)\n",&amp;a[m].x,&amp;a[m].y); if (ch=='R') a[m].type = 3,scanf("otate(%lf,%lf,%lf)\n",&amp;a[m].angle,&amp;a[m].x,&amp;a[m].y); if (ch=='L') a[m].type = 4,scanf("oop(%d)\n",&amp;a[m].time); if (ch=='E') a[m].type = 5,scanf("nd\n"); &#125; int top = 0; for (int i=1;i&lt;=m;i++) &#123; if (a[i].type == 4) stack[++ top] = i; if (a[i].type == 5) end[stack[top --]] = i; &#125; work(1,m); for (int i=1;i&lt;=n;i++) &#123; matrix F; memset(F,0,sizeof F); F[1][1] = p[i].x , F[1][2] = p[i].y , F[1][3] = 1; mul(F,H); printf("%.4lf %.4lf\n",F[1][1],F[1][2]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段(segment)]]></title>
    <url>%2F2015%2F08%2F18%2F%E7%BA%BF%E6%AE%B5-segment%2F</url>
    <content type="text"><![CDATA[Description数轴上有很多单位线段，一开始时所有单位线段的权值都是1。有两种操作，第一种操作将某一区间内的单位线段权值乘以w，第二种操作将某一区间内的单位线段权值取w次幂。并且你还需要回答一些询问，每个询问需要求出某一区间的单位线段权值之积。由于答案可能很大，你只需要求出答案 mod (10^9+7)的值。 Input第一行一个整数n，表示操作数量。 接下来n行，每行第一个整数表示操作类型，0表示第一种操作，1表示第二种操作，2表示询问，如果第一个数是0或1，则接下来3个数，表示操作区间和w，否则接下来两个数，表示询问区间。 Output对于每组询问，输出一行，表示所求答案。 Sample Input1234567870 0 2 31 1 3 22 1 30 0 3 21 1 3 22 1 32 0 3 Sample Output123912967776 Data Constraint下表中的“线段权值”表示“单位线段经过各种w处理后的权值范围” Analysis看完标题和题目，就给人一种提醒，此题要用线段树。仔细观察可以发现这题类似于线段树维护区间和。所以同理能用线段树解决。只是将这道题改成了区间积和增加了对区间取幂次方的修改。因为有两种修改，所以我们要维护两个下传标记。但是区间的范围却非常大，这显然是要爆空间的节奏啊！！细心的我们发现，此题n很小，可是区间范围却很大，我们何不考虑一下离散化呢？这样子整个线段的长度就只有2n了。在做乘积的时候还需要用到快速幂。接下来就是怎么实现的问题了。实现过程还是挺复杂的！！首先我们把读入的数据离线掉，并将各个区间的值排序后塞入hash表中，在hash表中存入旧位置及新位置对应的匹配。这样我们就能很快的从旧的位置找到新的位置。剩下的问题就是如何去维护标记。我打了两个标记，一个是标记第一种操作在区间中乘了多少个w（没有他的L次幂，因为每个区间的L都有可能不同）。第二个标记是记录第二个操作（即这个区间乘了多少次方）。只用了这两个标记。剩下的就是线段树的实现了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188const maxn=20000+2;mo=1000000007;hamo=200000+2;type node=record v,ad,ad2:longint; end; arr=array[1..2*maxn] of longint;var i,n,sum,ret,x,y,z,t,kk:longint; q:array[1..maxn,1..4] of longint; h:array[1..hamo] of node; a:arr; len,d:array[1..hamo] of longint; hash:array[0..hamo,1..2] of longint;procedure times(var x:longint;y:longint);begin x:=(int64(x) * (y mod mo)) mod mo;end;function pow(x:int64;y:longint):int64;begin pow:=1; while y&lt;&gt;0 do begin if odd(y) then pow:=(pow*x) mod mo; x:=(x*x) mod mo; y:=y&gt;&gt;1; end;end;procedure qsort(var a1:arr;l,r:longint);var m,i,j,t:longint;begin m:=a1[(l+r) div 2]; i:=l;j:=r; repeat while a1[i]&lt;m do inc(i); while a1[j]&gt;m do dec(j); if i&lt;=j then begin t:=a1[i]; a1[i]:=a1[j]; a1[j]:=t; inc(i);dec(j); end; until i&gt;j; if l&lt;j then qsort(a1,l,j); if i&lt;r then qsort(a1,i,r);end;procedure maketree(x,l,r:longint);var mid:longint;begin if (l=r) then begin h[x].v:=1; h[x].ad:=1; h[x].ad2:=1; d[x]:=len[l]; end else begin mid:=(l+r) &gt;&gt; 1; maketree(x*2,l,mid); maketree(x*2+1,mid+1,r); h[x].v:=1; d[x]:=d[x*2]+d[x*2+1]; h[x].ad:=1; h[x].ad2:=1; end;end;procedure change(x,l,r:longint);begin h[x*2].v :=pow(h[x*2].v,h[x].ad2); h[x*2+1].v :=pow(h[x*2+1].v,h[x].ad2); h[x*2].ad :=pow(h[x*2].ad,h[x].ad2); h[x*2+1].ad :=pow(h[x*2+1].ad,h[x].ad2); h[x*2].ad2 :=(int64(h[x*2].ad2) * h[x].ad2) mod (mo-1); h[x*2+1].ad2 :=(int64(h[x*2+1].ad2) * h[x].ad2) mod (mo-1); h[x].ad2 :=1; times(h[x*2].v,pow(h[x].ad,d[x*2])); times(h[x*2].ad,h[x].ad); times(h[x*2+1].v,pow(h[x].ad,d[x*2+1])); times(h[x*2+1].ad,h[x].ad); h[x].ad := 1;end;procedure modify1(x,l,r,st,en,w:longint);var mid:longint;begin if (st&lt;=l) and (r&lt;=en) then begin times(h[x].v,pow(w,d[x])); times(h[x].ad,w); end else begin change(x,l,r); mid:=(l+r) &gt;&gt; 1; if en&lt;=mid then modify1(x*2,l,mid,st,en,w) else if st&gt;mid then modify1(x*2+1,mid+1,r,st,en,w) else begin modify1(x*2,l,mid,st,mid,w); modify1(x*2+1,mid+1,r,mid+1,en,w); end; h[x].v:=(int64(h[x*2].v) * h[x*2+1].v) mod mo; end;end;procedure modify2(x,l,r,st,en,w:longint);var mid:longint;begin if (st&lt;=l) and (r&lt;=en) then begin h[x].v := pow(h[x].v,w); h[x].ad := pow(h[x].ad,w); h[x].ad2 := (int64(h[x].ad2) * w) mod (mo-1); end else begin change(x,l,r); mid:=(l+r) &gt;&gt; 1; if en&lt;=mid then modify2(x*2,l,mid,st,en,w) else if st&gt;mid then modify2(x*2+1,mid+1,r,st,en,w) else begin modify2(x*2,l,mid,st,mid,w); modify2(x*2+1,mid+1,r,mid+1,en,w); end; h[x].v:=(int64(h[x*2].v) * h[x*2+1].v) mod mo; end;end;procedure query(x,l,r,st,en:longint);var mid:longint;begin if (st&lt;=l) and (r&lt;=en) then begin times(ret,h[x].v); end else begin change(x,l,r); mid:=(l+r) &gt;&gt; 1; if en&lt;=mid then query(x*2,l,mid,st,en) else if st&gt;mid then query(x*2+1,mid+1,r,st,en) else begin query(x*2,l,mid,st,mid); query(x*2+1,mid+1,r,mid+1,en); end; h[x].v:=(int64(h[x*2].v) * h[x*2+1].v) mod mo; end;end;procedure enter(x,i:longint);var y:longint;begin y:=abs(x) mod hamo; while hash[y,1]&lt;&gt;0 do y:=(y+1) mod hamo; hash[y,1]:=i; hash[y,2]:=xend;function ha(x:longint):longint;var y:longint;begin y:=abs(x) mod hamo; while hash[y,2]&lt;&gt;x do y:=(y+1) mod hamo; exit(hash[y,1]);end;begin readln(n); for i:=1 to n do begin read(q[i,1],q[i,2],q[i,3]); if q[i,1]&lt;&gt;2 then read(q[i,4]); inc(t); a[t]:=q[i,2]; inc(t); a[t]:=q[i,3]; end; qsort(a,1,t); kk:=a[1]; for i:=2 to t do begin if kk&lt;&gt;a[i] then begin inc(sum); enter(kk,sum); len[sum]:=a[i]-kk; kk:=a[i]; end; end; inc(sum); enter(a[t],sum); dec(sum); maketree(1,1,sum); for i:=1 to n do begin x:=ha(q[i,2]); y:=ha(q[i,3])-1; case q[i,1] of 0:begin z:=q[i,4]; modify1(1,1,sum,x,y,z); end; 1:begin z:=q[i,4]; modify2(1,1,sum,x,y,z); end; 2:begin ret:=1; query(1,1,sum,x,y); writeln(ret); end; end; end; end.]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>hash</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Find the Path]]></title>
    <url>%2F2015%2F08%2F17%2FFind-the-Path%2F</url>
    <content type="text"><![CDATA[DescriptionScofield刚从监狱里面跑出来，现在他要在进行大逃亡. 你也知道, 逃亡是非常不容易的, 现在Scofield遇到了一些困难, 你可以帮助他吗? Scofield面前的是一个美国的交通图, 图里面有一些城市, 有些城市之间有路连接. 路的长度scofield是知道的, 但是有些城市里面的警察很多, 所以scofield对这个问题很头疼. 他现在要安排一些逃亡路线, 所以他要对你做一些询问, 询问是这样的:某两个城市之间的最短路是什么? 但是这个最短路有个前提, 那就是路径上的每个城市里的警察不得超过k个. 起点和终点除外. Input有多组测试数据, 数据第一行是一个整数T表示测试数据的个数。每组测试数据以二个整数N，M 开始。N是城市个数，M是道路数。下面一行有n个数, 表示每个城市里面的警察的个数Ci.再下面m行, 每行有三个数, u, v, w.再下面有一个整数Q下面有Q行, 每行三个整数u, v, k表示,查询的内容为从u到v的警察数不超过k的最短路.(u, v上的警察不用计算在内). Technical Specification T &lt;= 20 2 &lt;= N &lt;= 200, 0 &lt;= M &lt;= n * (n – 1) / 2 0 &lt;= Ci &lt;= 1000,000,000 0 &lt;= u, v &lt; N, 0 &lt;= w &lt;= 1000, 0 &lt;= k &lt;= 1000,000,000 0&lt;= Q &lt;= 100000 没有多重边和自环边 对于每一个询问，u！= v。 输入数据后面有一个空行。 Output对于每一个询问，输出一行，表示最短路是什么，如果不存在的话就输出-1.每一个测试数据后面加一个空行。 Sample Input1234567891014 4100 2 3 1000 1 10 2 11 3 22 3 320 3 20 3 1 Sample Output 123-1 Analysis这题是要我们求最短路，但是最短路有一定的要求，就是最短路上的警察要不超过k个。再看看数据范围，N非常的小，组数也不多。再求最短路的诸多算法中，floyd算法虽然慢，但是他在处理一些特殊问题(带条件)时却能发挥它的重要作用。我们都知道floyd算法，是通过枚举中间点，进而求出最短路。在枚举中间点的时候，未枚举到的中间点，并不在所求的最短路内。所以根据这个特性，我们就可以再求最短路的同时，进而保证警察数k在一个范围内，然后在回答每一个问题。实现起来可能略微复杂，首先我们将原先图上的点进行重编号。按照点的警察数从小到大排序，顺次编号。现在对于图上编号为i的点，在[1..i-1]中的点他们的警察数k都比i点的警察数k小。在对新图做一次floyd最短路。对于后面的每个询问，将询问的&lt;u,v&gt;转化为新图的&lt;u,v&gt;。再从满足警察数&lt;=k个中选出一个最小的答案，作为此次询问的答案。整道题的算法复杂度为O((N^3+QN)*T)。其实复杂度还是蛮高的。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long LL;const long long INF = 1042521604759584125;const int N = 200+10;LL map[N][N][N];int pos[N];struct node&#123; int num,id; bool operator &lt; (node a) const &#123; return num &lt; a.num; &#125;&#125;cos[N];int main()&#123; //freopen("1061.in","r",stdin); int T; scanf("%d",&amp;T); while (T --) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for (int i = 0 ; i &lt; n ; i ++) &#123; scanf("%d",&amp;cos[i].num); cos[i].id = i; &#125; sort(cos,cos + n); for (int i = 0 ; i &lt; n ; i ++)\ &#123; pos[cos[i].id] = i+1; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) map[i][j][0]=INF; for (int i = 1 ; i &lt;= m ; i ++) &#123; int x,y,z; scanf("%d %d %d",&amp;x,&amp;y,&amp;z); map[pos[x]][pos[y]][0] = z; map[pos[y]][pos[x]][0] = z; &#125; for (int k = 1;k &lt;= n; k ++) &#123; for (int i = 1 ; i &lt;= n ; i ++) for (int j = 1 ; j &lt;= n ; j ++) map[i][j][k] = map[i][j][k - 1]; for (int i = 1 ; i &lt;= n ; i ++) for (int j = 1 ; j &lt;= n ; j ++) map[i][j][k] = min(map[i][j][k],map[i][k][k-1]+map[k][j][k-1]); &#125; int Q; scanf("%d",&amp;Q); while (Q --) &#123; int x,y,z; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); LL ans = map[pos[x]][pos[y]][0]; for (int i = n-1 ; i &gt;= 0; i --) &#123; if (cos[i].num &lt;= z) &#123; ans = map[pos[x]][pos[y]][i+1]; break; &#125; &#125; if (ans == INF) puts("-1"); else printf("%lld\n",ans); &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>floyd算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP】独立集(bubble)]]></title>
    <url>%2F2015%2F08%2F16%2F%E3%80%90NOIP%E3%80%91%E7%8B%AC%E7%AB%8B%E9%9B%86-bubble%2F</url>
    <content type="text"><![CDATA[Tips题目来源：http://www.luo.hustoj.com/problem.php?id=1287 Analysis从这个顺(dou)旺(bi)基同学的代码中，我们发现他的算法实际上是给逆序对连边，而独立集所在的集合中，任意两个都不存在连边(即不是逆序对)，那就是顺序的。并且题目要求我们要找出一个最大的独立集，求出他的长度，那就是要我们求最长不下降子序列，而因为给出的n个数是全排列。所以就是求最长上升子序列。这个可以用(nlogn)的二分查找求出。最关键的就是怎么求第二问最长上升子序列中那些点是必选的。 首先我们从左往右做一遍最长上升子序列，并得到他的数组f。f[i]表示以i结尾在[1..i]中的最长下上升子序列的长度同样我们从右往左最一遍最长下降子序列，并得到他的数组g。g[i]表示以i为结尾的在[i..n]中的最长下降子序列。 ans1表示第一个答案（即最长上升子序列）的值当f[i]+g[i]-1=ans1时，就说明这个点在其中一个最长上升子序列中（但不是第二题的合法位置）。所以我们要从这些点中找出唯一的点。如果在ans2的数组中发现一个位置有两个人已经使用过了，那么这个位置的答案就是不合法的。 我们来看一下下面这个例子： i 1 2 3 4 5a[i] 5 1 3 2 4f[i] 1 1 2 2 3g[i] 1 3 2 2 1 ans1=3其中，2 3 4 5都是任意最长上升子序列中的一部分，但是因为2 与 3 的f值重复了，所以这两个点就不是答案了。 现在还有一个问题就是如何快速的得到f和g数组。然而网上的O(N log N)只支持求长度而不能得到每一个f或g的值。而O(N^2)的算法又太慢了。因为这道题有一个关键的条件那就是： 输入的数据是全排列所以我们可以从左往右求f值，将每一个f值塞入到线段数的叶子[a[i],a[i]]中然后维护线段树的最大值，当计算下一个f[i]的值时，就询问线段书[1,a[i]]的区间中的最大值,将得到的最大值+1就是当前的f[i]值，重复这样的操作就的合法的f序列。正确性显然。当你从左往右添加时，由于在右边的f[i]值并没有塞入线段数中，所以询问[1,a[i]]时并不会得到那些f值，只有已经在i前面的f值才能得到，并且这些f值所对应的a[j]都要比a[i]小。就与O(n^2)的算法转移类似。具体实现可看代码。 Code然而此题并不需要如此复杂的线段树，只要支持单点修改和区间查询最大值即可。当然如果你有能力完全可以写树状数组。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970uses math;const maxn=100000;var i,n,maxx:longint; h:array[1..4*maxn,1..2] of longint; a,g,f,ans:array[1..maxn] of longint;procedure change(x,l,r,st,en,val:longint);var mid:longint;begin if (l=st) and (r=en) then begin inc(h[x,1],val);inc(h[x,2],val); end else begin inc(h[x+x,1],h[x,2]);inc(h[x+x,2],h[x,2]); inc(h[x+x+1,1],h[x,2]);inc(h[x+x+1,2],h[x,2]); h[x,2]:=0; mid:=(l+r)&gt;&gt;1; if en&lt;=mid then change(x+x,l,mid,st,en,val) else if st&gt;mid then change(x+x+1,mid+1,r,st,en,val) else begin change(x+x,l,mid,st,mid,val); change(x+x+1,mid+1,r,mid+1,en,val); end; h[x,1]:=max(h[x+x,1],h[x+x+1,1]); end;end;function quary(x,l,r,st,en:longint):longint;var mid:longint;begin if (l=st) and (r=en) then begin exit(h[x,1]); end else begin inc(h[x+x,1],h[x,2]);inc(h[x+x,2],h[x,2]); inc(h[x+x+1,1],h[x,2]);inc(h[x+x+1,2],h[x,2]); h[x,2]:=0; mid:=(l+r)&gt;&gt;1; if en&lt;=mid then exit(quary(x+x,l,mid,st,en)) else if st&gt;mid then exit(quary(x+x+1,mid+1,r,st,en)) else exit(max(quary(x+x,l,mid,st,mid),quary(x+x+1,mid+1,r,mid+1,en))); end;end;begin //assign(input,'3485.in');reset(input); readln(n); for i:=1 to n do read(a[i]); maxx:=0; fillchar(h,sizeof(h),0); for i:=1 to n do begin f[i]:=quary(1,1,n,1,a[i])+1; change(1,1,n,a[i],a[i],f[i]); maxx:=max(maxx,f[i]); end; fillchar(h,sizeof(h),0); for i:=n downto 1 do begin g[i]:=quary(1,1,n,a[i],n)+1; change(1,1,n,a[i],a[i],g[i]); end; for i:=1 to n do begin if (f[i]+g[i]-1=maxx) then begin if (ans[f[i]]&gt;0) or (ans[f[i]]=-1) then ans[f[i]]:=-1 else ans[f[i]]:=i; end; end; writeln(maxx); for i:=1 to maxx do if ans[i]&gt;0 then write(ans[i],' '); writeln;end.]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP】剑与魔法(dragons)]]></title>
    <url>%2F2015%2F08%2F16%2F%E3%80%90NOIP%E3%80%91%E5%89%91%E4%B8%8E%E9%AD%94%E6%B3%95(dragons)%2F</url>
    <content type="text"><![CDATA[Description万老师听说某大国很流行穿越，于是他就想写一个关于穿越的剧本。 闲话休提。话说老师穿越到了某一个剑与魔法的大陆。因为如此这般，所以老师从维娜艾那里得到了预言。老师一共被告知了若干件按顺序结算的事件。这些事件分为两类：战役事件（CASE）、穿越回去事件（END）。战役事件可以选择是否参加，参加了之后会获得一定的金钱。每个END事件发生需要至少参加一定数量的战役事件。特别的是，END事件如果满足要求就会强制发生。老师希望在大陆玩个够，所以他要求只有最后一个END事件会发生。老师希望获得最多的金钱，所以求助于你。 Input第一行一个数N，表示输入文件有多少行。 接下来每一行用空格隔开一个字符和一个整数。字符为“c”表示战役事件，接下来的整数表示这次涨RP顺带有多少钱；字符为“e”表示穿越回去事件，接下来的整数代表至少要涨多少RP。最后一个事件保证是END事件。 Output第一行一个整数，最多金钱数目。 若不可能则输出-1。 Sample Input1234565c 10c 12e 2c 1e 2 Sample Output113 Data Constraint30%的数据满足 N&lt;=20 60%的数据满足 N&lt;=1,000 100%的数据满足 N&lt;=200,000 每次涨RP事件赏金不超过10,000 穿越事件的要求不超过200,000 Analysis显然可以用堆来统计答案，一开始想用大根堆来统计答案，但是会发现有各种难以判断的地方。所以正难则反，我们可以维护一个小根堆。首先我们要把最后一个END事件去掉，在统计答案的过程中是没有用的。从前往后坐，每次遇到CASE事件，都将对应的金钱push进堆中，每次遇到END事件都将大于END时间限制个数的金钱pop，答案就是做到最后堆中剩余金钱的总和。最后再看看堆中的元素个数是否大于最后一个END的限制值。(然而我并没有判(^__^)嘻嘻) Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const maxn=200000;oo=100000000;var i,j,n,size,last,t:longint; h:array[1..maxn] of longint; a:array[0..maxn,1..2] of longint; b:array[0..maxn] of longint; ch:char; ans:int64;procedure swap(var x,y:longint);var t:longint;begin t:=x; x:=y; y:=t;end;procedure down(x:longint);var y:longint;begin y:=2*x; while ((y&lt;=size) and (h[x]&gt;h[y])) or ((y+1&lt;=size) and (h[x]&gt;h[y+1])) do begin if (y+1&lt;=size) and (h[y+1]&lt;h[y]) then inc(y); swap(h[x],h[y]); x:=y; y:=2*x; end;end;procedure up(x:longint);begin while (x&gt;1) and (h[x]&lt;h[x&gt;&gt;1]) do begin swap(h[x],h[x&gt;&gt;1]); x:=x&gt;&gt;1; end;end;procedure pop;begin h[1]:=h[size]; h[size]:=oo; dec(size); down(1);end;procedure push(x:longint);var i:longint;begin inc(size); h[size]:=x; up(size);end;begin readln(n); for i:=1 to n do begin readln(ch,a[i,2]); if ch='c' then a[i,1]:=1 else a[i,1]:=2; end; for i:=1 to n-1 do begin if a[i,1]=1 then push(a[i,2]) else begin t:=a[i,2]-1; while size&gt;t do pop; end; end; ans:=0; for i:=1 to size do inc(ans,h[i]); writeln(ans);end.]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3732 Network]]></title>
    <url>%2F2015%2F08%2F11%2Fbzoj3732-Network%2F</url>
    <content type="text"><![CDATA[Description题目来源bzoj3732 Analysis这题给的输入是一个无向连通图，说明图中会有环和一些树枝。对于一个询问在环上的两个点，有两条可以联通的道路。一条中的边权最大值是整个环的最大值（舍弃），另一条的边权最大值是整个环的次大值（需要）。所以只有次大值才是我们想要的！因此，我们想到了最小生成树，将这些环中的最大边权值所属的边删掉。最小生成树的求法就是，先让边权从小到大排序，然后依次添加并用并查集维护即可。（Kruskal算法） 所以，现在问题就转化成在一棵树中，求任意两点A，B路径上边权的最大值。 此时我们就需要求LCA了，并维护两点到LCA边权的最大值，在做LCA的时候使用倍增算法，再配上RMQ问题中的st算法即可解决问题。 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N=30000+100,M=30000+100;struct node&#123;int x,y,d;&#125;c[N];struct node1&#123;int y,v,next;&#125;h[2*M];int n,m,k,u,v,tot,e[N],fw[N][16],fv[N][16],fa[N],dep[N];bool cmp(node a, node b) &#123;return a.d&lt;b.d;&#125;int gf(int x)&#123; if (fa[x] == x) return x; return fa[x] = gf(fa[x]);&#125;void add(int x,int y,int z)&#123; tot ++; h[tot].y = y; h[tot].v = z; h[tot].next=e[x]; e[x] = tot;&#125;void dfs(int x ,int fat)&#123; for (int i = e[x];i;i = h[i].next) if (h[i].y!=fat) &#123; dep[h[i].y] = dep[x]+1; dfs(h[i].y,x); fv[h[i].y][0] = h[i].v; fw[h[i].y][0] = x; &#125;&#125;int move(int &amp;x,int d)&#123; int i,t=0; while (dep[fw[x][0]]!=d) &#123; for (i = 0;dep[fw[x][i]]&gt;d;i++); t = max(t,fv[x][i-1]); x = fw[x][i-1]; &#125; t = max(t,fv[x][0]); x = fw[x][0]; return t;&#125;int lca(int u,int v)&#123; int i,t = 0; if (dep[u]&gt;dep[v]) t = move(u,dep[v]); else if (dep[u]&lt;dep[v]) t = move(v,dep[u]); while (fw[u][0]!=fw[v][0]) &#123; for (i = 0;fw[u][i] != fw[v][i];i ++); t = max(t,max(fv[u][i-1],fv[v][i-1])); u = fw[u][i-1]; v = fw[v][i-1]; &#125; if (u!=v) t = max(max(fv[u][0],fv[v][0]),t); return t;&#125;int main()&#123; //freopen("1738.in","r",stdin); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for (int i=1;i &lt;= m ; i ++) scanf("%d%d%d",&amp;c[i].x,&amp;c[i].y,&amp;c[i].d); sort(c+1,c+1+m,cmp); for (int i=1 ; i &lt;= n ; i ++) fa[i]=i; for (int i=1 ; i &lt;= m ; i ++) &#123; if (gf(c[i].x)!=gf(c[i].y)) &#123; add(c[i].x,c[i].y,c[i].d); add(c[i].y,c[i].x,c[i].d); fa[fa[c[i].x]] = fa[fa[c[i].y]]; &#125; &#125; dep[1] = 1; dfs(1,0); for (int j=1 ; j &lt;= 14; j ++) for (int i=1 ;i&lt;=n;i ++) if (fw[fw[i][j-1]][j-1] != 0)//limit excepeted &#123; fw[i][j] = fw[fw[i][j-1]][j-1]; fv[i][j] = max(fv[i][j-1],fv[fw[i][j-1]][j-1]); &#125; for (int i = 1 ; i &lt;= k ; i ++) &#123; int u,v; scanf("%d%d",&amp;u,&amp;v); printf("%d\n",lca(u,v)); &#125; return 0;&#125; TipsKruskal算法LCA 倍增算法RMQ st算法]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>LCA</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[铺砖问题]]></title>
    <url>%2F2015%2F08%2F11%2F%E9%93%BA%E7%A0%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Description用1×2的 砖头铺满N*M的区域，不能有重叠，一共有多少种方案？如下图所示： Data Constraint20%的数据满足1&lt;=N,M&lt;=650%的数据满足1&lt;=N&lt;=100,1&lt;=M&lt;=11另外50%的数据满足1&lt;=N&lt;=10^200,1&lt;=M&lt;=5 Analysis对于此题的前50%的数据可以参照此位大神的解析：http://blog.csdn.net/yan_____/article/details/8719748我的程序前50%就是参考了这篇文章 对于100%的数据 我们发现N很大，但是M却很小。 前50%的数据我们都是通过不同的二进制状态转移并累加得到的。这种转移就显然就是矩阵自乘的结果。而他的答案就是$a[(1 shl m)-1,(1 shl m)-1]$,表示从(1 shl m)-1转移到(1 shl m)-1的方案数。 那么我们可以将前50%数据得到的st数组中的对应值映射到[0..1 shl m,0..1 shl m]的矩阵中，然后将这个矩阵自乘n次即可得到答案。 矩阵自乘可以用快速幂进行优化。 因为做一次矩阵乘法的时间复杂度为$O(N^3)$。所以整体的时间复杂度为$O((2^m)^3*log(10^100)/log(2))$。 因为n极其的庞大所以在做快速幂时我们需要用到单精除。 可能很多人会不理解为什么用矩阵乘法和为什么答案是$a[(1 shl m)-1,(1 shl m)-1]$。(懂得人可以忽略此部分内容) 对于每一层来说，因为st数组中$st[i][0] $都可以到$st[i][1]$ 。所以我们首先想想最简单的情况:当n=1时，他的答案就是从$dp[0][1 shl m-1]$ 到$dp[1][1 shl m-1] $。就是 $base[1 shl m -1] [1 shl m-1]$。当n=2 时，我们可以看看矩阵乘法的工作原理 对于答案$ans[i,j] += a[i,k]*a[k,j]$，他是通过枚举k将第i行和第j列一一对应相乘并累加的道德结果。而在我们的基础矩阵base存放的就是第i行的状态可以转移到哪j个状态。当你要从i这个状态到j这个状态，我们可以枚举一个中间点k让i先到k，再从k到j,这样恰好进行了两次转移所以这个ans矩阵，就代表从第i个状态经过了n次转移(看你乘了多少次)到达第j个状态的方案数。其实矩阵乘法可以类比floyd求最短路的算法。 Code因为代码比较丑，所以不要见怪123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116const maxn=100+5;maxm=10+5; mo=1000000007;len=17;size=(1 shl 5);jw=100000000000000000;type bignum=array[0..15] of int64; matrix=array[0..size,0..size] of int64;var i,j,m,n,tot,tmp:longint; st:array[0..(1 shl maxm),0..1] of longint; dp:array[0..maxn,0..(1 shl maxm)] of int64; s,nn,mm:string; base,ans:matrix; n1:bignum; sum:int64;procedure dfs(n,from,next:longint);begin if (n&gt;m) then begin exit; end; if (n=m) then begin st[tot][0]:=from; st[tot][1]:=next; inc(tot); exit; end; dfs(n+2,(from&lt;&lt;2)+3,(next&lt;&lt;2)+3); dfs(n+1,(from&lt;&lt;1)+1,(next&lt;&lt;1)); dfs(n+1,(from&lt;&lt;1),(next&lt;&lt;1)+1);end;procedure div2(var x:bignum);var i,t:longint;begin t:=0; for i:=x[0] downto 1 do begin x[i]:=t*jw+x[i]; t:=x[i] mod 2; x[i]:=x[i] div 2; if x[i]=0 then x[0]:=i-1; end;end;procedure stom(var s:string;var num:bignum);var ts:string[len]; i:longint;begin fillchar(num,sizeof(num),0); ts:=''; for i:=length(s) downto 1 do begin ts:=s[i]+ts; if length(ts)=len then begin inc(num[0]); val(ts,num[num[0]]); ts:=''; end; end; if ts&lt;&gt;'' then begin inc(num[0]); val(ts,num[num[0]]); end;end;function mul(x,y:matrix):matrix;//矩阵乘法var i,j,k,size1:integer; z:matrix;begin size1:=(1&lt;&lt;m); fillchar(z,sizeof(z),0); for i:=0 to size1 do for j:=0 to size1 do for k:=0 to size1 do begin z[i,j]:=(z[i,j]+x[i,k]*y[k,j])mod mo; end; exit(z);end;procedure work(y:bignum);begin fillchar(ans,sizeof(ans),0); for i:=0 to (1&lt;&lt;m) do ans[i][i]:=1; //单位矩阵，就是实数中的1 while (y[0]&lt;&gt;0) do begin if odd(y[1]) then begin ans:=mul(ans,base); end; base:=mul(base,base); div2(y); end;end;begin readln(s); tmp:=pos(' ',s); nn:=copy(s,1,tmp-1); mm:=copy(s,tmp + 1,length(s) - tmp);val(mm,m); tot:=0; dfs(0,0,0); if (length(nn)&lt;=2) or (nn='100') then begin //前50%的做法 val(nn,n); if odd(n*m) then begin writeln(0); exit; end; dp[0][(1&lt;&lt;m)-1]:=1; for i:=1 to n do for j:=0 to tot-1 do begin dp[i][st[j][1]]:=(dp[i][st[j][1]]+dp[i-1][st[j][0]]) mod mo; end; writeln(dp[n][(1&lt;&lt;m)-1]); end else begin fillchar(base,sizeof(base),0); for j:=0 to tot-1 do begin base[st[j][0]][st[j][1]]:=1; end; //初始化基础对应矩阵 stom(nn,n1);//将nn这个字符串转化为高精度数组 work(n1);//快速幂做矩阵乘法 sum:=ans[(1&lt;&lt;m)-1][(1&lt;&lt;m)-1]; writeln(sum mod mo); end;end. Tips此题源自：zoj1100http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1100据说此题有通项公式，具体请看维基百科https://en.wikipedia.org/wiki/Domino_tiling]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP2013模拟联考9】阿Q的停车场]]></title>
    <url>%2F2015%2F08%2F11%2F%E3%80%90NOIP2013%E6%A8%A1%E6%8B%9F%E8%81%94%E8%80%839%E3%80%91%E9%98%BFQ%E7%9A%84%E5%81%9C%E8%BD%A6%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[Description刚拿到驾照的KJ 总喜欢开着车到处兜风，玩完了再把车停到阿Q的停车场里，虽然她对自己停车的水平很有信心，但她还是不放心其他人的停车水平，尤其是Kelukin。于是，她每次都把自己的爱车停在距离其它车最远的一个车位。KJ 觉得自己这样的策略非常科学，于是她开始想：在一个停车场中有一排车位，从左到右编号为 1 到 n，初始时全部是空的。有若干汽车，进出停车场共 m 次。对于每辆进入停车场的汽车，会选择与其它车距离最小值最大的一个车位，若有多个符合条件，选择最左边一个。KJ 想着想着就睡着了，在她一旁的Kelukin想帮她完成这个心愿，但是他又非常的懒，不愿意自己动手，于是就把这个问题就留给了你：在KJ 理想的阿 Q 的停车场中，给你车辆进出的操作序列，依次输出每辆车的车位编号。 Input第一行，两个整数 n 和 m，表示停车场大小和操作数； 接下来 m 行，每行两个整数，F 和 x F 是 1 表示编号为 x 的车进停车场； F 是 2 表示编号为 x 的车出停车场； 保证操作合法，即： 出停车场的车一定目前仍在停车场里； 停车场内的车不会超过 n； Output对于所有操作 1，输出一个整数，表示该车车位的编号。 Sample Input7 111 151 1231231 31 52 1231232 151 212 31 61 71 8 Sample Output17427413 Data Constraint对30%的数据 n&lt;=1000 ，m&lt;=1000对60%的数据 n&lt;=200000，m&lt;=2000对100%的数据n，m&lt;=200000，车的编号小于等于 10^6 Analysis我当时一看此题，就觉得第一第二个插入操作的输出很奇怪。实际上，我们们不能认为在[1..n]个停车位中，第0个与第n+1个停有车。所以说处理此类情况要特判。对于其他情况就是找出一段最长未停车线段,然后它的答案除以二就是距离最远车的距离,再根据前面第1个位置与第n个位置的特判得出答案。 对于30%数据 通过暴力的O(n*m)就可以得出答案。先建立一个长度为n的bool数组，标示每个位置是否被车占用。用一个car[1e6]数组表示每一辆车对应的编号。再用一个a[N]数组表示各个位置距离两旁(或一旁)的车(0与n-1不能算做有车)的最近距离.对于 1 询问:通过前后各扫描一次,更新a数组,再从a数组中找出一个最大的位置，将车停在那里。O(N)对于 2 询问:只需从car数组中找到该车的位置将其删除即可，O(1) 对于60%数据嘿嘿，我也不知道了！ 对于100%数据我是用线段树来实现的。(据某位大神说，可以用堆来做。然而我并不会)用线段树还是相对简单的。首先我们对区间[1..n]开一课线段树。对于每一个节点，维护4个值。分别是l,r,mid,p。l表示在当前结点线段树所在区间，最左边的车停的位置。同理，r表示做右边的车所停的位置。mid表示在这个小区间[l,r]中的紧邻的两辆车的最长距离除以2后的值。p表示取得mid值是所在的紧邻的两辆车的中间位置，也就是在[l,r]中的答案值。 对于 1 询问：访问线段树的第一个节点，我们比较l-1，n-r，mid的值哪个更大，就选哪个，它们的答案依次是1,n,mid。假设我们求得的位置是car[x]。然后访问[car[x],car[x]]所在的线段树的叶子节点，初始化它的值，然后回溯，进行合并。对于h[x].l与h[x].r可以通过两个儿子的l,r信息得出。对于h[x].mid值,首先在左右儿子的mid值中去一个最大的值。其次考虑一种情况，就是夹在两个线段之间的距离，可以通过(h[x+x+1].l-h[x+x].r) div 2 的值得出在于mid进行比较，然后p就随着mid的值的更新而更新。对于2询问：访问询问车所在的位置，直接将它的叶子节点[car[x],car[x]]删除，然后回溯时，再做一次合并操作。即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const maxc=1000005;maxn=200005;type node=record l,r,mid,p:longint; end;var i,j,k,m,n,ch,num,sum:longint; car:array[1..maxc] of longint; h:array[1..4*maxn] of node;procedure merger(x:longint);var t:longint;begin if h[x+x].l&gt;0 then h[x].l:=h[x+x].l else h[x].l:=h[x+x+1].l; if h[x+x+1].r&gt;0 then h[x].r:=h[x+x+1].r else h[x].r:=h[x+x].r; h[x].mid:=h[x+x].mid; h[x].p:=h[x+x].p; if (h[x+x+1].l&gt;0) and (h[x+x].r&gt;0) then begin t:=(h[x+x+1].l-h[x+x].r) div 2; if t&gt;h[x].mid then begin h[x].mid:=t; h[x].p:=(h[x+x+1].l+h[x+x].r) div 2; end; if h[x+x+1].mid&gt;h[x].mid then begin h[x].mid:=h[x+x+1].mid; h[x].p:=h[x+x+1].p; end; end;end;procedure work(x,l,r,num,kind:longint);var mid:longint;begin if l=r then begin if kind=2 then begin h[x].l:=0;h[x].r:=0; h[x].mid:=0;h[x].p:=0; end else begin h[x].l:=l;h[x].r:=r; h[x].mid:=0;h[x].p:=0; end; exit; end; mid:=(l+r)&gt;&gt;1; if num&lt;=mid then work(x+x,l,mid,num,kind) else work(x+x+1,mid+1,r,num,kind); merger(x);end;begin readln(n,m); for i:=1 to m do begin readln(ch,num); if ch=1 then begin if h[1].l=0 then begin car[num]:=1; end else begin sum:=-maxlongint; if h[1].l-1&gt;sum then begin sum:=h[1].l-1; car[num]:=1; end; if h[1].mid&gt;sum then begin sum:=h[1].mid; car[num]:=h[1].p; end; if n-h[1].r&gt;sum then begin sum:=n-h[1].r; car[num]:=n; end; end; writeln(car[num]); work(1,1,n,car[num],1); end else begin work(1,1,n,car[num],2); end; end;end.]]></content>
      <categories>
        <category>信息学</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽签程序]]></title>
    <url>%2F2013%2F11%2F09%2F%E6%8A%BD%E7%AD%BE%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最新版本：2.5Version 2.5(2017届)下载地址：http://pan.baidu.com/s/1gdFBcmJVersion 2.3(2014届)下载地址：http://pan.baidu.com/s/1gdq85F1Version 2.3(2015届)下载地址：http://pan.baidu.com/s/1kTIkIFl]]></content>
      <categories>
        <category>易语言</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cc软件集]]></title>
    <url>%2F2012%2F03%2F24%2Fcc%E8%BD%AF%E4%BB%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[cc软件集最新版本Version 3.1cc软件集3.1安装包地址http://pan.baidu.com/s/1i3kyJLrcc软件集3.0安装包地址http://pan.baidu.com/s/1gdyFUYRcc软件集2.9安装包地址http://pan.baidu.com/s/1hqfbdZYcc软件集2.7安装包地址http://pan.baidu.com/s/1mgvhSEkcc软件集2.5安装包地址http://pan.baidu.com/s/1o6xfH1occ软件集2.3安装包地址http://pan.baidu.com/s/1ntxhKtr目前没有升级补丁或升级包 如有疑问，请发送邮件至:liuyuanzhe0515]]></content>
      <categories>
        <category>易语言</category>
        <category>原创</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
</search>
